# XLN 2D Birdview Specification

This document describes the target behaviour, architecture, and implementation plan for the new 2D network visualisation. The goal is to deliver a deterministic, ultra-performant canvas-based view that can render 10k+ entities and their bilateral accounts while preserving the visual language of the existing 3D topology (credit/collateral bars, hub glow, live activity).

## 1. Product Goals

- **Always-on alternative to 3D** – users can flip between the current WebGL birdview and this 2D map with zero data loss.
- **Dense network support** – smooth 60 FPS interaction for 10,000 nodes and 50,000+ edges on a modern laptop.
- **Invariant visual language** – leverage the same colours for credit/collateral (light red / green) and Δ marker. Lines remain 3 px minimal bars showing invariant segments.
- **Live + historical support** – the view must respond to the same `visibleReplicas`, `visibleGossip`, and time-machine snapshots as other components.
- **Zero overdraw from 3D stack** – independent Svelte component that does not pollute existing Three.js code paths.

## 2. Component Outline

- `frontend/src/lib/components/Network/NetworkTopology2D.svelte`
  - Canvas container + UI chrome (zoom slider, pause physics, legend toggle).
  - Integrates with `viewModeStore` (or existing state once available) so navigation can flip views.
- `frontend/src/lib/components/Network/force2d.ts`
  - Deterministic layout engine (hash-seeded initial placement + force integration step).
  - Exposes `createLayout(state)` returning `{ nodes, edges, tick(dt) }`.
- `frontend/src/lib/components/Network/render2d.ts`
  - Low-level renderer. Accepts layout buffers and draws to `CanvasRenderingContext2D`.
  - Batch draws using `ctx.drawImage` on cached offscreen canvases for repeated gradients (e.g., hub glow, delta marker).

## 3. Data Flow & Stores

```
visibleReplicas/time-store => mapEntities()
                              \=> layoutEngine.update()
canvas animation loop => render2d.draw(layoutState)
```

- **Sources**: `visibleReplicas`, `visibleGossip`, `currentTimeIndex`, `isLive`, `xlnFunctions.deriveDelta`.
- **Derived state**:
  - `nodes`: `{ id, hashSeed, radius, hubScore, activityTimestamp, pinnedPosition? }`.
  - `edges`: `{ key, from, to, deltaData, segments, lastPaymentTimestamp }`.
  - Layout engine keeps a `Float32Array` for positions/velocities to minimise GC churn.

## 4. Layout Algorithm

### 4.1 Initial Placement

- Hash entity id to generate deterministic polar coordinates.
  - `angle = murmurhash(entityId) * 2π`
  - `radius = baseRadius + spreadFactor * log(index + 1)`
- Store seed so layout is stable across sessions.

### 4.2 Force Integration

- Integrator: velocity–Verlet with high damping (0.85) and 16 ms step.
- Forces:
  1. **Spring Attraction** for edges (`k_edge = 0.02`, rest length proportional to log(account total capacity)).
  2. **Repulsion** using Barnes–Hut quadtree (θ = 0.9). Forces capped to avoid jitter.
  3. **Centering** to keep network within viewport.
- Hub nodes get extra mass (stability) so they anchor the “H” shape.
- Each frame, engine updates nodes’ positions; edges reuse endpoints.
- Physics can be paused (important when inspecting details).

### 4.3 Pinned Layout

- When a user drags a node, mark `pinned = true` and zero forces.
- Stored in `localStorage` (shared with 3D view if we keep same key pattern `xln-entity-positions-2d`).

## 5. Rendering Strategy

### 5.1 Canvas Setup

- Primary `<canvas>` sized to viewport (`devicePixelRatio` aware).
- Offscreen canvases for reusable assets:
  - Hub glow gradient.
  - Delta marker disk.
  - Edge segment pattern (credit/collateral) rendered as 1×N textures stretched with `createPattern`.

### 5.2 Draw Order

1. Clear with alpha fade (if physics active) to create motion trails.
2. Draw edges:
   - Convert 3 segments (peer credit, collateral, own credit) into 3 tiny rectangles along the edge direction.
   - Use `ctx.save/restore` minimal times (batched by segment type).
   - Edge thickness fixed at `3 px`.
3. Draw payments/particles if needed – simple circle moving along edge (reuse 2019 logic but keep count low).
4. Draw nodes:
   - Fill circle with base colour.
   - If hub (top-degree), overlay glow from offscreen canvas.
   - Draw label using `ctx.fillText` only when zoomed in (avoid 10k text draws).
5. Draw UI overlays (legend, status) using DOM overlay rather than canvas text.

### 5.3 Interaction

- Mouse hover uses spatial index (same quadtree). On hover, show tooltip (Svelte overlay) with entity info and account Δ using existing formatting helpers.
- Dragging: convert screen coords to world coords, update pinned node, restart physics with a small jitter so layout adjusts.

## 6. API & Events

Component props/events:

```ts
export interface NetworkTopology2DProps {
  onRequestExit?: () => void;  // triggered by “Panels” icon or ESC in 2D view
  autoRotate?: boolean;        // optional future parity with 3D
}

export interface NetworkTopology2DExports {
  focusEntity(id: string): void;  // programmatic centring
  captureFrame(): HTMLCanvasElement; // screenshot support
}
```

Keyboard shortcuts (scoped when view is active):

- `Space`: pause/resume physics
- `+/-`: zoom
- `F`: focus selected entity
- `Esc`: emit `onRequestExit`

## 7. Performance Targets

| Load Case | GPU/CPU Budget | Notes |
|-----------|----------------|-------|
| 10k nodes, 50k edges | <16 ms/frame on M2 Air | Force step 4 ms, render 8 ms |
| Node drag | 60 FPS | throttle to `requestAnimationFrame` (no extra loops) |
| Time-machine jump | Layout reinit <80 ms | Pre-calc seeds; reuse physics buffers |

Optimisations:

- Reuse typed arrays for layout + rendering (positions, velocities, colours).
- Minimal allocations per frame; use object pool for tooltips/particles.
- Rebuild quadtree only when node positions change > threshold.
- Clip drawing by current viewport to avoid offscreen edges.

## 8. Integration Checklist

1. Introduce `viewModeStore.ts` (done) and wire AdminTopBar to use it.
2. Add `NetworkTopology2D.svelte` pushing to `frontend/src/lib/components/Network/` with sub modules.
3. Add `HomeView.svelte` & `TerminalView.svelte` (placeholders or basic content) to keep navigation functional.
4. Update `+page.svelte` to use the new store (ensure time-machine still renders below main view).
5. Update navigation styles (`view-switcher`) to support 5 tabs.
6. Run `bun run check` + smoke tests (prepopulate, time-travel, 2D interactions).

## 9. Implementation Phases

1. **Scaffold** – create new components, store, stub renderer (no physics) to ensure wiring works.
2. **Physics Engine** – implement layout/core force integration with placeholder rendering (circles + lines).
3. **Invariant Rendering** – add credit/collateral segments, delta markers, hover tooltips.
4. **Optimisations** – quadtree refactor, offscreen caches, profiling with Chrome DevTools.
5. **Polish** – add legend, settings, terminal/home integration final touches.

## 10. Open Questions

- Should hover tooltips display full entity panel data or a condensed summary?
- Do we need to sync camera state (zoom/pan) across 2D and 3D views?
- Terminal view may reuse existing stores; confirm command set before wiring.

---

This spec keeps the addition scoped to new Svelte modules and a small view-mode store so the existing Three.js topology and panel stack remain untouched. Implementation will follow the phases above, with `bun run check` executed after every batch of changes.
