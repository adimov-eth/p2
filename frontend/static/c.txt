contracts
├── Token.sol
├── EntityProvider.sol
├── ERC1155Mock.sol
├── ECDSA.sol
├── ERC20Mock.sol
├── Depository.sol
├── ERC721Mock.sol
├── console.sol
└── SubcontractProvider.sol


src
├── j-event-watcher.ts
├── account-utils.ts
├── financial-utils.ts
├── entity-consensus.ts
├── gossip.ts
├── rundemo.ts
├── debug-config.ts
├── utils.ts
├── entity-helpers.ts
├── jurisdiction-loader.ts
├── gossip-loader.ts
├── account-consensus.ts
├── types.ts
├── gossip-helper.ts
├── logger.ts
├── entity-tx
├── ├── validation.ts
├── ├── apply.ts
├── ├── proposals.ts
├── ├── financial.ts
├── ├── j-events.ts
├── ├── index.ts
├── └── handlers
├── └── └── account.ts
├── name-resolution.ts
├── serialization-utils.ts
├── test-hanko-basic.ts
├── snapshot-coder.ts
├── hanko-real.ts
├── routing
├── ├── pathfinding.ts
├── └── graph.ts
├── account-tx
├── ├── direct-payment.ts
├── ├── crypto.ts
├── ├── processor.ts
├── └── index.ts
├── evm.ts
├── state-helpers.ts
├── prepopulate.ts
├── server.ts
├── validation-utils.ts
├── run-hanko-tests.ts
└── entity-factory.ts


docs
├── hanko-architecture.md
├── DEPLOYMENT_LESSONS.md
├── consensus
├── └── transaction-flow-specification.md
├── limitorderbook.md
├── xln-pitch-guide.md
├── CONTRACT_DEPLOYMENT.md
├── summary.md
├── claudecode
├── └── account-master-plan.md
├── next.md
├── debugging
├── └── consensus-debugging-guide.md
├── payment-spec.md
├── novelty.md
├── foundation-governance.md
├── faq.md
├── invariant.md
├── server
├── └── README.md
├── documentation-updates-summary.md
├── README.md
├── fixed-supply-analysis.md
├── architecture
├── └── xln-visual-debugger-architecture.md
├── sessions
├── ├── template.md
├── ├── reserve_credit.md
├── ├── financial_infrastructure.md
├── ├── core_principles.md
├── ├── sonnet_on_merkle.md
├── └── channel_architecture.md
├── session-summary-2025-01-16.md
├── VULTR_DEPLOYMENT.md
├── ui-ux
├── └── visual-debugger-design-patterns.md
├── guide.md
├── philosophy
├── ├── tradfi-plus-defi-equals-xln.md
├── ├── programmable-entities.md
├── └── the-data-sovereignty-manifesto.md
├── evolution-analysis-2019-2025.md
├── contract-architecture.md
├── governance-architecture.md
├── honest-systems-comparison.md
├── claudecode.md
├── JEA.md
├── entity-control-shares-tradfi-comparison.md
├── guide-ru.md
├── memo-to-model.md
├── pure-technical-comparison.md
└── xln-adoption-roadmap.md


--- contracts/Token.sol ---
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;

interface Token {
    /// @return supply total amount of tokens
    function totalSupply() external view returns (uint256 supply);

    /// @param _owner The address from which the balance will be retrieved
    /// @return balance The balance
    function balanceOf(address _owner) external view returns (uint256 balance);

    /// @notice send `_value` token to `_to` from `msg.sender`
    /// @param _to The address of the recipient
    /// @param _value The amount of token to be transferred
    /// @return success Whether the transfer was successful or not
    function transfer(address _to, uint256 _value) external returns (bool success);

    /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`
    /// @param _from The address of the sender
    /// @param _to The address of the recipient
    /// @param _value The amount of token to be transferred
    /// @return success Whether the transfer was successful or not
    function transferFrom(address _from, address _to, uint256 _value) external returns (bool success);

    /// @notice `msg.sender` approves `_spender` to spend `_value` tokens
    /// @param _spender The address of the account able to transfer the tokens
    /// @param _value The amount of wei to be approved for transfer
    /// @return success Whether the approval was successful or not
    function approve(address _spender, uint256 _value) external returns (bool success);

    /// @param _owner The address of the account owning tokens
    /// @param _spender The address of the account able to transfer the tokens
    /// @return remaining Amount of remaining tokens allowed to spent
    function allowance(address _owner, address _spender) external view returns (uint256 remaining);

    event Transfer(address indexed _from, address indexed _to, uint256 _value);
    event Approval(address indexed _owner, address indexed _spender, uint256 _value);

    // Optionally implemented function to show the number of decimals for the token
    function decimals() external view returns (uint8 dec);
}

--- contracts/EntityProvider.sol ---
// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.24;

import "./Token.sol";
import "@openzeppelin/contracts/token/ERC1155/ERC1155.sol";
import "./ECDSA.sol";
import "hardhat/console.sol";

contract EntityProvider is ERC1155 { 
  struct Entity {
    bytes32 currentBoardHash;    // 0x0 = lazy entity (entityId == boardHash)
    bytes32 proposedBoardHash;   // Pending board transition
    uint256 activateAtBlock;     // When proposed board becomes active
    uint256 registrationBlock;   // When entity was registered (0 for lazy)
    ProposerType proposerType;   // Who proposed the current transition
    bytes32 articlesHash;        // Governance config hash
  }

  struct Board {
    uint16 votingThreshold;
    bytes32[] entityIds;        // Parallel arrays for efficiency
    uint16[] votingPowers;      // Must match entityIds length
    uint32 boardChangeDelay;    // Board → Board transitions (blocks)
    uint32 controlChangeDelay;  // Control → Board transitions (blocks)  
    uint32 dividendChangeDelay; // Dividend → Board transitions (blocks)
  }

  struct EntityArticles {
    uint32 controlDelay;      // Delay for control shareholders (X blocks)
    uint32 dividendDelay;     // Delay for dividend shareholders (X*3 blocks)  
    uint32 foundationDelay;   // Delay for foundation (X*10 blocks, 0=disabled)
    uint16 controlThreshold;  // % of control tokens needed for quorum replacement
  }

  enum ProposerType { BOARD, CONTROL, DIVIDEND }

  struct BoardProposal {
    bytes32 proposedBoardHash;
    ProposerType proposerType;
    uint256 proposeBlock;
    uint256 activateBlock;
    bool active;
  }

  // Core entity storage - single mapping for all entities
  mapping(bytes32 => Entity) public entities;
  
  // Sequential numbering for registered entities
  uint256 public nextNumber = 1;
  

  
  // Name system (decoupled from entity IDs)
  mapping(string => uint256) public nameToNumber;  // "coinbase" => 42
  mapping(uint256 => string) public numberToName;  // 42 => "coinbase"
  mapping(string => bool) public reservedNames;    // Admin-controlled names
  
  // Foundation controls (no centralized admin)
  mapping(address => uint8) public nameQuota;      // User name allowances
  
  // Governance system
  mapping(bytes32 => BoardProposal) public activeProposals;  // entityId => proposal
  mapping(bytes32 => uint256) public totalControlSupply;      // entityId => total control tokens
  mapping(bytes32 => uint256) public totalDividendSupply;     // entityId => total dividend tokens
  
  // Fixed token supplies for all entities (immutable and fair)
  uint256 public constant TOTAL_CONTROL_SUPPLY = 1e15;   // 1 quadrillion (max granularity)
  uint256 public constant TOTAL_DIVIDEND_SUPPLY = 1e15;  // 1 quadrillion (max granularity)

  // Foundation entity (always #1)
  uint256 public constant FOUNDATION_ENTITY = 1;

  // Events
  event EntityRegistered(bytes32 indexed entityId, uint256 indexed entityNumber, bytes32 boardHash);
  event NameAssigned(string indexed name, uint256 indexed entityNumber);
  event NameTransferred(string indexed name, uint256 indexed fromNumber, uint256 indexed toNumber);
  event BoardProposed(bytes32 indexed entityId, bytes32 proposedBoardHash);
  event BoardActivated(bytes32 indexed entityId, bytes32 newBoardHash);
  event GovernanceEnabled(bytes32 indexed entityId, uint256 controlTokenId, uint256 dividendTokenId);
  event ProposalCancelled(bytes32 indexed entityId, ProposerType cancelledBy);

  constructor() ERC1155("https://xln.com/entity/{id}.json") {
    // Reserve some premium names
    reservedNames["coinbase"] = true;
    reservedNames["ethereum"] = true;
    reservedNames["bitcoin"] = true;
    reservedNames["uniswap"] = true;
    
    // Create foundation entity #1 with governance
    bytes32 foundationQuorum = keccak256("FOUNDATION_INITIAL_QUORUM");
    bytes32 foundationId = bytes32(FOUNDATION_ENTITY);
    
    entities[foundationId] = Entity({
      currentBoardHash: foundationQuorum,
      proposedBoardHash: bytes32(0),
      activateAtBlock: 0,
      registrationBlock: block.number,
      proposerType: ProposerType.BOARD,
      articlesHash: keccak256(abi.encode(EntityArticles({
        controlDelay: 1000,
        dividendDelay: 3000,
        foundationDelay: 0, // Foundation can't replace itself
        controlThreshold: 51
      })))
    });
    
    // Setup governance for foundation entity
    (uint256 controlTokenId, uint256 dividendTokenId) = getTokenIds(FOUNDATION_ENTITY);
    address foundationAddress = address(uint160(uint256(foundationId)));
    
    _mint(foundationAddress, controlTokenId, TOTAL_CONTROL_SUPPLY, "");
    _mint(foundationAddress, dividendTokenId, TOTAL_DIVIDEND_SUPPLY, "");
    
    totalControlSupply[foundationId] = TOTAL_CONTROL_SUPPLY;
    totalDividendSupply[foundationId] = TOTAL_DIVIDEND_SUPPLY;
    
    emit GovernanceEnabled(foundationId, controlTokenId, dividendTokenId);
    
    nextNumber = 2; // Foundation takes #1, next entity will be #2
  }

  modifier onlyFoundation() {
    // Only foundation entity (via its governance tokens) can call admin functions
    bytes32 foundationId = bytes32(FOUNDATION_ENTITY);
    (uint256 controlTokenId,) = getTokenIds(FOUNDATION_ENTITY);
    require(balanceOf(msg.sender, controlTokenId) > 0, "Only foundation token holders");
    _;
  }

  /**
   * @notice Register a new numbered entity with automatic governance setup
   * @param boardHash Initial board/quorum hash
   * @return entityNumber The assigned entity number
   */
  function registerNumberedEntity(bytes32 boardHash) external returns (uint256 entityNumber) {
    entityNumber = nextNumber++;
    bytes32 entityId = bytes32(entityNumber);
    
    // Create entity with default governance articles
    EntityArticles memory defaultArticles = EntityArticles({
      controlDelay: 1000,     // Default 1000 blocks for control
      dividendDelay: 3000,    // Default 3000 blocks for dividend  
      foundationDelay: 10000, // Default 10000 blocks for foundation
      controlThreshold: 51    // Default 51% threshold
    });
    
    entities[entityId] = Entity({
      currentBoardHash: boardHash,
      proposedBoardHash: bytes32(0),
      activateAtBlock: 0,
      registrationBlock: block.number,
      proposerType: ProposerType.BOARD,
      articlesHash: keccak256(abi.encode(defaultArticles))
    });
    
    // Automatically setup governance with fixed supply
    (uint256 controlTokenId, uint256 dividendTokenId) = getTokenIds(entityNumber);
    address entityAddress = address(uint160(uint256(entityId)));
    
    _mint(entityAddress, controlTokenId, TOTAL_CONTROL_SUPPLY, "");
    _mint(entityAddress, dividendTokenId, TOTAL_DIVIDEND_SUPPLY, "");
    
    totalControlSupply[entityId] = TOTAL_CONTROL_SUPPLY;
    totalDividendSupply[entityId] = TOTAL_DIVIDEND_SUPPLY;
    
    emit EntityRegistered(entityId, entityNumber, boardHash);
    emit GovernanceEnabled(entityId, controlTokenId, dividendTokenId);
    
    return entityNumber;
  }

  /**
   * @notice Foundation assigns a name to an existing numbered entity
   * @param name The name to assign (e.g., "coinbase")
   * @param entityNumber The entity number to assign the name to
   */
  function assignName(string memory name, uint256 entityNumber) external onlyFoundation {
    require(bytes(name).length > 0 && bytes(name).length <= 32, "Invalid name length");
    require(entities[bytes32(entityNumber)].currentBoardHash != bytes32(0), "Entity doesn't exist");
    require(nameToNumber[name] == 0, "Name already assigned");
    
    // If entity already has a name, clear it
    string memory oldName = numberToName[entityNumber];
    if (bytes(oldName).length > 0) {
      delete nameToNumber[oldName];
    }
    
    nameToNumber[name] = entityNumber;
    numberToName[entityNumber] = name;
    
    emit NameAssigned(name, entityNumber);
  }

  /**
   * @notice Transfer a name from one entity to another (foundation only)
   * @param name The name to transfer
   * @param newEntityNumber The target entity number
   */
  function transferName(string memory name, uint256 newEntityNumber) external onlyFoundation {
    require(nameToNumber[name] != 0, "Name not assigned");
    require(entities[bytes32(newEntityNumber)].currentBoardHash != bytes32(0), "Target entity doesn't exist");
    
    uint256 oldEntityNumber = nameToNumber[name];
    
    // Clear old mapping
    delete numberToName[oldEntityNumber];
    
    // Set new mapping
    nameToNumber[name] = newEntityNumber;
    numberToName[newEntityNumber] = name;
    
    emit NameTransferred(name, oldEntityNumber, newEntityNumber);
  }

  /**
   * @notice Propose a new board with proper BCD governance
   * @param entityId The entity ID  
   * @param newBoardHash The proposed new board hash
   * @param proposerType Who is proposing (BOARD, CONTROL, DIVIDEND)
   * @param articles Current governance articles (for verification)
   */
  function proposeBoard(
    bytes32 entityId, 
    bytes32 newBoardHash,
    ProposerType proposerType,
    EntityArticles memory articles
  ) external {
    require(entities[entityId].currentBoardHash != bytes32(0), "Entity doesn't exist");
    require(keccak256(abi.encode(articles)) == entities[entityId].articlesHash, "Invalid articles");
    
    // Check permissions and delays
    uint32 delay = _getDelayForProposer(articles, proposerType);
    require(delay > 0, "Proposer type disabled");
    
    // Verify proposer has the right to propose based on type
    if (proposerType == ProposerType.CONTROL) {
      // Control holders can override any proposal
      // TODO: Verify msg.sender has control tokens
    } else if (proposerType == ProposerType.BOARD) {
      // Current board can propose (shortest delay)
      // TODO: Verify msg.sender is current board member
    } else if (proposerType == ProposerType.DIVIDEND) {
      // Dividend holders can propose (longest delay)
      // TODO: Verify msg.sender has dividend tokens
    }
    
    // Cancel any existing proposal that can be overridden
    if (entities[entityId].proposedBoardHash != bytes32(0)) {
      require(_canCancelProposal(proposerType, entities[entityId].proposerType), 
              "Cannot override existing proposal");
    }
    
    uint256 activateAtBlock = block.number + delay;
    
    entities[entityId].proposedBoardHash = newBoardHash;
    entities[entityId].activateAtBlock = activateAtBlock;
    entities[entityId].proposerType = proposerType;
    
    emit BoardProposed(entityId, newBoardHash);
  }

  /**
   * @notice Activate a previously proposed board (with delay enforcement)
   * @param entityId The entity ID
   */
  function activateBoard(bytes32 entityId) external {
    require(entities[entityId].currentBoardHash != bytes32(0), "Entity doesn't exist");
    require(entities[entityId].proposedBoardHash != bytes32(0), "No proposed board");
    require(block.number >= entities[entityId].activateAtBlock, "Delay period not met");
    
    entities[entityId].currentBoardHash = entities[entityId].proposedBoardHash;
    entities[entityId].proposedBoardHash = bytes32(0);
    entities[entityId].activateAtBlock = 0;
    
    emit BoardActivated(entityId, entities[entityId].currentBoardHash);
  }

  /**
   * @notice Cancel a pending board proposal
   * @param entityId The entity ID
   * @param proposerType Who is cancelling (BOARD, CONTROL, DIVIDEND)
   * @param articles Current governance articles (for verification)
   */
  function cancelBoardProposal(
    bytes32 entityId,
    ProposerType proposerType,
    EntityArticles memory articles
  ) external {
    require(entities[entityId].currentBoardHash != bytes32(0), "Entity doesn't exist");
    require(entities[entityId].proposedBoardHash != bytes32(0), "No proposed board");
    require(keccak256(abi.encode(articles)) == entities[entityId].articlesHash, "Invalid articles");
    
    // Check if this proposer type can cancel the existing proposal
    require(_canCancelProposal(proposerType, entities[entityId].proposerType), 
            "Cannot cancel this proposal");
    
    entities[entityId].proposedBoardHash = bytes32(0);
    entities[entityId].activateAtBlock = 0;
    
    emit ProposalCancelled(entityId, proposerType);
  }



  /**
   * @notice Recover entity ID from hanko signature (improved version of isValidSignature)
   * @param encodedBoard The entity's board data
   * @param encodedSignature The entity's signatures  
   * @param hash The hash that was signed
   * @return entityId The entity ID that signed this hash (0 if invalid)
   */
  function recoverEntity(
    bytes calldata encodedBoard, 
    bytes calldata encodedSignature, 
    bytes32 hash
  ) public view returns (uint256 entityId) {
    bytes32 boardHash = keccak256(encodedBoard);
    
    // First try to find registered entity with this board hash
    for (uint256 i = 1; i < nextNumber; i++) {
      bytes32 candidateEntityId = bytes32(i);
      if (entities[candidateEntityId].currentBoardHash != bytes32(0) && entities[candidateEntityId].currentBoardHash == boardHash) {
        // Verify signature for this registered entity
        uint16 boardResult = _verifyBoard(hash, encodedBoard, encodedSignature);
        if (boardResult > 0) {
          return i; // Return entity number
        }
      }
    }
    
    // If no registered entity found, try as lazy entity
    uint16 lazyResult = _verifyBoard(hash, encodedBoard, encodedSignature);
    if (lazyResult > 0) {
      return uint256(boardHash); // Return board hash as entity ID for lazy entities
    }
    
    return 0; // Invalid signature
  }

  /**
   * @notice Simplified board verification (calldata version)
   */
  function _verifyBoard(
    bytes32 _hash,
    bytes calldata encodedBoard,
    bytes calldata encodedSignature
  ) internal pure returns (uint16) {
    Board memory board = abi.decode(encodedBoard, (Board));
    bytes[] memory signatures = abi.decode(encodedSignature, (bytes[]));
    
    require(board.entityIds.length == board.votingPowers.length, "Board arrays length mismatch");
    
    uint16 voteYes = 0;
    uint16 totalVotes = 0;
    
    for (uint i = 0; i < board.entityIds.length && i < signatures.length; i++) {
      bytes32 entityId = board.entityIds[i];
      uint16 votingPower = board.votingPowers[i];
      
      // Check if this is an EOA (20 bytes when cast to address)
      if (uint256(entityId) <= type(uint160).max) {
        // Simple EOA verification
        address signer = address(uint160(uint256(entityId)));
        if (signer == _recoverSigner(_hash, signatures[i])) {
          voteYes += votingPower;
        }
        totalVotes += votingPower;
      }
      // Note: Nested entity verification handled by Hanko system
    }
    
    if (totalVotes == 0) return 0;
    if (voteYes < board.votingThreshold) return 0;
    
    return (voteYes * 100) / totalVotes;
  }



  /**
   * @notice Recover signer from signature
   */
  function _recoverSigner(bytes32 _hash, bytes memory _signature) internal pure returns (address) {
    if (_signature.length != 65) return address(0);
    
    bytes32 r;
    bytes32 s;
    uint8 v;
    
    assembly {
      r := mload(add(_signature, 32))
      s := mload(add(_signature, 64))
      v := byte(0, mload(add(_signature, 96)))
    }
    
    if (v < 27) v += 27;
    if (v != 27 && v != 28) return address(0);
    
    return ecrecover(_hash, v, r, s);
  }

  /**
   * @notice Validate entity exists (registered or lazy)
   * @param entityId The entity ID to validate
   * @param boardHash The board hash for validation
   * @return isLazy Whether this is a lazy entity
   */
  function _validateEntity(bytes32 entityId, bytes32 boardHash) internal view returns (bool isLazy) {
    if (entities[entityId].currentBoardHash == bytes32(0)) {
      // Lazy entity: entityId must equal boardHash
      require(entityId == boardHash, "Lazy entity: ID must equal board hash");
      return true;
    } else {
      // Registered entity: use stored boardHash
      require(boardHash == entities[entityId].currentBoardHash, "Board hash mismatch");
      return false;
    }
  }



  // Utility functions
  function resolveEntityId(string memory identifier) external view returns (bytes32) {
    // Try to resolve as name first
    uint256 number = nameToNumber[identifier];
    if (number > 0) {
      return bytes32(number);
    }
    
    // Try to parse as number
    // Note: This would need a string-to-uint parser in practice
    return bytes32(0);
  }

  function getEntityInfo(bytes32 entityId) external view returns (
    bool exists,
    bytes32 currentBoardHash,
    bytes32 proposedBoardHash,
    uint256 registrationBlock,
    string memory name
  ) {
    Entity memory entity = entities[entityId];
    exists = entity.currentBoardHash != bytes32(0);
    currentBoardHash = entity.currentBoardHash;
    proposedBoardHash = entity.proposedBoardHash;
    registrationBlock = entity.registrationBlock;
    
    // Get name if it's a numbered entity
    if (uint256(entityId) > 0 && uint256(entityId) < nextNumber) {
      name = numberToName[uint256(entityId)];
    }
  }

  // Admin functions
  function setReservedName(string memory name, bool reserved) external onlyFoundation {
    reservedNames[name] = reserved;
  }

  // === HANKO SIGNATURE VERIFICATION ===
  //
  // 🚨 CRITICAL DESIGN PHILOSOPHY: "ASSUME YES" FLASHLOAN GOVERNANCE 🚨
  //
  // This system INTENTIONALLY allows entities to mutually validate without EOA signatures.
  // This is NOT a bug - it's a feature that enables flexible governance structures.
  //
  // EXAMPLE OF INTENTIONAL "LOOPHOLE":
  // EntityA (threshold: 1) references EntityB at weight 100
  // EntityB (threshold: 1) references EntityA at weight 100
  // → Both pass validation with ZERO EOA signatures!
  //
  // WHY THIS IS INTENDED:
  // 1. UI/Application layer enforces policies (e.g., "require at least 1 EOA")
  // 2. Protocol stays flexible for exotic governance structures
  // 3. Real entities will naturally include EOAs for practical control
  // 4. Alternative would require complex graph analysis → expensive + still gameable
  //
  // POLICY ENFORCEMENT BELONGS IN UI, NOT PROTOCOL!

  struct HankoBytes {
    bytes32[] placeholders;    // Entity IDs that failed to sign (index 0..N-1)  
    bytes packedSignatures;    // EOA signatures → yesEntities (index N..M-1)
    HankoClaim[] claims;       // Entity claims to verify (index M..∞)
  }

  struct HankoClaim {
    bytes32 entityId;          // Entity being verified
    uint256[] entityIndexes;   // Indexes into placeholders + yesEntities + claims arrays
    uint256[] weights;         // Voting weights for each entity  
    uint256 threshold;         // Required voting power
  }
  
  // Events
  event HankoVerified(bytes32 indexed entityId, bytes32 indexed hash);
  event HankoClaimProcessed(bytes32 indexed entityId, bool success, uint256 votingPower);

  /**
   * @notice Detect signature count from packed signatures length
   * @dev DESIGN CHOICE: Signature count embedded in byte length, not explicit field
   *      This eliminates potential attack vectors where count != actual signatures
   * 
   * @param packedSignatures Packed rsrsrs...vvv format
   * @return signatureCount Number of signatures in the packed data
   * 
   * EXAMPLES:
   * - 1 sig: 64 bytes (RS) + 1 byte (V) = 65 bytes total
   * - 2 sigs: 128 bytes (RS) + 1 byte (VV in bits) = 129 bytes total  
   * - 8 sigs: 512 bytes (RS) + 1 byte (8 V bits) = 513 bytes total
   * - 9 sigs: 576 bytes (RS) + 2 bytes (9 V bits) = 578 bytes total
   */
  function _detectSignatureCount(bytes memory packedSignatures) internal pure returns (uint256 signatureCount) {
    if (packedSignatures.length == 0) return 0;
    
    // Try different signature counts until we find the right one
    // Formula: length = count * 64 + ceil(count / 8)
    for (uint256 count = 1; count <= 16000; count++) {
      uint256 expectedRSBytes = count * 64;
      uint256 expectedVBytes = (count + 7) / 8; // Ceiling division
      uint256 expectedTotal = expectedRSBytes + expectedVBytes;
      
      if (packedSignatures.length == expectedTotal) {
        return count;
      }
      
      // Early exit if we've exceeded possible length
      if (expectedTotal > packedSignatures.length) {
        break;
      }
    }
    
    revert("Invalid packed signature length - cannot detect count");
  }

  /**
   * @notice Unpack signatures from packed format
   * @param packedSignatures Packed rsrsrs...vvv format
   * @return signatures Array of 65-byte signatures
   */
  function _unpackSignatures(
    bytes memory packedSignatures
  ) internal pure returns (bytes[] memory signatures) {
    uint256 signatureCount = _detectSignatureCount(packedSignatures);
    
    if (signatureCount == 0) {
      return new bytes[](0);
    }
    
    uint256 expectedRSBytes = signatureCount * 64;
    // uint256 expectedVBytes = (signatureCount + 7) / 8; // Ceiling division - unused
    
    signatures = new bytes[](signatureCount);
    
    for (uint256 i = 0; i < signatureCount; i++) {
      // Extract R and S (64 bytes)
      bytes memory rs = new bytes(64);
      for (uint256 j = 0; j < 64; j++) {
        rs[j] = packedSignatures[i * 64 + j];
      }
      
      // Extract V bit
      uint256 vByteIndex = expectedRSBytes + i / 8;
      uint256 vBitIndex = i % 8;
      uint8 vByte = uint8(packedSignatures[vByteIndex]);
      uint8 v = ((vByte >> vBitIndex) & 1) == 0 ? 27 : 28;
      
      // Combine into 65-byte signature
      signatures[i] = new bytes(65);
      for (uint256 j = 0; j < 64; j++) {
        signatures[i][j] = rs[j];
      }
      signatures[i][64] = bytes1(v);
    }
  }

  /**
   * @notice Build and hash a board from actual signers and claim data
   * @param actualSigners Array of recovered signer addresses
   * @param claim The hanko claim with weights and threshold
   * @return boardHash The keccak256 hash of the reconstructed board
   */
  function _buildBoardHash(
    address[] memory actualSigners,
    HankoClaim memory claim
  ) internal pure returns (bytes32 boardHash) {
    require(actualSigners.length == claim.weights.length, "Signers/weights length mismatch");
    
    // Build parallel arrays for Board struct
    bytes32[] memory entityIds = new bytes32[](actualSigners.length);
    uint16[] memory votingPowers = new uint16[](actualSigners.length);
    
    // Populate arrays with actual signers and their weights
    for (uint256 i = 0; i < actualSigners.length; i++) {
      entityIds[i] = bytes32(uint256(uint160(actualSigners[i]))); // Convert address to bytes32
      votingPowers[i] = uint16(claim.weights[i]);
    }
    
    // Build Board struct with parallel arrays (transition delays set to 0 for compatibility)
    Board memory reconstructedBoard = Board({
      votingThreshold: uint16(claim.threshold),
      entityIds: entityIds,
      votingPowers: votingPowers,
      boardChangeDelay: 0,      // Default delays for hanko verification
      controlChangeDelay: 0,
      dividendChangeDelay: 0
    });
    
    // Hash the reconstructed board (same as entity registration)
    boardHash = keccak256(abi.encode(reconstructedBoard));
  }

  /**
   * @notice Verify hanko signature with flashloan governance (optimistic verification)
   * @param hankoData ABI-encoded hanko bytes  
   * @param hash The hash that was signed
   * @return entityId The verified entity (0 if invalid)
   * @return success Whether verification succeeded
   */
  function verifyHankoSignature(
    bytes calldata hankoData,
    bytes32 hash
  ) external view returns (bytes32 entityId, bool success) {
    HankoBytes memory hanko = abi.decode(hankoData, (HankoBytes));
    
    // Unpack signatures (with automatic count detection)
    bytes[] memory signatures = _unpackSignatures(hanko.packedSignatures);
    uint256 signatureCount = signatures.length;
    
    // Calculate total entities for bounds checking
    uint256 totalEntities = hanko.placeholders.length + signatureCount + hanko.claims.length;
    
    // Recover EOA signers for quorum hash building
    address[] memory actualSigners = new address[](signatureCount);
    uint256 validSignerCount = 0;
    
    for (uint256 i = 0; i < signatures.length; i++) {
      if (signatures[i].length == 65) {
        address signer = _recoverSigner(hash, signatures[i]);
        if (signer != address(0)) {
          actualSigners[validSignerCount] = signer;
          validSignerCount++;
        }
      }
    }
    
    // Resize to valid signers only
    address[] memory validSigners = new address[](validSignerCount);
    for (uint256 i = 0; i < validSignerCount; i++) {
      validSigners[i] = actualSigners[i];
    }
    
    // 🔥 FLASHLOAN GOVERNANCE: The Heart of "Assume YES" Philosophy 🔥
    //
    // KEY INSIGHT: When processing claim X that references claim Y:
    // - We DON'T wait for Y to be verified first
    // - We OPTIMISTICALLY assume Y will say "YES" 
    // - If ANY claim fails its threshold → entire Hanko fails IMMEDIATELY
    //
    // CONCRETE EXAMPLE - Circular Reference:
    // Claim 0: EntityA needs EntityB (index 3) at weight 100, threshold 100
    // Claim 1: EntityB needs EntityA (index 2) at weight 100, threshold 100
    // 
    // Processing:
    // 1. Claim 0 processing: Assume EntityB=YES → 100 power ≥ 100 → CONTINUE
    // 2. Claim 1 processing: Assume EntityA=YES → 100 power ≥ 100 → CONTINUE
    // 3. All claims passed → Hanko succeeds!
    //
    // ⚡ OPTIMIZATION: Fail immediately on threshold failure - no need to store results!
    //
    // This is INTENDED BEHAVIOR enabling flexible governance!
    
    for (uint256 claimIndex = 0; claimIndex < hanko.claims.length; claimIndex++) {
      HankoClaim memory claim = hanko.claims[claimIndex];
      
      // Build board hash from actual signers
      bytes32 reconstructedBoardHash = _buildBoardHash(validSigners, claim);
      
      // Validate entity exists (registered or lazy) and verify board hash
      _validateEntity(claim.entityId, reconstructedBoardHash);
      
      // Validate structure
      require(
        claim.entityIndexes.length == claim.weights.length,
        "Claim indexes/weights length mismatch"
      );
      
      uint256 totalVotingPower = 0;
      
      // Calculate voting power with flashloan assumptions
      for (uint256 i = 0; i < claim.entityIndexes.length; i++) {
        uint256 entityIndex = claim.entityIndexes[i];
        
        // Bounds check
        require(entityIndex < totalEntities, "Entity index out of bounds");
        
        if (entityIndex < hanko.placeholders.length) {
          // Index 0..N-1: Placeholder (failed entity) - contributes 0 voting power
          continue;
        } else if (entityIndex < hanko.placeholders.length + signatureCount) {
          // Index N..M-1: EOA signature - verified, contributes full weight
          totalVotingPower += claim.weights[i];
        } else {
          // Index M..∞: Entity claim - ASSUME YES! (flashloan governance)
          uint256 referencedClaimIndex = entityIndex - hanko.placeholders.length - signatureCount;
          require(referencedClaimIndex < hanko.claims.length, "Referenced claim index out of bounds");
          
          // 🚨 CRITICAL: We ASSUME the referenced claim will pass (flashloan assumption)
          // This enables circular references to mutually validate.
          // If our assumption is wrong, THIS claim will fail its threshold check below.
          totalVotingPower += claim.weights[i];
        }
      }
      
      // 💥 IMMEDIATE FAILURE: Check threshold and fail right away if not met
      if (totalVotingPower < claim.threshold) {
        return (bytes32(0), false); // Immediate failure - no need to check other claims
      }
    }
    
    // All claims passed - return final entity
    if (hanko.claims.length > 0) {
      bytes32 targetEntity = hanko.claims[hanko.claims.length - 1].entityId;
      return (targetEntity, true);
    }
    
    return (bytes32(0), false);
  }

  /**
   * @notice Batch verify multiple hanko signatures
   * @param hankoDataArray Array of ABI-encoded hanko bytes
   * @param hashes Array of hashes that were signed
   * @return entityIds Array of verified entity IDs
   * @return results Array of success flags
   */
  function batchVerifyHankoSignatures(
    bytes[] calldata hankoDataArray,
    bytes32[] calldata hashes
  ) external view returns (bytes32[] memory entityIds, bool[] memory results) {
    require(hankoDataArray.length == hashes.length, "Array length mismatch");
    
    entityIds = new bytes32[](hankoDataArray.length);
    results = new bool[](hankoDataArray.length);
    
    for (uint256 i = 0; i < hankoDataArray.length; i++) {
      (entityIds[i], results[i]) = this.verifyHankoSignature(hankoDataArray[i], hashes[i]);
    }
  }



  function setNameQuota(address user, uint8 quota) external onlyFoundation {
    nameQuota[user] = quota;
  }

  // === GOVERNANCE FUNCTIONS ===

  /**
   * @notice Get token IDs for an entity (first bit determines control vs dividend)
   * @param entityNumber The entity number
   * @return controlTokenId Token ID for control tokens (original ID)
   * @return dividendTokenId Token ID for dividend tokens (first bit set)
   */
  function getTokenIds(uint256 entityNumber) public pure returns (uint256 controlTokenId, uint256 dividendTokenId) {
    controlTokenId = entityNumber;
    dividendTokenId = entityNumber | 0x8000000000000000000000000000000000000000000000000000000000000000;
  }

  /**
   * @notice Extract entity number from token ID
   * @param tokenId The token ID (control or dividend)
   * @return entityNumber The entity number
   */
  function getEntityFromToken(uint256 tokenId) public pure returns (uint256 entityNumber) {
    return tokenId & 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;
  }







  // === INTERNAL HELPER FUNCTIONS ===

  function _getDelayForProposer(EntityArticles memory articles, ProposerType proposerType) internal pure returns (uint32) {
    if (proposerType == ProposerType.CONTROL) return articles.controlDelay;
    if (proposerType == ProposerType.DIVIDEND) return articles.dividendDelay;
    return 0; // BOARD has no delay
  }

  function _canCancelProposal(ProposerType canceller, ProposerType existing) internal pure returns (bool) {
    // Priority: CONTROL > BOARD > DIVIDEND (BCD model)
    if (canceller == ProposerType.CONTROL) return existing != ProposerType.CONTROL;
    if (canceller == ProposerType.BOARD) return existing == ProposerType.DIVIDEND;
    return false; // DIVIDEND cannot cancel anyone
  }

  function _validateControlProposer(bytes32 entityId, address proposer, EntityArticles memory /*articles*/) internal view {
    (uint256 controlTokenId,) = getTokenIds(uint256(entityId));
    uint256 proposerBalance = balanceOf(proposer, controlTokenId);
    require(proposerBalance > 0, "No control tokens");
    
    // Optional: require minimum percentage
    // uint256 required = (totalControlSupply[entityId] * articles.controlThreshold) / 10000;
    // require(proposerBalance >= required, "Insufficient control tokens");
  }

  function _validateDividendProposer(bytes32 entityId, address proposer) internal view {
    (, uint256 dividendTokenId) = getTokenIds(uint256(entityId));
    uint256 proposerBalance = balanceOf(proposer, dividendTokenId);
    require(proposerBalance > 0, "No dividend tokens");
  }

  function _validateControlSupport(bytes32 entityId, address[] memory supporters, EntityArticles memory articles) internal view {
    (uint256 controlTokenId,) = getTokenIds(uint256(entityId));
    
    uint256 totalSupport = 0;
    for (uint i = 0; i < supporters.length; i++) {
      totalSupport += balanceOf(supporters[i], controlTokenId);
    }
    
    uint256 required = (totalControlSupply[entityId] * articles.controlThreshold) / 100;
    require(totalSupport >= required, "Insufficient control support");
  }

  function _validateDividendSupport(bytes32 entityId, address[] memory supporters) internal view {
    (, uint256 dividendTokenId) = getTokenIds(uint256(entityId));
    
    uint256 totalSupport = 0;
    for (uint i = 0; i < supporters.length; i++) {
      totalSupport += balanceOf(supporters[i], dividendTokenId);
    }
    
    // Require majority of dividend tokens
    uint256 required = (totalDividendSupply[entityId] * 51) / 100;
    require(totalSupport >= required, "Insufficient dividend support");
  }

  // === VIEW FUNCTIONS ===

  /**
   * @notice Get governance info for an entity
   */
  function getGovernanceInfo(uint256 entityNumber) external view returns (
    uint256 controlTokenId,
    uint256 dividendTokenId,
    uint256 controlSupply,
    uint256 dividendSupply,
    bool hasActiveProposal,
    bytes32 articlesHash
  ) {
    bytes32 entityId = bytes32(entityNumber);
    (controlTokenId, dividendTokenId) = getTokenIds(entityNumber);
    controlSupply = totalControlSupply[entityId];
    dividendSupply = totalDividendSupply[entityId];
    hasActiveProposal = activeProposals[entityId].active;
    articlesHash = entities[entityId].articlesHash;
  }

  /**
   * @notice Override to track token supply changes
   */
  function _afterTokenTransfer(
    address /*operator*/,
    address from,
    address to,
    uint256[] memory ids,
    uint256[] memory amounts,
    bytes memory /*data*/
  ) internal {
    for (uint i = 0; i < ids.length; i++) {
      uint256 entityNumber = getEntityFromToken(ids[i]);
      bytes32 entityId = bytes32(entityNumber);
      
      if (entities[entityId].currentBoardHash != bytes32(0)) {
        (uint256 controlTokenId,) = getTokenIds(entityNumber);
        
        // Update total supply for control tokens
        if (ids[i] == controlTokenId) {
          if (from == address(0)) {
            // Mint
            totalControlSupply[entityId] += amounts[i];
          } else if (to == address(0)) {
            // Burn
            totalControlSupply[entityId] -= amounts[i];
          }
        } else {
          // Dividend token
          if (from == address(0)) {
            // Mint
            totalDividendSupply[entityId] += amounts[i];
          } else if (to == address(0)) {
            // Burn
            totalDividendSupply[entityId] -= amounts[i];
          }
        }
      }
    }
  }

  /**
   * @notice Foundation can create entity with custom governance articles
   * @param boardHash Initial board/quorum hash
   * @param articles Custom governance configuration
   * @return entityNumber The assigned entity number
   */
  function foundationRegisterEntity(
    bytes32 boardHash,
    EntityArticles memory articles
  ) external onlyFoundation returns (uint256 entityNumber) {
    entityNumber = nextNumber++;
    bytes32 entityId = bytes32(entityNumber);
    
    entities[entityId] = Entity({
      currentBoardHash: boardHash,
      proposedBoardHash: bytes32(0),
      activateAtBlock: 0,
      registrationBlock: block.number,
      proposerType: ProposerType.BOARD,
      articlesHash: keccak256(abi.encode(articles))
    });
    
    // Automatically setup governance with fixed supply
    (uint256 controlTokenId, uint256 dividendTokenId) = getTokenIds(entityNumber);
    address entityAddress = address(uint160(uint256(entityId)));
    
    _mint(entityAddress, controlTokenId, TOTAL_CONTROL_SUPPLY, "");
    _mint(entityAddress, dividendTokenId, TOTAL_DIVIDEND_SUPPLY, "");
    
    totalControlSupply[entityId] = TOTAL_CONTROL_SUPPLY;
    totalDividendSupply[entityId] = TOTAL_DIVIDEND_SUPPLY;
    
    emit EntityRegistered(entityId, entityNumber, boardHash);
    emit GovernanceEnabled(entityId, controlTokenId, dividendTokenId);
    
    return entityNumber;
  }

  // === ENTITY SIGNATURE RECOVERY ===

  /**
   * @notice Transfer tokens from entity using hanko signature authorization
   * @param entityNumber The entity number
   * @param to Recipient address  
   * @param tokenId Token ID (control or dividend)
   * @param amount Amount to transfer
   * @param encodedBoard Entity's board data
   * @param encodedSignature Entity's signatures authorizing this transfer
   */
  function entityTransferTokens(
    uint256 entityNumber,
    address to,
    uint256 tokenId,
    uint256 amount,
    bytes calldata encodedBoard,
    bytes calldata encodedSignature
  ) external {
    // Create transfer hash
    bytes32 transferHash = keccak256(abi.encodePacked(
      "ENTITY_TRANSFER",
      entityNumber,
      to,
      tokenId,
      amount,
      block.timestamp
    ));
    
    // Verify entity signature
    uint256 recoveredEntityId = recoverEntity(encodedBoard, encodedSignature, transferHash);
    require(recoveredEntityId == entityNumber, "Invalid entity signature");
    
    // Execute transfer
    address entityAddress = address(uint160(uint256(bytes32(entityNumber))));
    _safeTransferFrom(entityAddress, to, tokenId, amount, "");
  }

  // === CONTROL SHARES RELEASE TO DEPOSITORY ===

  event ControlSharesReleased(
    bytes32 indexed entityId, 
    address indexed depository, 
    uint256 controlAmount, 
    uint256 dividendAmount,
    string purpose
  );

  /**
   * @notice Release entity's control and/or dividend shares to depository for trading
   * @dev This mirrors real corporate stock issuance - entity manages its own share releases
   * @param entityNumber The entity number
   * @param depository Depository contract address to receive the shares
   * @param controlAmount Amount of control tokens to release (0 to skip)
   * @param dividendAmount Amount of dividend tokens to release (0 to skip) 
   * @param purpose Human-readable purpose (e.g., "Series A", "Employee Pool", "Public Sale")
   * @param encodedBoard Entity's board data
   * @param encodedSignature Entity's Hanko signatures authorizing this release
   */
  function releaseControlShares(
    uint256 entityNumber,
    address depository,
    uint256 controlAmount,
    uint256 dividendAmount,
    string calldata purpose,
    bytes calldata encodedBoard,
    bytes calldata encodedSignature
  ) external {
    require(depository != address(0), "Invalid depository address");
    require(controlAmount > 0 || dividendAmount > 0, "Must release some tokens");
    
    bytes32 entityId = bytes32(entityNumber);
    require(entities[entityId].currentBoardHash != bytes32(0), "Entity doesn't exist");
    
    // Create release authorization hash
    bytes32 releaseHash = keccak256(abi.encodePacked(
      "RELEASE_CONTROL_SHARES",
      entityNumber,
      depository,
      controlAmount,
      dividendAmount,
      keccak256(bytes(purpose)),
      block.timestamp
    ));
    
    // Verify entity signature authorization
    uint256 recoveredEntityId = recoverEntity(encodedBoard, encodedSignature, releaseHash);
    require(recoveredEntityId == entityNumber, "Invalid entity signature");
    
    address entityAddress = address(uint160(uint256(entityId)));
    (uint256 controlTokenId, uint256 dividendTokenId) = getTokenIds(entityNumber);
    
    // Transfer control tokens if requested
    if (controlAmount > 0) {
      require(balanceOf(entityAddress, controlTokenId) >= controlAmount, "Insufficient control tokens");
      _safeTransferFrom(entityAddress, depository, controlTokenId, controlAmount, 
        abi.encode("CONTROL_SHARE_RELEASE", purpose));
    }
    
    // Transfer dividend tokens if requested  
    if (dividendAmount > 0) {
      require(balanceOf(entityAddress, dividendTokenId) >= dividendAmount, "Insufficient dividend tokens");
      _safeTransferFrom(entityAddress, depository, dividendTokenId, dividendAmount,
        abi.encode("DIVIDEND_SHARE_RELEASE", purpose));
    }
    
    emit ControlSharesReleased(entityId, depository, controlAmount, dividendAmount, purpose);
  }

}
--- contracts/ERC1155Mock.sol ---
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;

import "@openzeppelin/contracts/token/ERC1155/ERC1155.sol";

contract ERC1155Mock is ERC1155 {
    constructor() ERC1155("") {}

    function mint(address to, uint256 id, uint256 amount, bytes memory data) public {
        _mint(to, id, amount, data);
    }
}
--- contracts/ECDSA.sol ---
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;

/**
 * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.
 *
 * These functions can be used to verify that a message was signed by the holder
 * of the private keys of a given address.
 */
library ECDSA {
    /**
     * @dev Returns the address that signed a hashed message (`hash`) with
     * `signature`. This address can then be used for verification purposes.
     *
     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:
     * this function rejects them by requiring the `s` value to be in the lower
     * half order, and the `v` value to be either 27 or 28.
     *
     * IMPORTANT: `hash` _must_ be the result of a hash operation for the
     * verification to be secure: it is possible to craft signatures that
     * recover to arbitrary addresses for non-hashed data. A safe way to ensure
     * this is by receiving a hash of the original message (which may otherwise
     * be too long), and then calling {toEthSignedMessageHash} on it.
     */
    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {
        // Check the signature length
        if (signature.length != 65) {
            revert("ECDSA: invalid signature length");
        }

        // Divide the signature in r, s and v variables
        bytes32 r;
        bytes32 s;
        uint8 v;

        // ecrecover takes the signature parameters, and the only way to get them
        // currently is to use assembly.
        // solhint-disable-next-line no-inline-assembly
        assembly {
            r := mload(add(signature, 0x20))
            s := mload(add(signature, 0x40))
            v := byte(0, mload(add(signature, 0x60)))
        }

        return recover(hash, v, r, s);
    }

    /**
     * @dev Overload of {ECDSA-recover} that receives the `v`,
     * `r` and `s` signature fields separately.
     */
    function recover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address) {
        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature
        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines
        // the valid range for s in (281): 0 < s < secp256k1n ÷ 2 + 1, and for v in (282): v ∈ {27, 28}. Most
        // signatures from current libraries generate a unique signature with an s-value in the lower half order.
        //
        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value
        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or
        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept
        // these malleable signatures as well.
        require(uint256(s) <= 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0, "ECDSA: invalid signature 's' value");
        require(v == 27 || v == 28, "ECDSA: invalid signature 'v' value");

        // If the signature is valid (and not malleable), return the signer address
        address signer = ecrecover(hash, v, r, s);
        require(signer != address(0), "ECDSA: invalid signature");

        return signer;
    }

    /**
     * @dev Returns an Ethereum Signed Message, created from a `hash`. This
     * produces hash corresponding to the one signed with the
     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]
     * JSON-RPC method as part of EIP-191.
     *
     * See {recover}.
     */
    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {
        // 32 is the length in bytes of hash,
        // enforced by the type signature above
        return keccak256(abi.encodePacked("\x19Ethereum Signed Message:\n32", hash));
    }

    /**
     * @dev Returns an Ethereum Signed Typed Data, created from a
     * `domainSeparator` and a `structHash`. This produces hash corresponding
     * to the one signed with the
     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`]
     * JSON-RPC method as part of EIP-712.
     *
     * See {recover}.
     */
    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32) {
        return keccak256(abi.encodePacked("\x19\x01", domainSeparator, structHash));
    }
}

--- contracts/ERC20Mock.sol ---
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;

import "@openzeppelin/contracts/token/ERC20/ERC20.sol";

contract ERC20Mock is ERC20 {
    constructor(string memory name, string memory symbol, uint256 initialSupply) ERC20(name, symbol) {
        _mint(msg.sender, initialSupply);
    }
}
--- contracts/Depository.sol ---
// SPDX-License-Identifier: unknown
pragma solidity ^0.8.24;


import "./ECDSA.sol";
import "./console.sol";
import "hardhat/console.sol";

import "./EntityProvider.sol";

import "./SubcontractProvider.sol";

// Add necessary interfaces
interface IERC20 {
  function transfer(address to, uint256 value) external returns (bool);
  function transferFrom(address from, address to, uint256 value) external returns (bool);
}
interface IERC721 {
  function transferFrom(address from, address to, uint256 tokenId) external;
}
//interface IERC1155 {
//  function safeTransferFrom(address from, address to, uint256 id, uint256 amount, bytes calldata data) external;
//}
// IERC1155 already imported from EntityProvider.sol
contract Depository is Console {

  // Multi-provider support  
  mapping(address => bool) public approvedEntityProviders;
  address[] public entityProvidersList;
  
  mapping (bytes32 => mapping (uint => uint)) public _reserves;

  mapping (bytes => ChannelInfo) public _channels;
  mapping (bytes => mapping(uint => ChannelCollateral)) public _collaterals; 
  

  mapping (bytes32 => mapping (uint => Debt[])) public _debts;
  // the current debt index to pay
  mapping (bytes32 => mapping (uint => uint)) public _debtIndex;
  // total number of debts of an entity  
  mapping (bytes32 => uint) public _activeDebts;


  // === REPUTATION SCORES ===

  struct EntityScore {
    // Total gas used by the entity in `processBatch` calls. Tracks overall activity.
    uint64 totalGasUsed;
    // Timestamp when the entity first acquired an active debt. Resets to 0 when all debts are cleared.
    uint48 inDebtSince;
    // The total number of outstanding debts across all tokens.
    uint32 totalActiveDebts;
    // Counter for how many times the entity has been involved in a dispute.
    uint32 totalDisputes;
    // A counter for successfully paid-off debts. A measure of reliability.
    uint32 successfulRepayments;
    // A counter for successful cooperative settlements. A measure of good-faith participation.
    uint32 cooperativeActions;
  }

  mapping(bytes32 => EntityScore) public entityScores;


  struct Settled {
      bytes32 left;
      bytes32 right;
      uint tokenId;
      uint leftReserve;
      uint rightReserve;
      uint collateral;
      int ondelta;
  }
  event ChannelSettled(Settled[]);

  struct Hub {
    bytes32 entityId;
    uint gasused;
    string uri;
  }
  Hub[] public _hubs;
  
  event TransferReserveToCollateral(bytes32 indexed receivingEntity, bytes32 indexed counterentity, uint collateral, int ondelta, uint tokenId);
  event DisputeStarted(bytes32 indexed sender, bytes32 indexed counterentity, uint indexed disputeNonce, bytes initialArguments);
  event CooperativeClose(bytes32 indexed sender, bytes32 indexed counterentity, uint indexed cooperativeNonce);
  
  event ReserveTransferred(bytes32 indexed from, bytes32 indexed to, uint indexed tokenId, uint amount);

  /**
   * @notice Emitted whenever an entity's reserve balance for a specific token changes.
   * @dev This is the primary event for j-watchers to sync entity state.
   * @param entity The entity whose reserve was updated.
   * @param tokenId The internal ID of the token.
   * @param newBalance The absolute new balance of the token for the entity.
   */
  event ReserveUpdated(bytes32 indexed entity, uint indexed tokenId, uint newBalance);

  /**
   * @notice Emitted when entities settle off-chain account differences
   * @dev This event contains final absolute values after settlement processing
   * @param leftEntity The first entity in the settlement
   * @param rightEntity The second entity in the settlement
   * @param tokenId The token being settled
   * @param leftReserve Final absolute reserve balance for left entity
   * @param rightReserve Final absolute reserve balance for right entity
   * @param collateral Final absolute collateral amount
   * @param ondelta Final ondelta value
   */
  event SettlementProcessed(
    bytes32 indexed leftEntity,
    bytes32 indexed rightEntity,
    uint indexed tokenId,
    uint leftReserve,
    uint rightReserve,
    uint collateral,
    int ondelta
  );

  //event ChannelUpdated(address indexed receiver, address indexed addr, uint tokenId);


  // Token type identifiers
  uint8 constant TypeERC20 = 0;
  uint8 constant TypeERC721 = 1;
  uint8 constant TypeERC1155 = 2;   




  bytes32[] public _tokens;
  
  // Efficient token lookup: packedToken -> internalTokenId
  mapping(bytes32 => uint256) public tokenToId;

  // === MULTI-PROVIDER MANAGEMENT ===
  
  event EntityProviderAdded(address indexed provider);
  event EntityProviderRemoved(address indexed provider);
  
  modifier onlyApprovedProvider(address provider) {
    require(approvedEntityProviders[provider], "Provider not approved");
    _;
  }
  
  /**
   * @notice Add an EntityProvider to approved list
   * @param provider EntityProvider contract address
   */
  function addEntityProvider(address provider) external {
    require(!approvedEntityProviders[provider], "Already approved");
    approvedEntityProviders[provider] = true;
    entityProvidersList.push(provider);
    emit EntityProviderAdded(provider);
  }
  
  /**
   * @notice Remove an EntityProvider from approved list  
   * @param provider EntityProvider contract address
   */
  function removeEntityProvider(address provider) external {
    require(approvedEntityProviders[provider], "Not approved");
    approvedEntityProviders[provider] = false;
    
    // Remove from list
    for (uint i = 0; i < entityProvidersList.length; i++) {
      if (entityProvidersList[i] == provider) {
        entityProvidersList[i] = entityProvidersList[entityProvidersList.length - 1];
        entityProvidersList.pop();
        break;
      }
    }
    emit EntityProviderRemoved(provider);
  }
  
  /**
   * @notice Get all approved EntityProviders
   */
  function getApprovedProviders() external view returns (address[] memory) {
    return entityProvidersList;
  }

  constructor() {
    _tokens.push(bytes32(0));
    
    // empty record, hub_id==0 means not a hub
    _hubs.push(Hub({
      entityId: bytes32(0),
      uri: '',
      gasused: 0
    }));
    
    // DEBUG: Prefund top 1000 entities for testing
    debugBulkFundEntities();
  }
  
  function getTokensLength() public view returns (uint) {
    return _tokens.length;
  }





  struct Batch {
    // tokens move Token <=> Reserve <=> Collateral
    // but never Token <=> Collateral. 'reserve' acts as an intermediary balance
    ReserveToExternalToken[] reserveToExternalToken;
    ExternalTokenToReserve[] externalTokenToReserve;

    // don't require a signature
    ReserveToReserve[] reserveToReserve;
    ReserveToCollateral[] reserveToCollateral;

    // NEW: Simple settlements between entities (no signature verification for now)
    Settlement[] settlements;
    
    // DEPRECATED: Keep for backwards compatibility but will be replaced
    CooperativeUpdate[] cooperativeUpdate;
    CooperativeDisputeProof[] cooperativeDisputeProof;

    // initialDisputeProof is signed by the peer, but could be outdated
    // another peer has time to respond with a newer proof
    InitialDisputeProof[] initialDisputeProof;
    FinalDisputeProof[] finalDisputeProof;


    TokenAmountPair[] flashloans;

    //bytes32[] revealSecret;
    //bytes32[] cleanSecret;
    uint hub_id;
  }


  /* === HANKO INTEGRATION ===
  
  /* Nonce tracking for replay protection (since Hanko signatures are stateless)
  /* EVM-style sequential nonces: each entity must use nonce = lastNonce + 1
  mapping(address => uint256) public entityNonces;
  
  /* Domain separation for EIP-712 compatibility
  bytes32 public constant DOMAIN_SEPARATOR = keccak256("XLN_DEPOSITORY_HANKO_V1");
  
  event HankoBatchProcessed(bytes32 indexed entityId, bytes32 indexed hankoHash, uint256 nonce, bool success);
  
  /**
   * @notice Process batch with Hanko signature authorization using on-chain cryptographic verification
   * @dev SECURITY: All signatures are verified on-chain using ecrecover - no off-chain trust
   * @param encodedBatch The batch data
   * @param entityProvider EntityProvider contract address  
   * @param hankoData ABI-encoded Hanko bytes (placeholders, packedSignatures, claims)
   * @param nonce EVM-style sequential nonce for replay protection
   */
  /* DISABLED: Hanko processing
  function processBatchWithHanko(
    bytes calldata encodedBatch,
    address entityProvider,
    bytes calldata hankoData,
    uint256 nonce
  ) external onlyApprovedProvider(entityProvider) returns (bool completeSuccess) {
    
    // 🛡️ Domain separation: Hash batch with contract-specific context
    bytes32 domainSeparatedHash = keccak256(abi.encodePacked(
      DOMAIN_SEPARATOR,
      block.chainid,
      address(this),
      encodedBatch,
      nonce
    ));
    
    // 🔥 Verify Hanko with flashloan governance
    (bytes32 entityId, bool hankoValid) = EntityProvider(entityProvider).verifyHankoSignature(
      hankoData,
      domainSeparatedHash
    );
    
    require(hankoValid, "Invalid Hanko signature");
    require(entityId != bytes32(0), "No entity recovered from Hanko");
    
    // 🚀 Nonce management: Prevent replay attacks
    bytes32 entityIdBytes32 = entityId; // Already bytes32
    bytes32 hankoHash = keccak256(hankoData);
    
    require(nonce == entityNonces[address(uint160(uint256(entityIdBytes32)))] + 1, "Invalid nonce (must be sequential)");
    entityNonces[address(uint160(uint256(entityIdBytes32)))] = nonce;
    
    // ⚡ Process the actual batch
    completeSuccess = _processBatch(entityIdBytes32, abi.decode(encodedBatch, (Batch)));
    
    emit HankoBatchProcessed(entityId, hankoHash, nonce, completeSuccess);
    
    return completeSuccess;
  }
  */
  




  // DEBUG: Simple function to fund entity reserves for testing
  function debugFundReserves(bytes32 entity, uint tokenId, uint amount) public {
    console.log("debugFundReserves: funding entity");
    console.logBytes32(entity);
    console.log("debugFundReserves: tokenId");
    console.logUint(tokenId);
    console.log("debugFundReserves: amount");
    console.logUint(amount);
    
    _reserves[entity][tokenId] += amount;
    emit ReserveUpdated(entity, tokenId, _reserves[entity][tokenId]);
    
    console.log("debugFundReserves: new balance");
    console.logUint(_reserves[entity][tokenId]);
  }

  // DEBUG: Bulk fund top 1000 entities with test reserves
  function debugBulkFundEntities() public {
    console.log("debugBulkFundEntities: funding entities 1-1000 with 100 ETH each");

    uint256 fundAmount = 100000000000000000000; // 100 ETH (100e18)

    for (uint256 entityNum = 1; entityNum <= 200; entityNum++) {
      bytes32 entity = bytes32(entityNum); // Entity ID is just the number padded

      // Fund with tokens 1, 2, 3
      for (uint256 tokenId = 1; tokenId <= 3; tokenId++) {
        _reserves[entity][tokenId] += fundAmount;
        emit ReserveUpdated(entity, tokenId, _reserves[entity][tokenId]);
      }
    }

    console.log("debugBulkFundEntities: funding complete");
  }

  function processBatch(bytes32 entity, Batch calldata batch) public returns (bool completeSuccess) {
    console.log("=== processBatch ENTRY ===");
    console.log("=== processBatch ENTRY ===");
    console.log("=== processBatch ENTRY ===");
    console.log("processBatch called with entity");
    console.logBytes32(entity);
    console.log("batch.reserveToReserve.length");
    console.logUint(batch.reserveToReserve.length);
    console.log("msg.sender:");
    console.logAddress(msg.sender);
    
    if (batch.reserveToReserve.length > 0) {
      console.log("First transfer details:");
      console.log("  to entity:");
      console.logBytes32(batch.reserveToReserve[0].receivingEntity);
      console.log("  tokenId:");
      console.logUint(batch.reserveToReserve[0].tokenId);
      console.log("  amount:");
      console.logUint(batch.reserveToReserve[0].amount);
      
      console.log("Sender current balance:");
      console.logUint(_reserves[entity][batch.reserveToReserve[0].tokenId]);
    }
    
    console.log("=== CALLING _processBatch ===");
    return _processBatch(entity, batch);
  }


  // ========== ACCOUNT PREFUNDING FUNCTION ==========
  // Allows an entity to fund an account's collateral from their reserves
  function prefundAccount(bytes32 counterpartyEntity, uint tokenId, uint amount) public returns (bool) {
    bytes32 fundingEntity = bytes32(uint256(uint160(msg.sender)));
    require(fundingEntity != counterpartyEntity, "Cannot prefund account with self");
    
    // Ensure entities are in canonical order (left < right)
    bytes32 leftEntity = fundingEntity < counterpartyEntity ? fundingEntity : counterpartyEntity;
    bytes32 rightEntity = fundingEntity < counterpartyEntity ? counterpartyEntity : fundingEntity;
    
    // Simple channel key: hash of left and right entities converted to bytes
    bytes memory ch_key = abi.encodePacked(keccak256(abi.encodePacked(leftEntity, rightEntity)));
    
    // Check funding entity has sufficient reserves
    require(_reserves[fundingEntity][tokenId] >= amount, "Insufficient reserves for prefunding");
    
    // Move funds from reserves to account collateral
    _reserves[fundingEntity][tokenId] -= amount;
    
    ChannelCollateral storage col = _collaterals[ch_key][tokenId];
    col.collateral += amount;
    
    // Emit SettlementProcessed event to notify both entities
    emit SettlementProcessed(
      leftEntity,
      rightEntity,
      tokenId,
      _reserves[leftEntity][tokenId],
      _reserves[rightEntity][tokenId],
      col.collateral,
      col.ondelta
    );
    
    console.log("Account prefunded:");
    console.logBytes32(fundingEntity);
    console.log("funded account with:");
    console.logBytes32(counterpartyEntity);
    console.log("amount:");
    console.logUint(amount);
    
    return true;
  }

  // ========== DIRECT R2R FUNCTION ==========
  // Simple reserve-to-reserve transfer (simpler than batch)
  function reserveToReserve(bytes32 fromEntity, bytes32 toEntity, uint tokenId, uint amount) public returns (bool) {
    require(fromEntity != toEntity, "Cannot transfer to self");
    require(_reserves[fromEntity][tokenId] >= amount, "Insufficient reserves");

    console.log("=== DIRECT R2R TRANSFER ===");
    console.logBytes32(fromEntity);
    console.log("to");
    console.logBytes32(toEntity);
    console.log("amount:");
    console.logUint(amount);

    // Simple transfer: subtract from sender, add to receiver
    _reserves[fromEntity][tokenId] -= amount;
    _reserves[toEntity][tokenId] += amount;

    // Emit events for j-watcher
    emit ReserveUpdated(fromEntity, tokenId, _reserves[fromEntity][tokenId]);
    emit ReserveUpdated(toEntity, tokenId, _reserves[toEntity][tokenId]);
    emit ReserveTransferred(fromEntity, toEntity, tokenId, amount);

    console.log("=== R2R TRANSFER COMPLETE ===");
    return true;
  }

  // ========== NEW SIMPLIFIED SETTLE FUNCTION ==========
  // Simple settlement between two entities without signature verification
  // Can be called independently or as part of processBatch
  function settle(bytes32 leftEntity, bytes32 rightEntity, SettlementDiff[] memory diffs) public returns (bool) {
    require(leftEntity != rightEntity, "Cannot settle with self");
    require(leftEntity < rightEntity, "Entities must be in order (left < right)");
    
    // Simple channel key: hash of left and right entities converted to bytes
    bytes memory ch_key = abi.encodePacked(keccak256(abi.encodePacked(leftEntity, rightEntity)));
    
    // Comment out signature verification for development
    // TODO: Re-enable signature verification in production
    
    for (uint j = 0; j < diffs.length; j++) {
      SettlementDiff memory diff = diffs[j];
      uint tokenId = diff.tokenId;
      
      // ✅ INVARIANT CHECK: Total value change must be zero
      // leftDiff + rightDiff + collateralDiff == 0
      require(diff.leftDiff + diff.rightDiff + diff.collateralDiff == 0, "Settlement must balance");
      
      // Update left entity reserves
      if (diff.leftDiff < 0) {
        require(_reserves[leftEntity][tokenId] >= uint(-diff.leftDiff), "Left entity insufficient reserves");
        _reserves[leftEntity][tokenId] -= uint(-diff.leftDiff);
      } else if (diff.leftDiff > 0) {
        _reserves[leftEntity][tokenId] += uint(diff.leftDiff);
      }
      
      // Update right entity reserves  
      if (diff.rightDiff < 0) {
        require(_reserves[rightEntity][tokenId] >= uint(-diff.rightDiff), "Right entity insufficient reserves");
        _reserves[rightEntity][tokenId] -= uint(-diff.rightDiff);
      } else if (diff.rightDiff > 0) {
        _reserves[rightEntity][tokenId] += uint(diff.rightDiff);
      }
      
      // Update collateral
      ChannelCollateral storage col = _collaterals[ch_key][tokenId];
      if (diff.collateralDiff < 0) {
        require(col.collateral >= uint(-diff.collateralDiff), "Insufficient collateral");
        col.collateral -= uint(-diff.collateralDiff);
      } else if (diff.collateralDiff > 0) {
        col.collateral += uint(diff.collateralDiff);
      }
      
      // Update ondelta
      col.ondelta += diff.ondeltaDiff;
      
      // Emit SettlementProcessed event with final values for j-watcher consumption
      emit SettlementProcessed(
        leftEntity,
        rightEntity,
        tokenId,
        _reserves[leftEntity][tokenId],
        _reserves[rightEntity][tokenId],
        col.collateral,
        col.ondelta
      );
    }
    
    // TODO: Add cooperative nonce tracking if needed for settlement ordering
    return true;
  }

  function _processBatch(bytes32 entityId, Batch memory batch) private returns (bool completeSuccess) {
    console.log("_processBatch starting for entity");
    console.logBytes32(entityId);
    uint startGas = gasleft();

    // the order is important: first go methods that increase entity's balance
    // then methods that deduct from it

    completeSuccess = true; 

    // Process reserveToReserve transfers (the core functionality we need)
    console.log("Processing reserveToReserve transfers count:");
    console.logUint(batch.reserveToReserve.length);
    for (uint i = 0; i < batch.reserveToReserve.length; i++) {
      console.log("Transfer index:");
      console.logUint(i);
      console.log("From entity:");
      console.logBytes32(entityId);
      console.log("To entity:");
      console.logBytes32(batch.reserveToReserve[i].receivingEntity);
      console.log("Token ID:");
      console.logUint(batch.reserveToReserve[i].tokenId);
      console.log("Amount:");
      console.logUint(batch.reserveToReserve[i].amount);
      reserveToReserve(entityId, batch.reserveToReserve[i]);
    }

    // NEW: Process settlements (simplified account settlements between entities)
    console.log("Processing settlements count:");
    console.logUint(batch.settlements.length);
    for (uint i = 0; i < batch.settlements.length; i++) {
      Settlement memory settlement = batch.settlements[i];
      console.log("Settlement between:");
      console.logBytes32(settlement.leftEntity);
      console.log("and:");
      console.logBytes32(settlement.rightEntity);
      
      if (!settle(settlement.leftEntity, settlement.rightEntity, settlement.diffs)) {
        completeSuccess = false;
      }
    }

    /*
    // flashloans allow to settle batch of cooperativeUpdate
    for (uint i = 0; i < batch.flashloans.length; i++) {
      _reserves[msg.sender][batch.flashloans[i].tokenId] += batch.flashloans[i].amount;
    }

    for (uint i = 0; i < batch.flashloans.length; i++) {
      // fails if not enough _reserves 
      _reserves[entityAddress][batch.flashloans[i].tokenId] -= batch.flashloans[i].amount;
    }
    */
    
    /* DISABLED: dispute functions
    for (uint i = 0; i < batch.cooperativeUpdate.length; i++) {
      if(!(cooperativeUpdate(entityId, batch.cooperativeUpdate[i]))){
        completeSuccess = false;
      }
    }
    for (uint i = 0; i < batch.cooperativeDisputeProof.length; i++) {
      if(!(cooperativeDisputeProof(batch.cooperativeDisputeProof[i]))){
        completeSuccess = false;
      }
    }

    //submitProof (Header / proofbody)

    for (uint i = 0; i < batch.initialDisputeProof.length; i++) {
      if(!(initialDisputeProof(batch.initialDisputeProof[i]))){
        completeSuccess = false;
      }
    }

    for (uint i = 0; i < batch.finalDisputeProof.length; i++) {
      if(!(finalDisputeProof(batch.finalDisputeProof[i]))){
        completeSuccess = false;
      }
    }
    */

    
    /* DISABLED: collateral functions
    for (uint i = 0; i < batch.reserveToCollateral.length; i++) {
      if(!(reserveToCollateral(entityId, batch.reserveToCollateral[i]))){
        completeSuccess = false;
      }
    }
    */
    
    /*
    for (uint i = 0; i < batch.revealSecret.length; i++) {
      revealSecret(batch.revealSecret[i]);
    }

    for (uint i = 0; i < batch.cleanSecret.length; i++) {
      cleanSecret(batch.cleanSecret[i]);
    }*/

    // increase gasused for hubs
    // this is hardest to fake metric of real usage
    if (batch.hub_id != 0 && entityId == _hubs[batch.hub_id].entityId){
      _hubs[batch.hub_id].gasused += startGas - gasleft();
    }

    // Update entity's gas usage score
    entityScores[entityId].totalGasUsed += uint64(startGas - gasleft());

    return completeSuccess;
    
  }

  
  enum MessageType {
    CooperativeUpdate,
    CooperativeDisputeProof,
    DisputeProof
  }

  struct TokenAmountPair {
    uint tokenId;
    uint amount;
  }

  struct AddrAmountPair {
    bytes32 entity;
    uint amount;
  }

  struct ReserveToCollateral {
    uint tokenId;
    bytes32 receivingEntity;
    // put in _channels with who (addr) and how much (amount)
    AddrAmountPair[] pairs;
  }

  struct Diff {
    uint tokenId;
    int peerReserveDiff;
    int collateralDiff;
    int ondeltaDiff;
  }

  // Simplified settlement diff structure
  struct SettlementDiff {
    uint tokenId;
    int leftDiff;        // Change for left entity
    int rightDiff;       // Change for right entity  
    int collateralDiff;  // Change in collateral
    int ondeltaDiff;     // Change in ondelta
  }

  // Settlement batch between two entities
  struct Settlement {
    bytes32 leftEntity;
    bytes32 rightEntity;
    SettlementDiff[] diffs;
    // No signature field - signatures commented out for development
  }
  //Enforces the invariant: Its main job is to run the check you described: require(leftReserveDiff + rightReserveDiff + collateralDiff == 0). This guarantees no value is created or lost, only moved.
  struct CooperativeUpdate {
    bytes32 counterentity;
    Diff[] diffs;
    uint[] forgiveDebtsInTokenIds;
    bytes sig; 
  }





  struct Allowence {
    uint deltaIndex;
    uint rightAllowence;
    uint leftAllowence;
  }
  struct SubcontractClause {
    address subcontractProviderAddress;
    bytes encodedBatch;
    Allowence[] allowences;
  }

  struct ProofBody{
    int[] offdeltas;
    uint[] tokenIds;
    SubcontractClause[] subcontracts;
  }

  struct CooperativeDisputeProof {
    bytes32 counterentity;
    ProofBody proofbody;
    bytes initialArguments;
    bytes finalArguments;
    bytes sig;
  }

  struct InitialDisputeProof {
    bytes32 counterentity;
    uint cooperativeNonce;
    uint disputeNonce;
    bytes32 proofbodyHash; 
    bytes sig;

    bytes initialArguments;
  }

  struct FinalDisputeProof {
    bytes32 counterentity;
    uint initialCooperativeNonce;
    uint initialDisputeNonce;
    uint disputeUntilBlock;
    bytes32 initialProofbodyHash;
    bytes initialArguments;
    bool startedByLeft;

    uint finalCooperativeNonce;
    uint finalDisputeNonce;
    ProofBody finalProofbody;
    bytes finalArguments;

    bytes sig;
  }

  struct Debt {
    uint amount;
    bytes32 creditor;
  }
  
  struct ChannelCollateral {
    // total amount of collateral locked in the channel for this token
    uint collateral;
    // when Left +=/-= .collateral, do the same operation to .ondelta
    int ondelta;   
  }

  struct ChannelInfo{
    // TODO: we could possibly store all channel state as a single hash
    // and provide it with every request as CALLDATA to save gas
    // but unilateral reserveToCollateral would become tricky

    // used for cooperativeUpdate and cooperative close, stored forever
    uint cooperativeNonce;

    // dispute state is stored after dispute is started
    bytes32 disputeHash;
  }
  

  function packTokenReference(uint8 tokenType, address contractAddress, uint96 externalTokenId) public pure returns (bytes32) {
    require(tokenType <= 255);

    // Pack the contractAddress into the most significant 160 bits
    bytes32 packed = bytes32(uint256(uint160(contractAddress)) << 96);

    // Pack the tokenId into the next 96 bits
    packed |= bytes32(uint256(externalTokenId) << 8);

    // Pack the tokenType into the least significant 8 bits
    packed |= bytes32(uint256(tokenType));

    return packed;
  }

  function unpackTokenReference(bytes32 packed) public pure returns (address contractAddress, uint96 externalTokenId, uint8 tokenType) {
    // Unpack the contractAddress from the most significant 160 bits
    contractAddress = address(uint160(uint256(packed) >> 96));

    // Unpack the externalTokenId from the next 96 bits
    externalTokenId = uint96((uint256(packed) >> 8) & 0xFFFFFFFFFFFFFFFFFFFFFF);

    // Unpack the tokenType from the least significant 8 bits
    tokenType = uint8(uint256(packed) & 0xFF);

    return (contractAddress, externalTokenId, tokenType);
  }





  function registerHub(uint hub_id, string memory new_uri) public returns (uint) {
    if (hub_id == 0) {
      _hubs.push(Hub({
        entityId: bytes32(uint256(uint160(msg.sender))),
        uri: new_uri,
        gasused: 0
      }));
      return _hubs.length - 1;
    } else {
      require(bytes32(uint256(uint160(msg.sender))) == _hubs[hub_id].entityId, "Sender is not hub owner");
      _hubs[hub_id].uri = new_uri;
      return hub_id;
    }
  }

  struct ExternalTokenToReserve{
    bytes32 entity; // The entity to credit. If bytes32(0), defaults to msg.sender
    bytes32 packedToken;
    uint internalTokenId;
    uint amount;
  }
  function externalTokenToReserve(ExternalTokenToReserve memory params) public {
    bytes32 targetEntity = params.entity == bytes32(0) ? bytes32(uint256(uint160(msg.sender))) : params.entity;
    
    if (params.internalTokenId == 0) {
      // Check if token already exists using efficient lookup
      params.internalTokenId = tokenToId[params.packedToken];
      
      if (params.internalTokenId == 0) {
        // Create new token
        _tokens.push(params.packedToken);
        params.internalTokenId = _tokens.length - 1;
        tokenToId[params.packedToken] = params.internalTokenId;
        
        //console.log("Saved new token:", params.internalTokenId);
      }
    } else {
      params.packedToken = _tokens[params.internalTokenId];
      //require(_tokens[params.internalTokenId] == params.packedToken, "Token data mismatch");
    }


    (address contractAddress, uint96 tokenId, uint8 tokenType) = unpackTokenReference(params.packedToken);
    //console.log('unpackedToken ', contractAddress,tokenId,  tokenType);

    // todo: allow longer uint256 tokenId for ERC721 and ERC1155 
    // e.g. Rarible has format of 0xCreatorAddress..00000TokenId
    if (tokenType == TypeERC20) {
      require(IERC20(contractAddress).transferFrom(msg.sender, address(this), params.amount), "ERC20 transferFrom failed");
    } else if (tokenType == TypeERC721) {
      // 721 does not return bool on transfer
      IERC721(contractAddress).transferFrom(msg.sender, address(this), uint(tokenId));
      params.amount = 1; // For 721, amount is always 1
    } else if (tokenType == TypeERC1155) {
      IERC1155(contractAddress).safeTransferFrom(msg.sender, address(this), uint(tokenId), params.amount, "");
    }

    _reserves[targetEntity][params.internalTokenId] += params.amount;
    emit ReserveUpdated(targetEntity, params.internalTokenId, _reserves[targetEntity][params.internalTokenId]);
  }


  struct ReserveToExternalToken{
    bytes32 receivingEntity;
    uint tokenId;
    uint amount;
  }
  function reserveToExternalToken(bytes32 entity, ReserveToExternalToken memory params) internal {
    // enforceDebts(entity, params.tokenId); // DISABLED

    (address contractAddress, uint96 tokenId, uint8 tokenType) = unpackTokenReference(_tokens[params.tokenId]);
    //console.log('unpackedToken ', contractAddress,tokenId,  tokenType);

    require(_reserves[entity][params.tokenId] >= params.amount, "Not enough reserve");

    _reserves[entity][params.tokenId] -= params.amount;
    emit ReserveUpdated(entity, params.tokenId, _reserves[entity][params.tokenId]);

    if (tokenType == TypeERC20) {
      require(IERC20(contractAddress).transfer(address(uint160(uint256(params.receivingEntity))), params.amount));
    } else if (tokenType == TypeERC721) {
      IERC721(contractAddress).transferFrom(address(this), address(uint160(uint256(params.receivingEntity))), uint(tokenId));
    } else if (tokenType == TypeERC1155) {
      IERC1155(contractAddress).safeTransferFrom(address(this), address(uint160(uint256(params.receivingEntity))), uint(tokenId), params.amount, "");
    }

  }
  struct ReserveToReserve{
    bytes32 receivingEntity;
    uint tokenId;
    uint amount;
  }
  function reserveToReserve(bytes32 entity, ReserveToReserve memory params) internal {
    console.log("=== reserveToReserve ENTRY ===");
    console.log("reserveToReserve: from entity");
    console.logBytes32(entity);
    console.log("reserveToReserve: to entity");
    console.logBytes32(params.receivingEntity);
    console.log("reserveToReserve: tokenId");
    console.logUint(params.tokenId);
    console.log("reserveToReserve: amount");
    console.logUint(params.amount);
    console.log("reserveToReserve: sender balance");
    console.logUint(_reserves[entity][params.tokenId]);
    
    // enforceDebts(entity, params.tokenId); // DISABLED

    console.log("=== BALANCE CHECK ===");
    if (_reserves[entity][params.tokenId] >= params.amount) {
      console.log("SUCCESS: Balance check passed");
    } else {
      console.log("FAIL: Balance check failed - insufficient funds");
      console.log("Required:");
      console.logUint(params.amount);
      console.log("Available:");
      console.logUint(_reserves[entity][params.tokenId]);
    }

    require(_reserves[entity][params.tokenId] >= params.amount, "Insufficient balance for transfer");
    
    console.log("=== EXECUTING TRANSFER ===");
    _reserves[entity][params.tokenId] -= params.amount;
    _reserves[params.receivingEntity][params.tokenId] += params.amount;
    
    console.log("reserveToReserve: transfer complete");
    console.log("reserveToReserve: new sender balance");
    console.logUint(_reserves[entity][params.tokenId]);
    console.log("reserveToReserve: new recipient balance");
    console.logUint(_reserves[params.receivingEntity][params.tokenId]);
    
    emit ReserveUpdated(entity, params.tokenId, _reserves[entity][params.tokenId]);
    emit ReserveUpdated(params.receivingEntity, params.tokenId, _reserves[params.receivingEntity][params.tokenId]);
    emit ReserveTransferred(entity, params.receivingEntity, params.tokenId, params.amount);
    console.log("=== reserveToReserve COMPLETE ===");
  }

  /**
   * @notice Transfer control/dividend shares between entity reserves
   * @dev Wrapper around reserveToReserve with better semantics for control shares
   * @param to Recipient entity address
   * @param internalTokenId Internal token ID (use getControlShareTokenId helper)
   * @param amount Amount of shares to transfer
   */
  function transferControlShares(
    bytes32 entity,
    bytes32 to,
    uint256 internalTokenId,
    uint256 amount,
    string calldata /* purpose */
  ) internal {
    // enforceDebts(entity, internalTokenId); // DISABLED

    require(_reserves[entity][internalTokenId] >= amount, "Insufficient control shares");
    require(to != bytes32(0), "Invalid recipient");
    require(to != entity, "Cannot transfer to self");

    _reserves[entity][internalTokenId] -= amount;
    _reserves[to][internalTokenId] += amount;

    // emit ControlSharesTransferred(entity, to, internalTokenId, amount, purpose); // DISABLED
    emit ReserveUpdated(entity, internalTokenId, _reserves[entity][internalTokenId]);
    emit ReserveUpdated(to, internalTokenId, _reserves[to][internalTokenId]);
  }

  /**
   * @notice Get internal token ID for EntityProvider control/dividend tokens
   * @param entityProvider EntityProvider contract address
   * @param externalTokenId External token ID (entity number for control, entity number | 0x8000... for dividend)
   * @return internalTokenId Internal token ID for use with reserves
   */
  function getControlShareTokenId(address entityProvider, uint256 externalTokenId) external view returns (uint256 internalTokenId) {
    bytes32 packedToken = packTokenReference(TypeERC1155, entityProvider, uint96(externalTokenId));
    return tokenToId[packedToken];
  }




  
  function getDebts(bytes32 entity, uint tokenId) public view returns (Debt[] memory allDebts, uint currentDebtIndex) {
    currentDebtIndex = _debtIndex[entity][tokenId];
    allDebts = _debts[entity][tokenId];
  }


  /* triggered automatically before every reserveTo{Reserve/ChannelCollateral/PackedToken}
  /* can be called manually
  /* iterates over _debts starting from current _debtIndex, first-in-first-out 
  /* max _debts?
  /* Calling enforceDebts at the exit points is
  sound: it guarantees nobody can move funds while they owe. What you get is a single choke point that’s trivial to audit: “any reserve decrease first clears
  debts.”*/

  function enforceDebts(bytes32 entity, uint tokenId) public returns (uint totalDebts) {
    uint debtsLength = _debts[entity][tokenId].length;
    if (debtsLength == 0) {
      return 0;
    }
   
    uint memoryReserve = _reserves[entity][tokenId]; 
    uint memoryDebtIndex = _debtIndex[entity][tokenId];
    
    if (memoryReserve == 0){
      return debtsLength - memoryDebtIndex;
    }
    // allow partial enforcing in case there are too many _debts to pay off at once (over block gas limit)
    while (true) {
      Debt storage debt = _debts[entity][tokenId][memoryDebtIndex];
      
      if (memoryReserve >= debt.amount) {
        // can pay this debt off in full
        memoryReserve -= debt.amount;
        _reserves[debt.creditor][tokenId] += debt.amount;

        delete _debts[entity][tokenId][memoryDebtIndex];

        // Update reputation score for repayment
        EntityScore storage score = entityScores[entity];
        score.totalActiveDebts--;
        score.successfulRepayments++;
        if (score.totalActiveDebts == 0) {
          score.inDebtSince = 0; // Reset timestamp when all debts are clear
        }

        // last debt was paid off, the entity is debt free now
        if (memoryDebtIndex+1 == debtsLength) {
          memoryDebtIndex = 0;
          // resets .length to 0
          delete _debts[entity][tokenId]; 
          debtsLength = 0;
          break;
        }
        memoryDebtIndex++;
        _activeDebts[entity]--;
        
      } else {
        // pay off the debt partially and break the loop
        _reserves[debt.creditor][tokenId] += memoryReserve;
        debt.amount -= memoryReserve;
        memoryReserve = 0;
        break;
      }
    }

    // put memory variables back to storage
    _reserves[entity][tokenId] = memoryReserve;
    _debtIndex[entity][tokenId] = memoryDebtIndex;
    
    return debtsLength - memoryDebtIndex;
  }



  function channelKey(bytes32 e1, bytes32 e2) public pure returns (bytes memory) {
    //determenistic channel key is 64 bytes: concatenated lowerKey + higherKey
    return e1 < e2 ? abi.encodePacked(e1, e2) : abi.encodePacked(e2, e1);
  }

  function reserveToCollateral(bytes32 entity, ReserveToCollateral memory params) internal returns (bool completeSuccess) {
    uint tokenId = params.tokenId;
    bytes32 receivingEntity = params.receivingEntity;
   
    // debts must be paid before any transfers from reserve 
    enforceDebts(entity, tokenId);

    for (uint i = 0; i < params.pairs.length; i++) {
      bytes32 counterentity = params.pairs[i].entity;
      uint amount = params.pairs[i].amount;

      bytes memory ch_key = channelKey(receivingEntity, counterentity);

      logChannel(receivingEntity, counterentity);

      if (_reserves[entity][tokenId] >= amount) {
        ChannelCollateral storage col = _collaterals[ch_key][tokenId];

        _reserves[entity][tokenId] -= amount;
        col.collateral += amount;
        if (receivingEntity < counterentity) { // if receiver is left
          col.ondelta += int(amount);
        }

        emit TransferReserveToCollateral(receivingEntity, counterentity, col.collateral, col.ondelta, tokenId);

        log("Deposited to channel ", _collaterals[ch_key][tokenId].collateral);
      } else {
        log("Not enough funds", entity);
        return false;
      }
      logChannel(receivingEntity, counterentity);

    }


    return true;
  }




  /* mutually agreed update of channel state in a single atomic operation
  function cooperativeUpdate(bytes32 entity, CooperativeUpdate memory params) internal returns (bool) {
    bytes memory ch_key = channelKey(entity, params.counterentity);
    bytes32 left;
    bytes32 right;

    if (entity < params.counterentity) {
        left = entity;
        right = params.counterentity;
    } else {
        left = params.counterentity;
        right = entity;
    }


    bytes memory encoded_msg = abi.encode(MessageType.CooperativeUpdate, 
    ch_key, 
    _channels[ch_key].cooperativeNonce, 
    params.diffs, 
    params.forgiveDebtsInTokenIds);

    bytes32 hash = ECDSA.toEthSignedMessageHash(keccak256(encoded_msg));

    log('Encoded msg', encoded_msg);
    
    if(params.counterentity != ECDSA.recover(hash, params.sig)) {
      log("Invalid signer ", ECDSA.recover(hash, params.sig));
      return false;
    }

    // Update cooperative action scores
    entityScores[entity].cooperativeActions++;
    entityScores[params.counterentity].cooperativeActions++;

    Settled[] memory settledEvents = new Settled[](params.diffs.length);

    for (uint i = 0; i < params.diffs.length; i++) {
      Diff memory diff = params.diffs[i];
      uint tokenId = diff.tokenId;

      // ✅ INVARIANT CHECK: Total value change within the channel for this token must be zero.
      // leftReserveChange + rightReserveChange + collateralChange == 0
      int myReserveDiff = -(diff.peerReserveDiff + diff.collateralDiff);
      require(_reserves[entity][tokenId] >= uint(-myReserveDiff), "Not enough sender reserve");


      if (diff.peerReserveDiff < 0) {
        enforceDebts(params.counterentity, tokenId);
        require(_reserves[params.counterentity][tokenId] >= uint(-diff.peerReserveDiff), "Not enough peer reserve");

        _reserves[params.counterentity][tokenId] -= uint(-diff.peerReserveDiff);
      } else {
        _reserves[params.counterentity][tokenId] += uint(diff.peerReserveDiff);
      }


      // ensure that the entity has enough funds to apply the diffs
      if (myReserveDiff < 0) {
        enforceDebts(entity, tokenId);
        // This check is already implicitly done by the invariant and the peer's reserve check,
        // but an explicit check is safer.
        require(_reserves[entity][tokenId] >= uint(-myReserveDiff), "Not enough sender reserve");
        _reserves[entity][tokenId] -= uint(-myReserveDiff);
      } else {
        _reserves[entity][tokenId] += uint(myReserveDiff);
      }


      ChannelCollateral storage col = _collaterals[ch_key][tokenId];

      if (diff.collateralDiff < 0) {
        require(col.collateral >= uint(-diff.collateralDiff), "Not enough collateral");
        col.collateral -= uint(-diff.collateralDiff);
      } else {
        col.collateral += uint(diff.collateralDiff);
      }

      // ondeltaDiff can be arbitrary
      col.ondelta += diff.ondeltaDiff;

      // Populate event with final absolute values for easy off-chain consumption
      settledEvents[i] = Settled({
          left: left,
          right: right,
          tokenId: tokenId,
          leftReserve: _reserves[left][tokenId],
          rightReserve: _reserves[right][tokenId],
          collateral: col.collateral,
          ondelta: col.ondelta
      });
    }

    if (settledEvents.length > 0) {
        emit ChannelSettled(settledEvents);
    }

    _channels[ch_key].cooperativeNonce++;

    logChannel(entity, params.counterentity);
    return true;
  }

  /* COMMENTED OUT: Channel finalization disabled for development focus
  /* returns tokens to _reserves based on final deltas and _collaterals
  /* then increases cooperativeNonce to invalidate all previous dispute proofs

  /* todo: private visability
  /* function finalizeChannel(bytes32 entity1, 
  /*     bytes32 entity2, 
  /*     ProofBody memory proofbody, 
  /*     bytes memory arguments1, 
  /*     bytes memory arguments2) public returns (bool) 
  /* {
  /*   bytes32 leftAddress;
  /*   bytes32 rightAddress;
  /*   bytes memory leftArguments;
  /*   bytes memory rightArguments;
  /*   if (entity1 < entity2) {
  /*       leftAddress = entity1;
  /*       rightAddress = entity2;
  /*       leftArguments = arguments1;
  /*       rightArguments = arguments2;
  /*   } else {
  /*       leftAddress = entity2;
  /*       rightAddress = entity1;    
  /*       leftArguments = arguments2;
  /*       rightArguments = arguments1;
  /*   }

  /*   bytes memory ch_key = abi.encodePacked(leftAddress, rightAddress);

  /*   logChannel(leftAddress, rightAddress);

    // 1. create deltas (ondelta+offdelta) from proofbody
    int[] memory deltas = new int[](proofbody.offdeltas.length);
    for (uint i = 0;i<deltas.length;i++){
      deltas[i] = _collaterals[ch_key][proofbody.tokenIds[i]].ondelta + int(proofbody.offdeltas[i]);
    }
    
    // 2. process subcontracts and apply to deltas
    bytes[] memory decodedLeftArguments = abi.decode(leftArguments, (bytes[]));
    bytes[] memory decodedRightArguments = abi.decode(rightArguments, (bytes[]));

    for (uint i = 0; i < proofbody.subcontracts.length; i++){
      SubcontractClause memory sc = proofbody.subcontracts[i];
      
      // todo: check gas usage
      int[] memory newDeltas = SubcontractProvider(sc.subcontractProviderAddress).applyBatch(
        deltas, 
        sc.encodedBatch, 
        decodedLeftArguments[i],
        decodedRightArguments[i]
      );

      // sanity check 
      if (newDeltas.length != deltas.length) continue;

      // iterate over allowences and apply to new deltas if they are respected
      for (uint j = 0; j < sc.allowences.length; j++){
        Allowence memory allowence = sc.allowences[j];
        int difference = newDeltas[allowence.deltaIndex] - deltas[allowence.deltaIndex];
        if ((difference > 0 && uint(difference) > allowence.rightAllowence) || 
          (difference < 0 && uint(-difference) > allowence.leftAllowence) || 
          difference == 0){
          continue;
        }
        console.log("Update delta");
        console.logInt(deltas[allowence.deltaIndex]);
        console.logInt(newDeltas[allowence.deltaIndex]);
        deltas[allowence.deltaIndex] = newDeltas[allowence.deltaIndex];
      
      }
    }    

    // 3. split _collaterals
    for (uint i = 0;i<deltas.length;i++){
      uint tokenId = proofbody.tokenIds[i];
      int delta = deltas[i];
      ChannelCollateral storage col = _collaterals[ch_key][tokenId];

      if (delta >= 0 && uint(delta) <= col.collateral) {
        // collateral is split between entities
        _reserves[leftAddress][tokenId] += uint(delta);
        _reserves[rightAddress][tokenId] += col.collateral - uint(delta);
      } else {
        // one entity gets entire collateral, another pays credit from reserve or gets debt
        address getsCollateral = delta < 0 ? rightAddress : leftAddress;
        address getsDebt = delta < 0 ? leftAddress : rightAddress;
        uint debtAmount = delta < 0 ? uint(-delta) : uint(delta) - col.collateral;
        _reserves[getsCollateral][tokenId] += col.collateral;
        
        log('gets debt', getsDebt);
        log('debt', debtAmount);

        if (_reserves[getsDebt][tokenId] >= debtAmount) {
          // will pay right away without creating Debt
          _reserves[getsCollateral][tokenId] += debtAmount;
          _reserves[getsDebt][tokenId] -= debtAmount;
        } else {
          // pay what they can, and create Debt
          if (_reserves[getsDebt][tokenId] > 0) {
            _reserves[getsCollateral][tokenId] += _reserves[getsDebt][tokenId];
            debtAmount -= _reserves[getsDebt][tokenId];
            _reserves[getsDebt][tokenId] = 0;
          }
          _debts[getsDebt][tokenId].push(Debt({
            creditor: getsCollateral,
            amount: debtAmount
          }));
          _activeDebts[getsDebt]++;

          // Update reputation score for new debt
          EntityScore storage score = entityScores[getsDebt];
          score.totalActiveDebts++;
          if (score.inDebtSince == 0) {
            score.inDebtSince = uint48(block.timestamp);
          }
        }
      }

      delete _collaterals[ch_key][tokenId];
    }


    delete _channels[ch_key].disputeHash;

    _channels[ch_key].cooperativeNonce++;
   
    logChannel(leftAddress, rightAddress);

    return true;

  }

  /* DISABLED: disputes
  function cooperativeDisputeProof (CooperativeDisputeProof memory params) public returns (bool) {
    bytes memory ch_key = channelKey(bytes32(uint256(uint160(msg.sender))), params.counterentity);


    console.log("Received proof");
    console.logBytes32(keccak256(abi.encode(params.proofbody)));
    console.logBytes32(keccak256(params.initialArguments));

    bytes memory encoded_msg = abi.encode(
      MessageType.CooperativeDisputeProof, 
      ch_key, 
      _channels[ch_key].cooperativeNonce,
      keccak256(abi.encode(params.proofbody)),
      keccak256(params.initialArguments)
    );

    bytes32 hash = keccak256(encoded_msg);


    bytes32 final_hash = ECDSA.toEthSignedMessageHash(keccak256(encoded_msg));

    require(ECDSA.recover(final_hash, params.sig) == params.counterentity);

    require(_channels[ch_key].disputeHash == bytes32(0));

    delete _channels[ch_key].disputeHash;

    finalizeChannel(bytes32(uint256(uint160(msg.sender))), params.counterentity, params.proofbody, params.finalArguments, params.initialArguments);
    
    emit CooperativeClose(bytes32(uint256(uint160(msg.sender))), params.counterentity, _channels[ch_key].cooperativeNonce);
  }
  */


  /* DISABLED: dispute functions
  function initialDisputeProof(InitialDisputeProof memory params) public returns (bool) {
  /*   bytes memory ch_key = channelKey(bytes32(uint256(uint160(msg.sender))), params.counterentity);

  /*   // Update dispute scores for both parties
  /*   entityScores[bytes32(uint256(uint160(msg.sender)))].totalDisputes++;
  /*   entityScores[params.counterentity].totalDisputes++;

  /*   // entities must always hold a dispute proof with cooperativeNonce equal or higher than the one in the contract
  /*   require(_channels[ch_key].cooperativeNonce <= params.cooperativeNonce);

  /*   bytes memory encoded_msg = abi.encode(MessageType.DisputeProof, 
  /*     ch_key, 
  /*     params.cooperativeNonce, 
  /*     params.disputeNonce, 
  /*     params.proofbodyHash);

  /*   bytes32 final_hash = ECDSA.toEthSignedMessageHash(keccak256(encoded_msg));

  /*   log('encoded_msg',encoded_msg);

  /*   require(ECDSA.recover(final_hash, params.sig) == params.counterentity, "Invalid signer");

  /*   require(_channels[ch_key].disputeHash == bytes32(0));

  /*   bytes memory encodedDispute = abi.encodePacked(params.cooperativeNonce,
  /*     params.disputeNonce, 
  /*     bytes32(uint256(uint160(msg.sender))) < params.counterentity, // is started by left
  /*     block.number + 20,
  /*     params.proofbodyHash, 
  /*     keccak256(abi.encodePacked(params.initialArguments)));

  /*   _channels[ch_key].disputeHash = keccak256(encodedDispute);
  /*   emit DisputeStarted(bytes32(uint256(uint160(msg.sender))), params.counterentity, params.disputeNonce, params.initialArguments);
  /* }

  /* COMMENTED OUT: Dispute functionality disabled for development focus
  /* function finalDisputeProof(FinalDisputeProof memory params) public returns (bool) {
  /*   bytes memory ch_key = channelKey(bytes32(uint256(uint160(msg.sender))), params.counterentity);

  /*   // Update dispute scores for both parties involved in the finalization
  /*   entityScores[bytes32(uint256(uint160(msg.sender)))].totalDisputes++;
  /*   entityScores[params.counterentity].totalDisputes++;

  /*   // verify the dispute was started

  /*   if (params.sig.length > 0) {
  /*     // Validate signature if provided
  /*     bytes memory encoded_msg = abi.encode(MessageType.FinalDisputeProof, 
  /*       ch_key, 
  /*       params.cooperativeNonce, 
  /*       params.initialDisputeNonce, 
  /*       params.finalDisputeNonce);
        
  /*     bytes32 final_hash = ECDSA.toEthSignedMessageHash(keccak256(encoded_msg));
  /*     log('encoded_msg',encoded_msg);
  /*     require(ECDSA.recover(final_hash, params.sig) == params.counterentity, "Invalid signer");

  /*     // TODO: if nonce is same, Left one's proof is considered valid

  /*     require(params.initialDisputeNonce < params.finalDisputeNonce, "New nonce must be greater");
  /*   } else {
  /*     // counterparty agrees or does not respond 
  /*     bool senderIsCounterparty = params.startedByLeft != (bytes32(uint256(uint160(msg.sender))) < params.counterentity);
  /*     require(senderIsCounterparty || (block.number >= params.disputeUntilBlock), "Dispute period ended");
  /*     require(params.initialProofbodyHash == keccak256(abi.encode(params.finalProofbody)), "Invalid proofbody");
  /*   }
    

  /*   finalizeChannel(bytes32(uint256(uint160(msg.sender))), params.counterentity, params.finalProofbody, params.finalArguments, params.initialArguments);
  

  /*   return true;
  /* }





  struct TokenReserveDebts {
    uint reserve;
    uint debtIndex;
    Debt[] debts;
  }
  
  struct UserReturn {
    uint ETH_balance;
    TokenReserveDebts[] tokens;
  }

  struct ChannelReturn{
    ChannelInfo channel;
    ChannelCollateral[] collaterals;
  }
  
  
  /* return users with reserves in provided tokens
  function getUsers(bytes32[] memory entities, uint[] memory tokenIds) external view returns (UserReturn[] memory response) {
    response = new UserReturn[](entities.length);
    for (uint i = 0;i<entities.length;i++){
      bytes32 entity = entities[i];
      response[i] = UserReturn({
        ETH_balance: address(uint160(uint256(entity))).balance,
        tokens: new TokenReserveDebts[](tokenIds.length)
      });
    
      for (uint j = 0;j<tokenIds.length;j++){
        response[i].tokens[j]= TokenReserveDebts({
          reserve: _reserves[entity][tokenIds[j]],
          debtIndex: _debtIndex[entity][tokenIds[j]],
          debts: _debts[entity][tokenIds[j]]
        });
      }
    }
    
    return response;
  }
  
  /* get many _channels around one address, with collaterals in provided tokens
  function getChannels(bytes32 entity, bytes32[] memory counterentities, uint[] memory tokenIds) public view returns (ChannelReturn[] memory response) {
    bytes memory ch_key;

    // set length of the response array
    response = new ChannelReturn[](counterentities.length);

    for (uint i = 0;i<counterentities.length;i++){
      ch_key = channelKey(entity, counterentities[i]);

      response[i]=ChannelReturn({
        channel: _channels[ch_key],
        collaterals: new ChannelCollateral[](tokenIds.length)
      });

      for (uint j = 0;j<tokenIds.length;j++){
        response[i].collaterals[j]=_collaterals[ch_key][tokenIds[j]];
      }      
    }
    return response;    
  }

  /*

  function getAllHubs () public view returns (Hub[] memory) {
    return _hubs;
  }
  function getAllTokens () public view returns (bytes32[] memory) {
    return _tokens;
  }
  


  function createDebt(address addr, address creditor, uint tokenId, uint amount) public {
    _debts[addr][tokenId].push(Debt({
      creditor: creditor,
      amount: amount
    }));
  }
  */


  function logChannel(bytes32 e1, bytes32 e2) public {
    /*
    bytes memory ch_key = channelKey(e1, e2);
    log(">>> Logging channel", ch_key);
    log("cooperativeNonce", _channels[ch_key].cooperativeNonce);
    log("disputeHash", _channels[ch_key].disputeHash);

    for (uint i = 0; i < _tokens.length; i++) {
      log("Token", _tokens[i]);
      log("Left:", _reserves[e1][i]);
      log("Right:", _reserves[e2][i]);
      log("collateral", _collaterals[ch_key][i].collateral);
      log("ondelta", _collaterals[ch_key][i].ondelta);
    }*/
  }       

  /* Events for control/dividend shares
  event ControlSharesReceived(
    address indexed entityProvider,
    bytes32 indexed fromEntity, 
    uint256 indexed tokenId,
    uint256 amount,
    bytes data
  );
  
  event ControlSharesTransferred(
    bytes32 indexed from,
    bytes32 indexed to,
    uint256 indexed internalTokenId,
    uint256 amount,
    string purpose
  );

  function onERC1155Received(
      address operator,
      address from,
      uint256 id,
      uint256 value,
      bytes calldata data
  )
      external
      returns(bytes4)
  {
    // If this is from an approved EntityProvider, automatically add to reserves
    if (approvedEntityProviders[msg.sender]) {
      // Create or find internal token ID for this EntityProvider token
      bytes32 packedToken = packTokenReference(TypeERC1155, msg.sender, uint96(id));
      
      // Use efficient lookup instead of O(n) iteration
      uint256 internalTokenId = tokenToId[packedToken];
      
      // Create new internal token ID if not found
      if (internalTokenId == 0) {
        _tokens.push(packedToken);
        internalTokenId = _tokens.length - 1;
        tokenToId[packedToken] = internalTokenId;
      }
      
      // Add to sender's reserves (the entity that sent the tokens)
      _reserves[bytes32(uint256(uint160(from)))][internalTokenId] += value;
      
      emit ControlSharesReceived(msg.sender, bytes32(uint256(uint160(from))), id, value, data);
    }
    
    return this.onERC1155Received.selector;
  }

  /* =================================================================================================
  /* === SHORTCUT FUNCTIONS ==========================================================================
  /* =================================================================================================

  /**
   * @notice Unilateral action to move funds from reserve to a channel's collateral.
   * @dev This does not require a counterparty signature as it only adds funds to the channel.
   * @param peer The counterparty in the channel.
   * @param tokenId The internal ID of the token being moved.
   * @param amount The amount to move.
   */

}

--- contracts/ERC721Mock.sol ---
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;

import "@openzeppelin/contracts/token/ERC721/ERC721.sol";

contract ERC721Mock is ERC721 {
    uint256 private _currentTokenId = 0;

    constructor(string memory name, string memory symbol) ERC721(name, symbol) {}

    function mint(address to, uint256 tokenId) public {
        _mint(to, tokenId);
    }
}
--- contracts/console.sol ---
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;
contract Console {
  event LogString(string, string);
  function log(string  memory s , string memory x) public {
    emit LogString(s, x);
  }

  event LogUint(string, uint);
  function log(string  memory s , uint  x) public {
    emit LogUint(s, x);
  }

  event LogInt(string, int);
  function log(string  memory s , int  x) public  {
    emit LogInt(s, x);
  }
  
  event LogBytes(string, bytes);
  function log(string  memory s , bytes  memory x) public  {
    emit LogBytes(s, x);
  }
  
  event LogBytes32(string, bytes32);
  function log(string  memory s , bytes32  x)  public {
    emit LogBytes32(s, x);
  }

  event LogAddress(string, address);
  function log(string  memory s , address  x) public  {
    emit LogAddress(s, x);
  }

  event LogBool(string, bool);
  function log(string  memory s , bool  x)  public {
    emit LogBool(s, x);
  }








}
--- contracts/SubcontractProvider.sol ---
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;
pragma experimental ABIEncoderV2;

import "./Token.sol";

import "./ECDSA.sol";
import "./console.sol";
import "hardhat/console.sol";

contract SubcontractProvider is Console {
  mapping(bytes32 => uint) public hashToBlock;
  uint MAXUINT32 = type(uint32).max;

  constructor() {
    revealSecret(bytes32(0));
  }
  
  struct Batch {
    Payment[] payment;
    Swap[] swap;
  }

  // actual subcontract structs
  struct Payment {
    uint deltaIndex;
    int amount;
    uint revealedUntilBlock;
    bytes32 hash;
  }

  struct Swap {
    bool ownerIsLeft;

    uint addDeltaIndex;
    uint addAmount;

    uint subDeltaIndex;
    uint subAmount;
  }

  // https://en.wikipedia.org/wiki/Credit_default_swap
  struct CreditDefaultSwap {
    uint deltaIndex;
    int amount;
    address referenceEntity;
    uint tokenId;
    uint exerciseUntilBlock;
  }

  function encodeBatch (Batch memory b) public pure returns (bytes memory) {
    return abi.encode(b);
  }



  // applies arbitrary changes to deltas
  function applyBatch(
    int[] memory deltas,
    bytes calldata encodedBatch,
    bytes calldata leftArguments,
    bytes calldata rightArguments
  ) public returns (int[] memory) {

    Batch memory decodedBatch = abi.decode(encodedBatch, (Batch));

    uint[] memory lArgs = abi.decode(leftArguments, (uint[]));
    uint[] memory rArgs = abi.decode(rightArguments, (uint[]));
    
    for (uint i = 0; i < decodedBatch.payment.length; i++) {
      applyPayment(deltas, decodedBatch.payment[i]);
    }

    uint leftSwaps = 0;
    for (uint i = 0; i < decodedBatch.swap.length; i++) {
      Swap memory swap = decodedBatch.swap[i];

      uint32 fillRatio = uint32(swap.ownerIsLeft ? lArgs[leftSwaps] : rArgs[i  - leftSwaps]);

      applySwap(deltas, swap, fillRatio);
      //logDeltas("Deltas after swap", deltas);

      if (swap.ownerIsLeft) {
        leftSwaps++;
      }
    }

    return deltas;
  }

  function applyPayment(int[] memory deltas, Payment memory payment) private {
    // apply amount to delta if revealed on time
    // this is "sprites" approach (https://arxiv.org/pdf/1702.05812) 
    // the opposite is "blitz" (https://www.usenix.org/system/files/sec21fall-aumayr.pdf)
    uint revealedAt = hashToBlock[payment.hash];
    if (revealedAt == 0 || revealedAt > payment.revealedUntilBlock) {
      return;
    }

    logDeltas("Before payment", deltas);
    deltas[payment.deltaIndex] += payment.amount;
    logDeltas("After payment", deltas);
  }

  function applySwap(int[] memory deltas, Swap memory swap, uint32 fillRatio) private {
    logDeltas("Before swap", deltas);
    deltas[swap.addDeltaIndex] += int(swap.addAmount * fillRatio / MAXUINT32);
    deltas[swap.subDeltaIndex] -= int(swap.subAmount * fillRatio / MAXUINT32);
    logDeltas("After swap", deltas);
  }





  function revealSecret(bytes32 secret) public {
    console.log("Revealing HTLC secret:");
    console.logBytes32(secret);
    console.logBytes32(keccak256(abi.encode(secret)));
    hashToBlock[keccak256(abi.encode(secret))] = block.number;
  }
  
  // anyone can get gas refund by deleting very old revealed secrets
  function cleanSecret(bytes32 hash) public {
    if (hashToBlock[hash] != 0 && hashToBlock[hash] < block.number - 100000){
      delete hashToBlock[hash];
    }
  }

  function logDeltas(string memory _msg, int[] memory deltas) public pure {
    console.log(_msg);
    for (uint i = 0; i < deltas.length; i++) {
      console.logInt(deltas[i]);
    }
    console.log('====================');
  }



}
--- src/j-event-watcher.ts ---
/**
 * J-Machine Event Watcher
 *
 * First-principles design:
 * 1. Find all proposer replicas in server
 * 2. Sync each proposer from their last jBlock (not duplicate events)
 * 3. Feed new j-events to proposer replicas through server processUntilEmpty
 * 4. Simple single polling loop - no complex timers or historical sync
 */

import { ethers } from 'ethers';
import type { Env } from './types.js';

// Debug flags - reduced for cleaner output
const DEBUG = false; // Reduced j-watcher verbosity
const HEAVY_LOGS = false;

// Event types we care about from the jurisdiction

interface WatcherConfig {
  rpcUrl: string;
  entityProviderAddress: string;
  depositoryAddress: string;
  startBlock?: number;
}

interface SignerConfig {
  signerId: string;
  privateKey: string;
  entityIds: string[]; // Which entities this signer cares about
}

export class JEventWatcher {
  private provider: ethers.JsonRpcProvider;
  private entityProviderContract: ethers.Contract;
  private depositoryContract: ethers.Contract;
  private signers: Map<string, SignerConfig> = new Map();
  private isWatching: boolean = false;

  // Minimal ABIs for events we need
  private entityProviderABI = [
    'event EntityRegistered(bytes32 indexed entityId, uint256 indexed entityNumber, bytes32 boardHash)',
    'event ControlSharesReleased(bytes32 indexed entityId, address indexed depository, uint256 controlAmount, uint256 dividendAmount, string purpose)',
    'event NameAssigned(string indexed name, uint256 indexed entityNumber)',
  ];

  private depositoryABI = [
    'event ControlSharesReceived(address indexed entityProvider, address indexed fromEntity, uint256 indexed tokenId, uint256 amount, bytes data)',
    'event ReserveUpdated(bytes32 indexed entity, uint256 indexed tokenId, uint256 newBalance)',
    'event ReserveTransferred(bytes32 indexed from, bytes32 indexed to, uint256 indexed tokenId, uint256 amount)',
    'event SettlementProcessed(bytes32 indexed leftEntity, bytes32 indexed rightEntity, uint256 indexed tokenId, uint256 leftReserve, uint256 rightReserve, uint256 collateral, int256 ondelta)',
  ];

  constructor(config: WatcherConfig) {
    this.provider = new ethers.JsonRpcProvider(config.rpcUrl);

    this.entityProviderContract = new ethers.Contract(
      config.entityProviderAddress,
      this.entityProviderABI,
      this.provider,
    );

    this.depositoryContract = new ethers.Contract(config.depositoryAddress, this.depositoryABI, this.provider);

    if (DEBUG) {
      console.log(`🔭 J-WATCHER: Initialized with RPC: ${config.rpcUrl}`);
      console.log(`🔭 J-WATCHER: EntityProvider: ${config.entityProviderAddress}`);
      console.log(`🔭 J-WATCHER: Depository: ${config.depositoryAddress}`);
    }
  }

  /**
   * Add a signer configuration for monitoring (legacy compatibility)
   */
  addSigner(signerId: string, privateKey: string, entityIds: string[]) {
    this.signers.set(signerId, {
      signerId,
      privateKey,
      entityIds,
    });

    if (DEBUG) {
      console.log(`🔭 J-WATCHER: Added signer ${signerId} monitoring entities: ${entityIds.join(', ')}`);
    }
  }

  /**
   * Start watching for jurisdiction events
   */
  async startWatching(env: Env): Promise<void> {
    if (this.isWatching) {
      console.log('🔭 J-WATCHER: Already watching');
      return;
    }

    this.isWatching = true;
    console.log('🔭 J-WATCHER: Starting simple first-principles watcher...');

    try {
      // Test blockchain connection
      const currentBlock = await this.provider.getBlockNumber();
      console.log(`🔭 J-WATCHER: Connected to blockchain at block ${currentBlock}`);
    } catch (error) {
      console.log(`🔭⚠️  J-WATCHER: Blockchain not ready, will retry: ${error instanceof Error ? error.message : String(error)}`);
    }

    // Simple polling every 1 second - first principles approach
    setInterval(async () => {
      if (!this.isWatching) return;

      try {
        await this.syncAllProposerReplicas(env);
      } catch (error) {
        if (DEBUG && !(error instanceof Error && error.message.includes('ECONNREFUSED'))) {
          console.error('🔭❌ J-WATCHER: Sync error:', error instanceof Error ? error.message : String(error));
        }
      }
    }, 1000);

    console.log('🔭 J-WATCHER: Started with simple 1s polling');
  }

  /**
   * Stop watching
   */
  stopWatching(): void {
    this.isWatching = false;
    this.entityProviderContract.removeAllListeners();
    this.depositoryContract.removeAllListeners();
    console.log('🔭 J-WATCHER: Stopped watching');
  }

  /**
   * Core logic: Find proposer replicas, sync each from last jBlock
   * This is the first-principles approach you requested
   */
  private async syncAllProposerReplicas(env: Env): Promise<void> {
    try {
      const currentBlock = await this.provider.getBlockNumber();

      if (DEBUG) {
        console.log(`🔭🔍 SYNC-START: Current blockchain block=${currentBlock}, total replicas=${env.replicas.size}`);
        console.log(`🔭🔍 SYNC-ENV-TIMESTAMP: env.timestamp=${env.timestamp}`);
        for (const [replicaKey, replica] of env.replicas.entries()) {
          console.log(`🔭🔍 REPLICA-STATE: ${replicaKey} → jBlock=${replica.state.jBlock}, height=${replica.state.height}, isProposer=${replica.isProposer}`);
        }
      }

      // 1. Find all proposer replicas that need syncing
      const proposerReplicas: Array<{entityId: string, signerId: string, lastJBlock: number}> = [];

      for (const [replicaKey, replica] of env.replicas.entries()) {
        if (replica.isProposer) {
          const [entityId, signerId] = replicaKey.split(':');
          if (!entityId || !signerId) continue;
          const lastJBlock = replica.state.jBlock || 0;

          if (DEBUG) {
            console.log(`🔭🔍 REPLICA-CHECK: ${signerId} → Entity ${entityId.slice(0,10)}... jBlock=${lastJBlock}, currentBlock=${currentBlock}, isProposer=${replica.isProposer}`);
          }

          if (lastJBlock < currentBlock) {
            proposerReplicas.push({ entityId, signerId, lastJBlock });

            if (HEAVY_LOGS) {
              console.log(`🔭🔍 PROPOSER-SYNC: Found proposer ${signerId} for entity ${entityId.slice(0,10)}... at jBlock ${lastJBlock}, needs sync to ${currentBlock}`);
            }
          } else {
            if (DEBUG) {
              console.log(`🔭✅ REPLICA-SYNCED: ${signerId} → Entity ${entityId.slice(0,10)}... already synced (jBlock=${lastJBlock} >= currentBlock=${currentBlock})`);
            }
          }
        }
      }

      if (proposerReplicas.length === 0) {
        // Completely silent when no sync needed
        return;
      }

      if (DEBUG) {
        console.log(`🔭⚡ SYNC: ${proposerReplicas.length} proposer replicas need sync to block ${currentBlock}`);
        for (const { entityId, signerId, lastJBlock } of proposerReplicas) {
          console.log(`🔭📋 SYNC-QUEUE: ${signerId} → Entity ${entityId.slice(0,10)}... from j-block ${lastJBlock + 1} to ${currentBlock}`);
        }
      }

      // 2. Sync each proposer replica from their last jBlock
      for (const { entityId, signerId, lastJBlock } of proposerReplicas) {
        await this.syncEntityFromJBlock(entityId, signerId, lastJBlock + 1, currentBlock, env);
      }

    } catch (error) {
      // Don't spam connection errors
      if (!(error instanceof Error) || !error.message.includes('ECONNREFUSED')) {
        throw error;
      }
    }
  }

  /**
   * Sync a specific entity from its last jBlock to current block
   */
  private async syncEntityFromJBlock(
    entityId: string,
    signerId: string,
    fromBlock: number,
    toBlock: number,
    env: Env
  ): Promise<void> {
    if (fromBlock > toBlock) return;

    if (DEBUG) {
      console.log(`🔭📡 ENTITY-SYNC: Entity ${entityId.slice(0,10)}... (${signerId}) from j-block ${fromBlock} to ${toBlock}`);
    }

    try {
      // Get new events for this entity in this block range
      const events = await this.getEntityEventsInRange(entityId, fromBlock, toBlock);

      if (events.length === 0) {
        if (HEAVY_LOGS) {
          console.log(`🔭⚪ ENTITY-SYNC: No events found for entity ${entityId.slice(0,10)}... in blocks ${fromBlock}-${toBlock}`);
        }
        return;
      }

      console.log(`🔭📦 ENTITY-SYNC: Found ${events.length} new events for entity ${entityId.slice(0,10)}... in blocks ${fromBlock}-${toBlock}`);

      // Process events chronologically and feed to proposer
      for (const event of events) {
        this.feedEventToProposer(entityId, signerId, event, env);
      }

      console.log(`🔭✅ ENTITY-SYNC: Queued ${events.length} events for entity ${entityId.slice(0,10)}... (${signerId})`);

    } catch (error) {
      console.error(`🔭❌ ENTITY-SYNC: Error syncing entity ${entityId.slice(0,10)}...`, error instanceof Error ? error.message : String(error));
    }
  }

  /**
   * Get all events for a specific entity in block range
   */
  private async getEntityEventsInRange(entityId: string, fromBlock: number, toBlock: number) {
    if (HEAVY_LOGS) {
      console.log(`🔭🔍 EVENT-QUERY: Fetching events for entity ${entityId.slice(0,10)}... blocks ${fromBlock}-${toBlock}`);
    }

    // Get both ReserveUpdated and SettlementProcessed events for this entity
    const reserveFilter = this.depositoryContract.filters['ReserveUpdated'];
    const settlementFilter = this.depositoryContract.filters['SettlementProcessed'];

    if (!reserveFilter || !settlementFilter) {
      throw new Error('Contract filters not available');
    }

    const [reserveEvents, settlementEventsLeft, settlementEventsRight] = await Promise.all([
      this.depositoryContract.queryFilter(
        reserveFilter(entityId),
        fromBlock,
        toBlock
      ),
      this.depositoryContract.queryFilter(
        settlementFilter(entityId, null, null),
        fromBlock,
        toBlock
      ),
      this.depositoryContract.queryFilter(
        settlementFilter(null, entityId, null),
        fromBlock,
        toBlock
      )
    ]);

    if (HEAVY_LOGS) {
      console.log(`🔭🔍 EVENT-QUERY: Entity ${entityId.slice(0,10)}... - Reserve: ${reserveEvents.length}, SettlementLeft: ${settlementEventsLeft.length}, SettlementRight: ${settlementEventsRight.length}`);
    }

    // Combine and sort chronologically
    const allEvents = [
      ...reserveEvents.map(e => ({ ...e, eventType: 'ReserveUpdated' })),
      ...settlementEventsLeft.map(e => ({ ...e, eventType: 'SettlementProcessed', side: 'left' })),
      ...settlementEventsRight.map(e => ({ ...e, eventType: 'SettlementProcessed', side: 'right' }))
    ].sort((a, b) => {
      if (a.blockNumber !== b.blockNumber) {
        return a.blockNumber - b.blockNumber;
      }
      return (a.transactionIndex || 0) - (b.transactionIndex || 0);
    });

    if (HEAVY_LOGS && allEvents.length > 0) {
      console.log(`🔭🔍 EVENT-QUERY: Entity ${entityId.slice(0,10)}... total events: ${allEvents.length}`);
      allEvents.forEach((event, i) => {
        console.log(`🔭🔍 EVENT-${i}: ${event.eventType} at block ${event.blockNumber} tx ${event.transactionIndex}`);
      });
    }

    return allEvents;
  }

  /**
   * Feed event to proposer replica via server entityInputs
   */
  private feedEventToProposer(entityId: string, signerId: string, event: any, env: Env): void {
    let entityTx;

    if (event.eventType === 'ReserveUpdated') {
      entityTx = {
        type: 'j_event' as const,
        data: {
          from: signerId,
          event: {
            type: 'ReserveUpdated',
            data: {
              entity: entityId,
              tokenId: Number(event.args.tokenId),
              newBalance: event.args.newBalance.toString(),
              symbol: `TKN${event.args.tokenId}`,
              decimals: 18,
            },
          },
          observedAt: Date.now(),
          blockNumber: event.blockNumber,
          transactionHash: event.transactionHash,
        },
      };

      if (DEBUG) {
        console.log(`🔭💰 R2R-EVENT: Entity ${entityId.slice(0,10)}... Token ${event.args.tokenId} Balance ${(Number(event.args.newBalance) / 1e18).toFixed(4)} (block ${event.blockNumber})`);
      }

    } else if (event.eventType === 'SettlementProcessed') {
      const isLeft = event.side === 'left';
      const counterpartyId = isLeft ? event.args.rightEntity.toString() : event.args.leftEntity.toString();
      const ownReserve = isLeft ? event.args.leftReserve : event.args.rightReserve;
      const counterpartyReserve = isLeft ? event.args.rightReserve : event.args.leftReserve;
      const ondelta = isLeft ? event.args.ondelta : -event.args.ondelta;

      entityTx = {
        type: 'j_event' as const,
        data: {
          from: signerId,
          event: {
            type: 'SettlementProcessed',
            data: {
              leftEntity: event.args.leftEntity.toString(),
              rightEntity: event.args.rightEntity.toString(),
              counterpartyEntityId: counterpartyId,
              tokenId: Number(event.args.tokenId),
              ownReserve: ownReserve.toString(),
              counterpartyReserve: counterpartyReserve.toString(),
              collateral: event.args.collateral.toString(),
              ondelta: ondelta.toString(),
              side: event.side,
            },
          },
          observedAt: Date.now(),
          blockNumber: event.blockNumber,
          transactionHash: event.transactionHash,
        },
      };

      if (DEBUG) {
        console.log(`🔭💱 SETTLE-EVENT: Entity ${entityId.slice(0,10)}... vs ${counterpartyId.slice(0,10)}... (${event.side} side, block ${event.blockNumber})`);
      }
    }

    if (entityTx) {
      // Feed to server processing queue
      console.log(`🚨 J-WATCHER-CREATING-EVENT: ${signerId} creating j-event ${event.eventType} block=${event.blockNumber} for entity ${entityId.slice(0,10)}...`);
      env.serverInput.entityInputs.push({
        entityId: entityId,
        signerId: signerId,
        entityTxs: [entityTx],
      });

      console.log(`🔭✅ J-WATCHER-QUEUED: ${signerId} → Entity ${entityId.slice(0,10)}... (${event.eventType}) block=${event.blockNumber} - Queue length now: ${env.serverInput.entityInputs.length}`);
    }
  }

  /**
   * Legacy compatibility method - not used in first-principles design
   */
  async syncNewlyCreatedEntities(_env: Env): Promise<boolean> {
    if (DEBUG) {
      console.log('🔭⚠️  J-WATCHER: syncNewlyCreatedEntities called (legacy) - first-principles design handles this automatically');
    }
    return false;
  }

  /**
   * Get current blockchain block number
   */
  async getCurrentBlockNumber(): Promise<number> {
    try {
      return await this.provider.getBlockNumber();
    } catch (error) {
      if (DEBUG) {
        console.log(`🔭⚠️  J-WATCHER: Could not get current block, using 0:`, error instanceof Error ? error.message : String(error));
      }
      return 0;
    }
  }

  /**
   * Get current watching status
   */
  getStatus(): { isWatching: boolean; signerCount: number } {
    return {
      isWatching: this.isWatching,
      signerCount: this.signers.size,
    };
  }
}

/**
 * Create and configure a J-Event Watcher instance
 */
export function createJEventWatcher(config: WatcherConfig): JEventWatcher {
  return new JEventWatcher(config);
}

/**
 * Helper function to set up watcher with common configuration
 * Updated for first-principles design
 */
export async function setupJEventWatcher(
  env: Env,
  rpcUrl: string,
  entityProviderAddr: string,
  depositoryAddr: string,
): Promise<JEventWatcher> {
  const watcher = createJEventWatcher({
    rpcUrl,
    entityProviderAddress: entityProviderAddr,
    depositoryAddress: depositoryAddr,
    startBlock: 0,
  });

  // Add example signers (legacy compatibility - not used in first-principles design)
  watcher.addSigner('s1', 's1-private-key', ['1', '2', '3', '4', '5']);
  watcher.addSigner('s2', 's2-private-key', ['1', '2', '3', '4', '5']);
  watcher.addSigner('s3', 's3-private-key', ['1', '2', '3', '4', '5']);

  await watcher.startWatching(env);

  if (DEBUG) {
    console.log('🔭✅ J-WATCHER: Setup complete with first-principles design');
  }

  return watcher;
}
--- src/account-utils.ts ---
/**
 * Account utilities for calculating balances and derived states
 * Based on old_src/app/Channel.ts deriveDelta logic
 */

import { Delta, DerivedDelta } from './types';
import { validateDelta } from './validation-utils';

/**
 * Determine if an entity is the "left" party in a bilateral account (like old_src Channel.ts)
 * @param myEntityId - Current entity ID
 * @param counterpartyEntityId - Other entity ID
 * @returns true if current entity is left (lexicographically smaller)
 */
export function isLeft(myEntityId: string, counterpartyEntityId: string): boolean {
  return myEntityId < counterpartyEntityId;
}

const BASE_CREDIT_LIMIT = 1_000_000n;

/**
 * Derive account balance information for a specific token
 * @param delta - The delta structure for this token
 * @param isLeft - Whether we are the left party in this account
 * @returns Derived balance information including capacities and credits
 */
export function deriveDelta(delta: Delta, isLeft: boolean): DerivedDelta {
  // VALIDATE AT SOURCE: Financial data must be valid
  validateDelta(delta, 'deriveDelta');

  const nonNegative = (x: bigint): bigint => x < 0n ? 0n : x;

  const totalDelta = delta.ondelta + delta.offdelta;
  const collateral = nonNegative(delta.collateral);

  let ownCreditLimit = delta.leftCreditLimit;
  let peerCreditLimit = delta.rightCreditLimit;

  let inCollateral = totalDelta > 0n ? nonNegative(collateral - totalDelta) : collateral;
  let outCollateral = totalDelta > 0n ? (totalDelta > collateral ? collateral : totalDelta) : 0n;

  let inOwnCredit = nonNegative(-totalDelta);
  if (inOwnCredit > ownCreditLimit) inOwnCredit = ownCreditLimit;

  let outPeerCredit = nonNegative(totalDelta - collateral);
  if (outPeerCredit > peerCreditLimit) outPeerCredit = peerCreditLimit;

  let outOwnCredit = nonNegative(ownCreditLimit - inOwnCredit);
  let inPeerCredit = nonNegative(peerCreditLimit - outPeerCredit);

  let inAllowence = delta.rightAllowence;
  let outAllowence = delta.leftAllowence;

  const totalCapacity = collateral + ownCreditLimit + peerCreditLimit;

  let inCapacity = nonNegative(inOwnCredit + inCollateral + inPeerCredit - inAllowence);
  let outCapacity = nonNegative(outPeerCredit + outCollateral + outOwnCredit - outAllowence);

  if (!isLeft) {
    // flip the view
    [inCollateral, inAllowence, inCapacity,
     outCollateral, outAllowence, outCapacity] =
    [outCollateral, outAllowence, outCapacity,
     inCollateral, inAllowence, inCapacity];

    [ownCreditLimit, peerCreditLimit] = [peerCreditLimit, ownCreditLimit];
    // swap in<->out own<->peer credit
    [outOwnCredit, inOwnCredit, outPeerCredit, inPeerCredit] =
    [inPeerCredit, outPeerCredit, inOwnCredit, outOwnCredit];
  }

  // ASCII visualization
  const totalWidth = Number(totalCapacity);
  const leftCreditWidth = Math.floor((Number(ownCreditLimit) / totalWidth) * 50);
  const collateralWidth = Math.floor((Number(collateral) / totalWidth) * 50);
  const rightCreditWidth = 50 - leftCreditWidth - collateralWidth;
  const deltaPosition = Math.floor(((Number(totalDelta) + Number(ownCreditLimit)) / totalWidth) * 50);

  // ASCII visualization - proper bar with position marker
  // Build the full capacity bar first
  const fullBar =
    '-'.repeat(leftCreditWidth) +
    '='.repeat(collateralWidth) +
    '-'.repeat(rightCreditWidth);

  // Insert position marker at deltaPosition
  const clampedPosition = Math.max(0, Math.min(deltaPosition, fullBar.length));
  const ascii =
    '[' +
    fullBar.substring(0, clampedPosition) +
    '|' +
    fullBar.substring(clampedPosition) +
    ']';

  return {
    delta: totalDelta,
    collateral,
    inCollateral,
    outCollateral,
    inOwnCredit,
    outPeerCredit,
    inAllowence,
    outAllowence,
    totalCapacity,
    ownCreditLimit,
    peerCreditLimit,
    inCapacity,
    outCapacity,
    outOwnCredit,
    inPeerCredit,
    ascii,
  };
}

/**
 * Create a simple delta for demo purposes
 * @param tokenId - Token ID
 * @param collateral - Collateral amount
 * @param delta - Delta amount
 * @returns Delta object with reasonable defaults
 */
export function createDemoDelta(tokenId: number, collateral: bigint = 1000n, delta: bigint = 0n): Delta {
  const creditLimit = getDefaultCreditLimit(tokenId);

  const deltaData = {
    tokenId,
    collateral,
    ondelta: delta,
    offdelta: 0n,
    leftCreditLimit: creditLimit,
    rightCreditLimit: creditLimit,
    leftAllowence: 0n,
    rightAllowence: 0n,
  };

  // VALIDATE AT SOURCE: Guarantee type safety from this point forward
  return validateDelta(deltaData, 'createDemoDelta');
}

/**
 * Get token information for display
 */
export const TOKEN_REGISTRY: Record<number, { symbol: string; name: string; decimals: number; color: string }> = {
  1: { symbol: 'ETH', name: 'Ethereum', decimals: 18, color: '#627eea' },
  2: { symbol: 'USDC', name: 'USD Coin', decimals: 18, color: '#2775ca' },
};

export function getTokenInfo(tokenId: number) {
  return TOKEN_REGISTRY[tokenId] || { 
    symbol: `TKN${tokenId}`, 
    name: `Token ${tokenId}`, 
    decimals: 18, 
    color: '#999' 
  };
}

/**
 * Default per-token credit limit scaled to token decimals (matches old channel behavior)
 */
export function getDefaultCreditLimit(tokenId: number): bigint {
  const tokenInfo = getTokenInfo(tokenId);
  const decimals = BigInt(tokenInfo.decimals ?? 18);
  return BASE_CREDIT_LIMIT * 10n ** decimals;
}

/**
 * Format amount for display with proper decimals
 */
// DEPRECATED: Use financial-utils.ts formatTokenAmount instead
// This is kept for backwards compatibility during migration
export { formatTokenAmount } from './financial-utils';

/**
 * Calculate percentage for capacity bar display
 */
// DEPRECATED: Use financial-utils.ts calculatePercentage instead
// This is kept for backwards compatibility during migration
export { calculatePercentage } from './financial-utils';

--- src/financial-utils.ts ---
/**
 * Financial utilities using ethers.js for proper BigInt handling
 * Single source of truth for all financial calculations and formatting
 */

import { formatUnits, parseUnits } from 'ethers';
import { getTokenInfo } from './account-utils';

/**
 * Format token amount for display using ethers formatUnits
 * Maintains full precision, uses established ETH ecosystem standards
 */
export function formatTokenAmount(tokenId: number, amount: bigint | null | undefined): string {
  // Handle null/undefined values that are causing ethers.js to crash
  if (amount === null || amount === undefined) {
    const tokenInfo = getTokenInfo(tokenId);
    return `0 ${tokenInfo.symbol}`;
  }

  const tokenInfo = getTokenInfo(tokenId);
  const formattedAmount = formatUnits(amount, tokenInfo.decimals);
  return `${formattedAmount} ${tokenInfo.symbol}`;
}

/**
 * Parse user input into token base units using ethers parseUnits
 * Converts human-readable amounts to BigInt base units
 */
export function parseTokenAmount(tokenId: number, humanAmount: string): bigint {
  const tokenInfo = getTokenInfo(tokenId);
  return parseUnits(humanAmount, tokenInfo.decimals);
}

/**
 * Convert between different token precisions while maintaining BigInt
 * Useful for cross-token calculations
 */
export function convertTokenPrecision(
  amount: bigint,
  fromDecimals: number,
  toDecimals: number
): bigint {
  if (fromDecimals === toDecimals) return amount;

  if (fromDecimals > toDecimals) {
    const divisor = 10n ** BigInt(fromDecimals - toDecimals);
    return amount / divisor;
  } else {
    const multiplier = 10n ** BigInt(toDecimals - fromDecimals);
    return amount * multiplier;
  }
}

/**
 * Calculate percentage for UI display (returns number for width calculations)
 * Only converts to number at the final display layer
 */
export function calculatePercentage(amount: bigint | null | undefined, total: bigint | null | undefined): number {
  // Handle null/undefined values
  if (amount === null || amount === undefined || total === null || total === undefined) return 0;
  if (total === 0n) return 0;
  // Use BigInt arithmetic until final conversion
  return Number((amount * 100n) / total);
}

/**
 * Format asset balance using ethers (for AssetBalance type)
 */
export function formatAssetAmount(balance: { amount: bigint | null | undefined; decimals: number; symbol: string }): string {
  // Handle null/undefined amounts
  if (balance.amount === null || balance.amount === undefined) {
    return `0 ${balance.symbol}`;
  }

  const formattedAmount = formatUnits(balance.amount, balance.decimals);
  return `${formattedAmount} ${balance.symbol}`;
}

/**
 * Safe BigInt arithmetic operations with overflow protection
 */
export const BigIntMath = {
  /**
   * Safe addition with null checking
   */
  add: (a: bigint | null | undefined, b: bigint | null | undefined): bigint => {
    const safeA = a ?? 0n;
    const safeB = b ?? 0n;
    return safeA + safeB;
  },

  /**
   * Safe subtraction with underflow check and null handling
   */
  subtract: (a: bigint | null | undefined, b: bigint | null | undefined): bigint => {
    const safeA = a ?? 0n;
    const safeB = b ?? 0n;
    if (safeB > safeA) throw new Error(`Underflow: ${safeA} - ${safeB}`);
    return safeA - safeB;
  },

  /**
   * Safe multiplication with null handling
   */
  multiply: (a: bigint | null | undefined, b: bigint | null | undefined): bigint => {
    const safeA = a ?? 0n;
    const safeB = b ?? 0n;
    return safeA * safeB;
  },

  /**
   * Safe division with remainder and null handling
   */
  divide: (dividend: bigint | null | undefined, divisor: bigint | null | undefined): { quotient: bigint; remainder: bigint } => {
    const safeDividend = dividend ?? 0n;
    const safeDivisor = divisor ?? 1n; // Avoid division by zero
    if (safeDivisor === 0n) throw new Error('Division by zero');
    return {
      quotient: safeDividend / safeDivisor,
      remainder: safeDividend % safeDivisor
    };
  },

  /**
   * Compare two BigInts with null handling
   */
  compare: (a: bigint | null | undefined, b: bigint | null | undefined): -1 | 0 | 1 => {
    const safeA = a ?? 0n;
    const safeB = b ?? 0n;
    if (safeA < safeB) return -1;
    if (safeA > safeB) return 1;
    return 0;
  },

  /**
   * Get absolute value with null handling
   */
  abs: (a: bigint | null | undefined): bigint => {
    const safeA = a ?? 0n;
    return safeA < 0n ? -safeA : safeA;
  },

  /**
   * Get minimum of two values with null handling
   */
  min: (a: bigint | null | undefined, b: bigint | null | undefined): bigint => {
    const safeA = a ?? 0n;
    const safeB = b ?? 0n;
    return safeA < safeB ? safeA : safeB;
  },

  /**
   * Get maximum of two values with null handling
   */
  max: (a: bigint | null | undefined, b: bigint | null | undefined): bigint => {
    const safeA = a ?? 0n;
    const safeB = b ?? 0n;
    return safeA > safeB ? safeA : safeB;
  },
};

/**
 * Financial constants in proper BigInt format
 */
export const FINANCIAL_CONSTANTS = {
  ZERO: 0n,
  ONE: 1n,
  WEI_PER_ETH: 10n ** 18n,
  USDC_DECIMALS: 6,
  ETH_DECIMALS: 18,
  DEFAULT_DECIMALS: 18,
} as const;

--- src/entity-consensus.ts ---
/**
 * XLN Entity Consensus and State Management
 * Core entity processing logic, consensus, proposals, and state transitions
 */

import { applyEntityTx } from './entity-tx';
import { ConsensusConfig, EntityInput, EntityReplica, EntityState, EntityTx, Env } from './types';
import { DEBUG, formatEntityDisplay, formatSignerDisplay, log } from './utils';
import { safeStringify } from './serialization-utils';

// === SECURITY VALIDATION ===

/**
 * Validates entity input to prevent malicious or corrupted data
 */
const validateEntityInput = (input: EntityInput): boolean => {
  try {
    // Basic required fields
    if (!input.entityId || typeof input.entityId !== 'string') {
      log.error(`❌ Invalid entityId: ${input.entityId}`);
      return false;
    }
    if (!input.signerId || typeof input.signerId !== 'string') {
      log.error(`❌ Invalid signerId: ${input.signerId}`);
      return false;
    }

    // EntityTx validation
    if (input.entityTxs) {
      if (!Array.isArray(input.entityTxs)) {
        log.error(`❌ EntityTxs must be array, got: ${typeof input.entityTxs}`);
        return false;
      }
      if (input.entityTxs.length > 1000) {
        log.error(`❌ Too many transactions: ${input.entityTxs.length} > 1000`);
        return false;
      }
      for (const tx of input.entityTxs) {
        if (!tx.type || !tx.data) {
          log.error(`❌ Invalid transaction: ${safeStringify(tx)}`);
          return false;
        }
        if (
          typeof tx.type !== 'string' ||
          !['chat', 'propose', 'vote', 'profile-update', 'j_event', 'accountInput', 'openAccount', 'directPayment'].includes(tx.type)
        ) {
          log.error(`❌ Invalid transaction type: ${tx.type}`);
          return false;
        }
      }
    }

    // Precommits validation
    if (input.precommits) {
      if (!(input.precommits instanceof Map)) {
        log.error(`❌ Precommits must be Map, got: ${typeof input.precommits}`);
        return false;
      }
      if (input.precommits.size > 100) {
        log.error(`❌ Too many precommits: ${input.precommits.size} > 100`);
        return false;
      }
      for (const [signerId, signature] of input.precommits) {
        if (typeof signerId !== 'string' || typeof signature !== 'string') {
          log.error(`❌ Invalid precommit format: ${signerId} -> ${signature}`);
          return false;
        }
      }
    }

    // ProposedFrame validation
    if (input.proposedFrame) {
      const frame = input.proposedFrame;
      if (typeof frame.height !== 'number' || frame.height < 0) {
        log.error(`❌ Invalid frame height: ${frame.height}`);
        return false;
      }
      if (!Array.isArray(frame.txs)) {
        log.error(`❌ Frame txs must be array`);
        return false;
      }
      if (!frame.hash || typeof frame.hash !== 'string') {
        log.error(`❌ Invalid frame hash: ${frame.hash}`);
        return false;
      }
    }

    return true;
  } catch (error) {
    log.error(`❌ Input validation error: ${error}`);
    return false;
  }
};

/**
 * Validates entity replica to prevent corrupted state
 */
const validateEntityReplica = (replica: EntityReplica): boolean => {
  try {
    if (!replica.entityId || !replica.signerId) {
      log.error(`❌ Invalid replica IDs: ${replica.entityId}:${replica.signerId}`);
      return false;
    }
    if (replica.state.height < 0) {
      log.error(`❌ Invalid state height: ${replica.state.height}`);
      return false;
    }
    if (replica.mempool.length > 10000) {
      log.error(`❌ Mempool overflow: ${replica.mempool.length} > 10000`);
      return false;
    }
    return true;
  } catch (error) {
    log.error(`❌ Replica validation error: ${error}`);
    return false;
  }
};

/**
 * Detects Byzantine faults like double-signing
 */
const detectByzantineFault = (signatures: Map<string, string>, signerId: string, newSignature: string): boolean => {
  try {
    const existingSig = signatures.get(signerId);
    if (existingSig && existingSig !== newSignature) {
      log.error(`❌ BYZANTINE FAULT: Double-sign detected from ${signerId}`);
      log.error(`❌ Existing: ${existingSig}`);
      log.error(`❌ New: ${newSignature}`);
      return true;
    }
    return false;
  } catch (error) {
    log.error(`❌ Byzantine detection error: ${error}`);
    return false;
  }
};

/**
 * Validates timestamp to prevent temporal attacks
 */
const validateTimestamp = (proposedTime: number, currentTime: number): boolean => {
  try {
    const maxDrift = 30000; // 30 seconds
    const drift = Math.abs(proposedTime - currentTime);
    if (drift > maxDrift) {
      log.error(`❌ Timestamp drift too large: ${drift}ms > ${maxDrift}ms`);
      log.error(`❌ Proposed: ${new Date(proposedTime).toISOString()}`);
      log.error(`❌ Current: ${new Date(currentTime).toISOString()}`);
      return false;
    }
    return true;
  } catch (error) {
    log.error(`❌ Timestamp validation error: ${error}`);
    return false;
  }
};

/**
 * Validates voting power to prevent overflow attacks
 */
const validateVotingPower = (power: bigint): boolean => {
  try {
    if (power < 0n) {
      log.error(`❌ Negative voting power: ${power}`);
      return false;
    }
    // Check for overflow (2^53 - 1 in bigint)
    if (power > BigInt(Number.MAX_SAFE_INTEGER)) {
      log.error(`❌ Voting power overflow: ${power} > ${Number.MAX_SAFE_INTEGER}`);
      return false;
    }
    return true;
  } catch (error) {
    log.error(`❌ Voting power validation error: ${error}`);
    return false;
  }
};

// === CORE ENTITY PROCESSING ===

/**
 * Main entity input processor - handles consensus, proposals, and state transitions
 */
export const applyEntityInput = async (
  env: Env,
  entityReplica: EntityReplica,
  entityInput: EntityInput,
): Promise<{ newState: EntityState, outputs: EntityInput[] }> => {
  // Debug: Log every input being processed with timestamp and unique identifier
  const entityDisplay = formatEntityDisplay(entityInput.entityId);
  const timestamp = Date.now();
  const currentProposalHash = entityReplica.proposal?.hash?.slice(0, 10) || 'none';
  const frameHash = entityInput.proposedFrame?.hash?.slice(0, 10) || 'none';

  console.log(
    `🔍 INPUT-RECEIVED: [${timestamp}] Processing input for Entity #${entityDisplay}:${formatSignerDisplay(entityInput.signerId)}`,
  );
  console.log(
    `🔍 INPUT-STATE: Current proposal: ${currentProposalHash}, Mempool: ${entityReplica.mempool.length}, isProposer: ${entityReplica.isProposer}`,
  );
  console.log(
    `🔍 INPUT-DETAILS: txs=${entityInput.entityTxs?.length || 0}, precommits=${entityInput.precommits?.size || 0}, frame=${frameHash}`,
  );
  if (entityInput.precommits?.size) {
    const precommitSigners = Array.from(entityInput.precommits.keys());
    console.log(`🔍 INPUT-PRECOMMITS: Received precommits from: ${precommitSigners.join(', ')}`);
    // Track exactly which proposal these precommits are for
    const firstPrecommit = entityInput.precommits.values().next().value;
    const proposalHashFromSig = firstPrecommit ? firstPrecommit.split('_')[2]?.slice(0, 10) : 'unknown';
    console.log(`🔍 PRECOMMIT-PROPOSAL: These precommits are for proposal: ${proposalHashFromSig}`);
  }

  // SECURITY: Validate all inputs
  if (!validateEntityInput(entityInput)) {
    log.error(`❌ Invalid input for ${entityInput.entityId}:${entityInput.signerId}`);
    return { newState: entityReplica.state, outputs: [] };
  }
  if (!validateEntityReplica(entityReplica)) {
    log.error(`❌ Invalid replica state for ${entityReplica.entityId}:${entityReplica.signerId}`);
    return { newState: entityReplica.state, outputs: [] };
  }

  const entityOutbox: EntityInput[] = [];

  // Add transactions to mempool (mutable for performance)
  if (entityInput.entityTxs?.length) {
    // DEBUG: Track vote transactions specifically
    const voteTransactions = entityInput.entityTxs.filter(tx => tx.type === 'vote');
    if (voteTransactions.length > 0) {
      console.log(`🗳️ VOTE-MEMPOOL: ${entityReplica.signerId} receiving ${voteTransactions.length} vote transactions`);
      voteTransactions.forEach(tx => {
        console.log(`🗳️ VOTE-TX:`, tx);
      });
    }

    if (entityReplica.signerId === 'alice') {
      console.log(`🔥 ALICE-RECEIVES: Alice receiving ${entityInput.entityTxs.length} txs from input`);
      console.log(
        `🔥 ALICE-RECEIVES: Transaction types:`,
        entityInput.entityTxs.map(tx => tx.type),
      );
      console.log(
        `🔥 ALICE-RECEIVES: Alice isProposer=${entityReplica.isProposer}, current mempool=${entityReplica.mempool.length}`,
      );
    }
    // Log details of each EntityTx
    for (const tx of entityInput.entityTxs) {
      console.log(`🏛️ E-MACHINE: - EntityTx type="${tx.type}", data=`, safeStringify(tx.data, 2));
    }
    entityReplica.mempool.push(...entityInput.entityTxs);
    if (DEBUG)
      console.log(
        `    → Added ${entityInput.entityTxs.length} txs to mempool (total: ${entityReplica.mempool.length})`,
      );
    if (DEBUG && entityInput.entityTxs.length > 3) {
      console.log(`    ⚠️  CORNER CASE: Large batch of ${entityInput.entityTxs.length} transactions`);
    }
  } else if (entityInput.entityTxs && entityInput.entityTxs.length === 0) {
    if (DEBUG) console.log(`    ⚠️  CORNER CASE: Empty transaction array received - no mempool changes`);
  }

  // CRITICAL: Forward transactions to proposer BEFORE processing commits
  // This prevents race condition where commits clear mempool before forwarding
  if (!entityReplica.isProposer && entityReplica.mempool.length > 0) {
    if (DEBUG) console.log(`    → Non-proposer sending ${entityReplica.mempool.length} txs to proposer`);
    // Send mempool to proposer
    const proposerId = entityReplica.state.config.validators[0];
    if (!proposerId) {
      console.error(`❌ No proposer found in validators: ${entityReplica.state.config.validators}`);
      return { newState: entityReplica.state, outputs: entityOutbox };
    }
    console.log(`🔥 BOB-TO-ALICE: Bob sending ${entityReplica.mempool.length} txs to proposer ${proposerId}`);
    console.log(
      `🔥 BOB-TO-ALICE: Transaction types:`,
      entityReplica.mempool.map(tx => tx.type),
    );
    entityOutbox.push({
      entityId: entityInput.entityId,
      signerId: proposerId,
      entityTxs: [...entityReplica.mempool],
    });
    // Clear mempool after sending
    entityReplica.mempool.length = 0;
  }

  // Handle commit notifications AFTER forwarding (when receiving finalized frame from proposer)
  if (entityInput.precommits?.size && entityInput.proposedFrame && !entityReplica.proposal) {
    const signers = Array.from(entityInput.precommits.keys());
    const totalPower = calculateQuorumPower(entityReplica.state.config, signers);

    if (totalPower >= entityReplica.state.config.threshold) {
      // This is a commit notification from proposer, apply the frame
      if (DEBUG) console.log(`    → Received commit notification with ${entityInput.precommits.size} signatures`);

      // Apply the committed frame with incremented height
      entityReplica.state = {
        ...entityInput.proposedFrame.newState,
        height: entityReplica.state.height + 1,
      };
      entityReplica.mempool.length = 0;
      delete entityReplica.lockedFrame; // Release lock after commit
      if (DEBUG)
        console.log(
          `    → Applied commit, new state: ${entityReplica.state.messages.length} messages, height: ${entityReplica.state.height}`,
        );

      // Return early - commit notifications don't trigger further processing
      return { newState: entityReplica.state, outputs: entityOutbox };
    }
  }

  // Handle proposed frame (PROPOSE phase) - only if not a commit notification
  if (
    entityInput.proposedFrame &&
    (!entityReplica.proposal || (entityReplica.state.config.mode === 'gossip-based' && entityReplica.isProposer))
  ) {
    const frameSignature = `sig_${entityReplica.signerId}_${entityInput.proposedFrame.hash}`;
    const config = entityReplica.state.config;

    // Lock to this frame (CometBFT style)
    entityReplica.lockedFrame = entityInput.proposedFrame;
    if (DEBUG) console.log(`    → Validator locked to frame ${entityInput.proposedFrame.hash.slice(0, 10)}...`);

    if (config.mode === 'gossip-based') {
      // Send precommit to all validators
      config.validators.forEach(validatorId => {
        console.log(
          `🔍 GOSSIP: [${timestamp}] ${entityReplica.signerId} sending precommit to ${validatorId} for entity ${entityInput.entityId.slice(0, 10)}, proposal ${frameHash}, sig: ${frameSignature.slice(0, 20)}...`,
        );
        entityOutbox.push({
          entityId: entityInput.entityId,
          signerId: validatorId,
          precommits: new Map([[entityReplica.signerId, frameSignature]]),
        });
      });
      if (DEBUG) console.log(`    → Signed proposal, gossiping precommit to ${config.validators.length} validators`);
    } else {
      // Send precommit to proposer only
      const proposerId = config.validators[0];
      if (!proposerId) {
        console.error(`❌ No proposer found in validators: ${config.validators}`);
        return { newState: entityReplica.state, outputs: entityOutbox };
      }
      console.log(
        `🔍 PROPOSER: [${timestamp}] ${entityReplica.signerId} sending precommit to ${proposerId} for entity ${entityInput.entityId.slice(0, 10)}, proposal ${frameHash}, sig: ${frameSignature.slice(0, 20)}...`,
      );
      console.log(
        `🔍 PROPOSER-REASON: Signed new proposal, current state: proposal=${currentProposalHash}, locked=${entityReplica.lockedFrame?.hash?.slice(0, 10) || 'none'}`,
      );
      entityOutbox.push({
        entityId: entityInput.entityId,
        signerId: proposerId,
        precommits: new Map([[entityReplica.signerId, frameSignature]]),
      });
      if (DEBUG) console.log(`    → Signed proposal, sending precommit to ${proposerId}`);
    }
  }

  // Handle precommits (SIGN phase)
  if (entityInput.precommits?.size && entityReplica.proposal) {
    // SECURITY: Check for Byzantine faults before collecting signatures
    for (const [signerId, signature] of entityInput.precommits) {
      if (detectByzantineFault(entityReplica.proposal.signatures, signerId, signature)) {
        log.error(`❌ Rejecting Byzantine input from ${signerId}`);
        return { newState: entityReplica.state, outputs: entityOutbox }; // Return early, don't process malicious input
      }
      entityReplica.proposal.signatures.set(signerId, signature);
    }
    if (DEBUG)
      console.log(
        `    → Collected ${entityInput.precommits.size} signatures (total: ${entityReplica.proposal.signatures.size})`,
      );

    // Check threshold using shares
    const signers = Array.from(entityReplica.proposal.signatures.keys());
    const totalPower = calculateQuorumPower(entityReplica.state.config, signers);

    // SECURITY: Validate voting power
    if (!validateVotingPower(totalPower)) {
      log.error(`❌ Invalid voting power calculation: ${totalPower}`);
      return { newState: entityReplica.state, outputs: entityOutbox };
    }

    if (DEBUG) {
      const totalShares = Object.values(entityReplica.state.config.shares).reduce((sum, val) => sum + val, BigInt(0));
      const percentage = ((Number(totalPower) / Number(entityReplica.state.config.threshold)) * 100).toFixed(1);
      log.info(
        `    🔍 Threshold check: ${totalPower} / ${totalShares} [${percentage}% threshold${Number(totalPower) >= Number(entityReplica.state.config.threshold) ? '+' : ''}]`,
      );
      if (entityReplica.state.config.mode === 'gossip-based') {
        console.log(`    ⚠️  CORNER CASE: Gossip mode - all validators receive precommits`);
      }
    }

    if (totalPower >= entityReplica.state.config.threshold) {
      // Commit phase - use pre-computed state with incremented height
      entityReplica.state = {
        ...entityReplica.proposal.newState,
        height: entityReplica.state.height + 1,
      };
      if (DEBUG) console.log(`    → Threshold reached! Committing frame, height: ${entityReplica.state.height}`);

      // Save proposal data before clearing
      const sortedSignatures = sortSignatures(entityReplica.proposal.signatures, entityReplica.state.config);
      const committedFrame = entityReplica.proposal;

      // Clear state (mutable)
      entityReplica.mempool.length = 0;
      delete entityReplica.proposal;
      delete entityReplica.lockedFrame; // Release lock after commit

      // Only send commit notifications in proposer-based mode
      // In gossip mode, everyone already has all precommits via gossip
      if (entityReplica.state.config.mode === 'proposer-based') {
        const committedProposalHash = committedFrame.hash.slice(0, 10);
        console.log(
          `🔍 COMMIT-START: [${timestamp}] ${entityReplica.signerId} reached threshold for proposal ${committedProposalHash}, sending commit notifications...`,
        );

        // Notify all validators (except self - proposer already has all precommits)
        entityReplica.state.config.validators.forEach(validatorId => {
          if (validatorId !== entityReplica.signerId) {
            const precommitSigners = Array.from(sortedSignatures.keys());
            console.log(
              `🔍 COMMIT: [${timestamp}] ${entityReplica.signerId} sending commit notification to ${validatorId} for entity ${entityInput.entityId.slice(0, 10)}, proposal ${committedProposalHash} (${sortedSignatures.size} precommits from: ${precommitSigners.join(', ')})`,
            );
            entityOutbox.push({
              entityId: entityInput.entityId,
              signerId: validatorId,
              precommits: sortedSignatures,
              proposedFrame: committedFrame,
            });
          }
        });
        const notifiedCount = entityReplica.state.config.validators.length - 1; // excluding self
        if (DEBUG) console.log(`    → Sending commit notifications to ${notifiedCount} validators (excluding self)`);
      } else {
        console.log(
          `🔍 GOSSIP-COMMIT: [${timestamp}] ${entityReplica.signerId} NOT sending commit notifications (gossip mode) for entity ${entityInput.entityId.slice(0, 10)}...`,
        );
        if (DEBUG)
          console.log(`    → Gossip mode: No commit notifications needed (everyone has precommits via gossip)`);
      }
    }
  }

  // Commit notifications are now handled at the top of the function

  // Debug consensus trigger conditions
  console.log(`🎯 CONSENSUS-CHECK: Entity ${entityReplica.entityId}:${entityReplica.signerId}`);
  console.log(`🎯   isProposer: ${entityReplica.isProposer}`);
  console.log(`🎯   mempool.length: ${entityReplica.mempool.length}`);
  console.log(`🎯   hasProposal: ${!!entityReplica.proposal}`);
  if (entityReplica.mempool.length > 0) {
    console.log(
      `🎯   mempoolTypes:`,
      entityReplica.mempool.map(tx => tx.type),
    );
  }

  // Auto-propose logic: ONLY proposer can propose (BFT requirement)
  if (entityReplica.isProposer && entityReplica.mempool.length > 0 && !entityReplica.proposal) {
    console.log(`🔥 ALICE-PROPOSES: Alice auto-propose triggered!`);
    console.log(
      `🔥 ALICE-PROPOSES: mempool=${entityReplica.mempool.length}, isProposer=${entityReplica.isProposer}, hasProposal=${!!entityReplica.proposal}`,
    );
    console.log(
      `🔥 ALICE-PROPOSES: Mempool transaction types:`,
      entityReplica.mempool.map(tx => tx.type),
    );

    // Check if this is a single signer entity (threshold = 1, only 1 validator)
    const isSingleSigner =
      entityReplica.state.config.validators.length === 1 && entityReplica.state.config.threshold === BigInt(1);

    if (isSingleSigner) {
      console.log(`🚀 SINGLE-SIGNER: Direct execution without consensus for single signer entity`);
      // For single signer entities, directly apply transactions without consensus
      const { newState: newEntityState, outputs: frameOutputs } = await applyEntityFrame(env, entityReplica.state, entityReplica.mempool);
      entityReplica.state = {
        ...newEntityState,
        height: entityReplica.state.height + 1,
      };

      // Add any outputs generated by entity transactions to the outbox
      entityOutbox.push(...frameOutputs);
      console.log(`🔍 SINGLE-SIGNER-OUTPUTS: Collected ${frameOutputs.length} outputs from applyEntityFrame, total entityOutbox: ${entityOutbox.length}`);

      // Clear mempool after direct application
      entityReplica.mempool.length = 0;

      if (DEBUG)
        console.log(
          `    ⚡ Single signer entity: transactions applied directly, height: ${entityReplica.state.height}`,
        );
      console.log(`🔍 SINGLE-SIGNER-RETURN: Returning ${entityOutbox.length} outputs`);
      return { newState: entityReplica.state, outputs: entityOutbox }; // Skip the full consensus process
    }

    if (DEBUG)
      console.log(
        `    🚀 Auto-propose triggered: mempool=${entityReplica.mempool.length}, isProposer=${entityReplica.isProposer}, hasProposal=${!!entityReplica.proposal}`,
      );
    // Compute new state once during proposal
    const { newState: newEntityState, outputs: proposalOutputs } = await applyEntityFrame(env, entityReplica.state, entityReplica.mempool);

    // Add any outputs generated during proposal to the outbox
    entityOutbox.push(...proposalOutputs);

    // Proposer creates new timestamp for this frame (always use current time for new proposals)
    const newTimestamp = Date.now();

    // SECURITY: Validate timestamp
    if (!validateTimestamp(newTimestamp, Date.now())) {
      log.error(`❌ Invalid proposal timestamp: ${newTimestamp}`);
      return { newState: entityReplica.state, outputs: entityOutbox };
    }

    const frameHash = `frame_${entityReplica.state.height + 1}_${newTimestamp}`;
    const selfSignature = `sig_${entityReplica.signerId}_${frameHash}`;

    entityReplica.proposal = {
      height: entityReplica.state.height + 1,
      txs: [...entityReplica.mempool],
      hash: frameHash,
      newState: {
        ...newEntityState,
        height: entityReplica.state.height + 1,
        timestamp: newTimestamp, // Set new deterministic timestamp in proposed state
      },
      signatures: new Map<string, string>([[entityReplica.signerId, selfSignature]]), // Proposer signs immediately
    };

    if (DEBUG)
      console.log(
        `    → Auto-proposing frame ${entityReplica.proposal.hash} with ${entityReplica.proposal.txs.length} txs and self-signature.`,
      );

    // Send proposal to all validators (except self)
    entityReplica.state.config.validators.forEach(validatorId => {
      if (validatorId !== entityReplica.signerId) {
        entityOutbox.push({
          entityId: entityInput.entityId,
          signerId: validatorId,
          proposedFrame: entityReplica.proposal!,
          // Note: Don't send entityTxs separately - they're already in proposedFrame.txs
        });
      }
    });
  } else if (entityReplica.isProposer && entityReplica.mempool.length === 0 && !entityReplica.proposal) {
    if (DEBUG) console.log(`    ⚠️  CORNER CASE: Proposer with empty mempool - no auto-propose`);
  } else if (!entityReplica.isProposer && entityReplica.mempool.length > 0) {
    if (DEBUG) console.log(`    → Non-proposer sending ${entityReplica.mempool.length} txs to proposer`);
    // Send mempool to proposer
    const proposerId = entityReplica.state.config.validators[0];
    if (!proposerId) {
      console.error(`❌ No proposer found in validators: ${entityReplica.state.config.validators}`);
      return { newState: entityReplica.state, outputs: entityOutbox };
    }
    console.log(`🔥 BOB-TO-ALICE: Bob sending ${entityReplica.mempool.length} txs to proposer ${proposerId}`);
    console.log(
      `🔥 BOB-TO-ALICE: Transaction types:`,
      entityReplica.mempool.map(tx => tx.type),
    );
    entityOutbox.push({
      entityId: entityInput.entityId,
      signerId: proposerId,
      entityTxs: [...entityReplica.mempool],
    });
    // Clear mempool after sending
    entityReplica.mempool.length = 0;
  } else if (entityReplica.isProposer && entityReplica.proposal) {
    if (DEBUG) console.log(`    ⚠️  CORNER CASE: Proposer already has pending proposal - no new auto-propose`);
  }

  // Debug: Log outputs being generated with detailed analysis
  console.log(
    `🔍 OUTPUT-GENERATED: [${timestamp}] Entity #${entityDisplay}:${formatSignerDisplay(entityReplica.signerId)} generating ${entityOutbox.length} outputs`,
  );
  console.log(
    `🔍 OUTPUT-FINAL-STATE: proposal=${entityReplica.proposal?.hash?.slice(0, 10) || 'none'}, mempool=${entityReplica.mempool.length}, locked=${entityReplica.lockedFrame?.hash?.slice(0, 10) || 'none'}`,
  );

  entityOutbox.forEach((output, index) => {
    const targetDisplay = formatEntityDisplay(output.entityId);
    const outputFrameHash = output.proposedFrame?.hash?.slice(0, 10) || 'none';
    console.log(
      `🔍 OUTPUT-${index + 1}: [${timestamp}] To Entity #${targetDisplay}:${formatSignerDisplay(output.signerId)} - txs=${output.entityTxs?.length || 0}, precommits=${output.precommits?.size || 0}, frame=${outputFrameHash}`,
    );

    if (output.precommits?.size) {
      const precommitSigners = Array.from(output.precommits.keys());
      console.log(`🔍 OUTPUT-${index + 1}-PRECOMMITS: Sending precommits from: ${precommitSigners.join(', ')}`);

      // Show the actual signature content to track duplicates
      output.precommits.forEach((sig, signer) => {
        const sigShort = sig.slice(0, 20);
        const proposalFromSig = sig.split('_')[2]?.slice(0, 10) || 'unknown';
        console.log(`🔍 OUTPUT-${index + 1}-SIG-DETAIL: ${signer} -> ${sigShort}... (proposal: ${proposalFromSig})`);
      });
    }

    // Classify output type for clarity
    if (output.proposedFrame && output.precommits?.size) {
      console.log(`🔍 OUTPUT-${index + 1}-TYPE: COMMIT_NOTIFICATION (frame + precommits)`);
    } else if (output.precommits?.size) {
      console.log(`🔍 OUTPUT-${index + 1}-TYPE: PRECOMMIT_VOTE (precommits only)`);
    } else if (output.proposedFrame) {
      console.log(`🔍 OUTPUT-${index + 1}-TYPE: PROPOSAL (frame only)`);
    } else if (output.entityTxs?.length) {
      console.log(`🔍 OUTPUT-${index + 1}-TYPE: TRANSACTION_FORWARD (txs only)`);
    } else {
      console.log(`🔍 OUTPUT-${index + 1}-TYPE: UNKNOWN (empty output)`);
    }
  });

  return { newState: entityReplica.state, outputs: entityOutbox };
};

export const applyEntityFrame = async (
  env: Env,
  entityState: EntityState,
  entityTxs: EntityTx[],
): Promise<{ newState: EntityState, outputs: EntityInput[] }> => {
  console.log(`🎯 APPLY-ENTITY-FRAME: Processing ${entityTxs.length} transactions`);
  entityTxs.forEach((tx, index) => {
    console.log(`🎯 Transaction ${index}: type="${tx.type}", data=`, tx.data);
  });

  let currentEntityState = entityState;
  const allOutputs: EntityInput[] = [];

  // Track accounts that need frame proposals during this processing round
  const proposableAccounts = new Set<string>();

  for (const entityTx of entityTxs) {
    const { newState, outputs } = await applyEntityTx(env, currentEntityState, entityTx);
    currentEntityState = newState;
    allOutputs.push(...outputs);

    // Track which accounts need proposals based on transaction type
    if (entityTx.type === 'accountInput' && entityTx.data) {
      const fromEntity = entityTx.data.fromEntityId;
      const accountMachine = currentEntityState.accounts.get(fromEntity);

      if (accountMachine) {
        // Add to proposable if:
        // 1. Received a NEW frame that needs ACK (newAccountFrame)
        // 2. Received an ACK (frameId with prevSignatures) AND we have mempool items
        // 3. Received account transactions that need processing
        const isNewFrame = entityTx.data.newAccountFrame;
        const isAck = entityTx.data.frameId && entityTx.data.prevSignatures;
        const hasAccountTx = entityTx.data.accountTx;
        const hasPendingTxs = accountMachine.mempool.length > 0;

        // Only propose if we have something to send:
        // - Need to ACK a new frame
        // - Have transactions in mempool
        // - Received account transactions to process
        if (isNewFrame || (hasPendingTxs && !accountMachine.pendingFrame) || hasAccountTx) {
          proposableAccounts.add(fromEntity);
          console.log(`🔄 Added ${fromEntity.slice(0,10)} to proposable - NewFrame:${isNewFrame}, AccTx:${hasAccountTx}, Pending:${hasPendingTxs}`);
        } else if (isAck) {
          console.log(`✅ Received ACK from ${fromEntity.slice(0,10)}, no action needed (mempool empty)`);
        }
      }
    } else if (entityTx.type === 'directPayment' && entityTx.data) {
      console.log(`🔍 DIRECT-PAYMENT detected in applyEntityFrame`);
      console.log(`🔍 Payment data:`, {
        targetEntityId: entityTx.data.targetEntityId,
        route: entityTx.data.route,
        amount: entityTx.data.amount
      });
      console.log(`🔍 Current entity has ${currentEntityState.accounts.size} accounts`);

      // Payment was added to mempool in applyEntityTx
      // We need to find which account got the payment and mark it for frame proposal

      // Check all accounts to see which one has new mempool items
      for (const [counterpartyId, accountMachine] of currentEntityState.accounts) {
        const isLeft = accountMachine.proofHeader.fromEntity < accountMachine.proofHeader.toEntity;
        console.log(`🔍 Checking account ${counterpartyId.slice(0,10)}: mempool=${accountMachine.mempool.length}, isLeft=${isLeft}, pendingFrame=${!!accountMachine.pendingFrame}`);
        if (accountMachine.mempool.length > 0) {
          proposableAccounts.add(counterpartyId);
          console.log(`🔄 ✅ Added ${counterpartyId.slice(0,10)} to proposableAccounts (has ${accountMachine.mempool.length} mempool items)`);
        }
      }
    } else if (entityTx.type === 'openAccount' && entityTx.data) {
      // Account opened - may need initial frame
      const targetEntity = entityTx.data.targetEntityId;
      const accountMachine = currentEntityState.accounts.get(targetEntity);
      if (accountMachine) {
        const isLeft = accountMachine.proofHeader.fromEntity < accountMachine.proofHeader.toEntity;
        if (isLeft) {
          proposableAccounts.add(targetEntity);
          console.log(`🔄 Added ${targetEntity.slice(0,10)} to proposable (new account opened)`);
        }
      }
    }
  }

  // AUTO-PROPOSE: Process all proposable accounts plus any with pending transactions
  console.log(`🚀 AUTO-PROPOSE: Starting bilateral consensus check`);
  console.log(`🚀 Proposable accounts so far: ${Array.from(proposableAccounts).join(', ') || 'none'}`);

  const { getAccountsToProposeFrames, proposeAccountFrame } = await import('./account-consensus');

  // Add accounts with mempool items that weren't already added
  const additionalAccounts = getAccountsToProposeFrames(currentEntityState);
  console.log(`🚀 Additional accounts from getAccountsToProposeFrames: ${additionalAccounts.join(', ') || 'none'}`);
  additionalAccounts.forEach(accountId => proposableAccounts.add(accountId));

  // Convert Set to Array for processing
  const accountsToProposeFrames = Array.from(proposableAccounts);

  if (accountsToProposeFrames.length > 0) {
    console.log(`🔄 AUTO-PROPOSE: ${accountsToProposeFrames.length} accounts need frame proposals`);
    console.log(`🔄 AUTO-PROPOSE: Accounts to propose: ${accountsToProposeFrames.map(id => id.slice(0,10)).join(', ')}`);

    for (const counterpartyEntityId of accountsToProposeFrames) {
      console.log(`🔄 AUTO-PROPOSE: Processing account ${counterpartyEntityId.slice(0,10)}...`);

      const accountMachine = currentEntityState.accounts.get(counterpartyEntityId);
      if (accountMachine) {
        console.log(`🔄 AUTO-PROPOSE: Account details - mempool=${accountMachine.mempool.length}, pendingFrame=${!!accountMachine.pendingFrame}`);
        const proposal = await proposeAccountFrame(accountMachine);
        console.log(`🔄 AUTO-PROPOSE: Proposal result - success=${proposal.success}, hasInput=${!!proposal.accountInput}, error=${proposal.error || 'none'}`);

        if (proposal.success && proposal.accountInput) {
          // Get the proposer of the target entity from env
          let targetProposerId = 'alice'; // Default fallback
          const targetReplicaKeys = Array.from(env.replicas.keys()).filter(key => key.startsWith(proposal.accountInput!.toEntityId + ':'));
          if (targetReplicaKeys.length > 0) {
            const firstTargetReplica = env.replicas.get(targetReplicaKeys[0]!);
            const firstValidator = firstTargetReplica?.state.config.validators[0];
            if (firstValidator) {
              targetProposerId = firstValidator;
            }
          }

          // Convert AccountInput to EntityInput for routing
          const outputEntityInput: EntityInput = {
            entityId: proposal.accountInput.toEntityId,
            signerId: targetProposerId, // Route to target entity's proposer
            entityTxs: [{
              type: 'accountInput' as const,
              data: proposal.accountInput
            }]
          };
          console.log(`📤 ROUTING-DEBUG: Creating EntityInput output - FULL entityId="${outputEntityInput.entityId}", signerId="${outputEntityInput.signerId}"`);
          console.log(`📤 ROUTING-DEBUG: Expected replica key should be: "${outputEntityInput.entityId}:${outputEntityInput.signerId}"`);
          allOutputs.push(outputEntityInput);

          // Add events to entity messages
          currentEntityState.messages.push(...proposal.events);
        }
      }
    }
  }

  return { newState: currentEntityState, outputs: allOutputs };
};

// === HELPER FUNCTIONS ===

/**
 * Calculate quorum power based on validator shares
 */
export const calculateQuorumPower = (config: ConsensusConfig, signers: string[]): bigint => {
  return signers.reduce((total, signerId) => {
    const shares = config.shares[signerId];
    if (shares === undefined) {
      throw new Error(`CONSENSUS-SAFETY: Unknown validator ${signerId} - cannot calculate quorum power`);
    }
    return total + shares;
  }, 0n);
};

export const sortSignatures = (signatures: Map<string, string>, config: ConsensusConfig): Map<string, string> => {
  const sortedEntries = Array.from(signatures.entries()).sort(([a], [b]) => {
    const indexA = config.validators.indexOf(a);
    const indexB = config.validators.indexOf(b);
    return indexA - indexB;
  });
  return new Map(sortedEntries);
};

// === ENTITY UTILITIES (existing) ===

/**
 * Merges duplicate entity inputs to reduce processing overhead
 */
export const mergeEntityInputs = (inputs: EntityInput[]): EntityInput[] => {
  const merged = new Map<string, EntityInput>();
  let duplicateCount = 0;
  const timestamp = Date.now();

  // Always log input count for debugging with detailed breakdown
  console.log(`🔍 MERGE-START: [${timestamp}] Processing ${inputs.length} entity inputs for merging`);

  // Log FULL entityIds for routing debugging
  inputs.forEach((input, idx) => {
    console.log(`🔍 MERGE-INPUT[${idx}]: FULL entityId="${input.entityId}", signerId="${input.signerId}", replicaKey="${input.entityId}:${input.signerId}"`);
  });

  // Pre-analysis: Show all inputs before merging to identify potential Carol duplicates
  const inputAnalysis = inputs.map((input, i) => {
    const entityShort = input.entityId.slice(0, 10);
    const frameHash = input.proposedFrame?.hash?.slice(0, 10) || 'none';
    const precommitCount = input.precommits?.size || 0;
    const precommitSigners = input.precommits ? Array.from(input.precommits.keys()).join(',') : 'none';
    return `${i + 1}:${entityShort}:${input.signerId}(txs=${input.entityTxs?.length || 0},pc=${precommitCount}[${precommitSigners}],f=${frameHash})`;
  });
  console.log(`🔍 MERGE-INPUTS: ${inputAnalysis.join(' | ')}`);

  // Look for potential Carol duplicates specifically
  const carolInputs = inputs.filter(input => input.signerId.includes('carol'));
  if (carolInputs.length > 1) {
    console.log(`🔍 MERGE-CAROL-ALERT: Found ${carolInputs.length} inputs from Carol - potential duplicate source!`);
    carolInputs.forEach((input, i) => {
      const entityShort = input.entityId.slice(0, 10);
      const precommitSigners = input.precommits ? Array.from(input.precommits.keys()).join(',') : 'none';
      console.log(`🔍 MERGE-CAROL-${i + 1}: ${entityShort}:${input.signerId} - precommits: ${precommitSigners}`);
    });
  }

  for (const input of inputs) {
    const key = `${input.entityId}:${input.signerId}`;
    const entityShort = input.entityId.slice(0, 10);

    if (merged.has(key)) {
      const existing = merged.get(key)!;
      duplicateCount++;

      console.log(`🔍 DUPLICATE-FOUND: Merging duplicate input ${duplicateCount} for ${entityShort}:${input.signerId}`);

      // Merge entity transactions
      if (input.entityTxs) {
        existing.entityTxs = [...(existing.entityTxs || []), ...input.entityTxs];
        console.log(`🔍 MERGE-TXS: Added ${input.entityTxs.length} transactions`);
      }

      // Merge precommits
      if (input.precommits) {
        const existingPrecommits = existing.precommits || new Map();
        console.log(
          `🔍 MERGE-PRECOMMITS: Merging ${input.precommits.size} precommits into existing ${existingPrecommits.size} for ${entityShort}:${input.signerId}`,
        );
        input.precommits.forEach((signature, signerId) => {
          console.log(`🔍 MERGE-DETAIL: Adding precommit from ${signerId} (sig: ${signature.slice(0, 20)}...)`);
          existingPrecommits.set(signerId, signature);
        });
        existing.precommits = existingPrecommits;
        console.log(`🔍 MERGE-RESULT: Total ${existingPrecommits.size} precommits after merge`);
      }

      // Keep the latest frame (simplified)
      if (input.proposedFrame) existing.proposedFrame = input.proposedFrame;

      console.log(
        `    🔄 Merging inputs for ${key}: txs=${input.entityTxs?.length || 0}, precommits=${input.precommits?.size || 0}, frame=${!!input.proposedFrame}`,
      );
    } else {
      merged.set(key, { ...input });
    }
  }

  if (duplicateCount > 0) {
    console.log(`    ⚠️  CORNER CASE: Merged ${duplicateCount} duplicate inputs (${inputs.length} → ${merged.size})`);
  }

  return Array.from(merged.values());
};

/**
 * Gets entity state summary for debugging
 */
export const getEntityStateSummary = (replica: EntityReplica): string => {
  const hasProposal = replica.proposal ? '✓' : '✗';
  return `mempool=${replica.mempool.length}, messages=${replica.state.messages.length}, proposal=${hasProposal}`;
};

/**
 * Checks if entity should auto-propose (simplified version)
 */
export const shouldAutoPropose = (replica: EntityReplica, _config: ConsensusConfig): boolean => {
  const hasMempool = replica.mempool.length > 0;
  const isProposer = replica.isProposer;
  const hasProposal = replica.proposal !== undefined;

  return hasMempool && isProposer && !hasProposal;
};

/**
 * Processes empty transaction arrays (corner case)
 */
export const handleEmptyTransactions = (): void => {
  console.log(`    ⚠️  CORNER CASE: Empty transaction array received - no mempool changes`);
};

/**
 * Logs large transaction batches (corner case)
 */
export const handleLargeBatch = (txCount: number): void => {
  if (txCount >= 8) {
    console.log(`    ⚠️  CORNER CASE: Large batch of ${txCount} transactions`);
  }
};

/**
 * Handles gossip mode precommit distribution
 */
export const handleGossipMode = (): void => {
  console.log(`    ⚠️  CORNER CASE: Gossip mode - all validators receive precommits`);
};

/**
 * Logs proposer with empty mempool corner case
 */
export const handleEmptyMempoolProposer = (): void => {
  console.log(`    ⚠️  CORNER CASE: Proposer with empty mempool - no auto-propose`);
};

--- src/gossip.ts ---
/**
 * Gossip Layer Implementation for XLN
 *
 * This module implements the gossip layer inside the server object.
 * It manages entity profiles and their capabilities in a distributed network.
 */

export type Profile = {
  entityId: string;
  capabilities: string[]; // e.g. ["router", "swap:memecoins"]
  hubs: string[]; // entityIds of hubs this entity is connected to
  metadata?: {
    // Consensus profile fields (from name-resolution.ts)
    name?: string;
    avatar?: string;
    bio?: string;
    website?: string;
    lastUpdated?: number;
    hankoSignature?: string;
    // Network-specific fields
    region?: string;
    version?: string;
    capacity?: number;
    uptime?: string;
    isHub?: boolean;
    // Fee configuration (PPM = parts per million)
    routingFeePPM?: number; // 0-10000 (0% - 1%)
    baseFee?: bigint; // Base fee in smallest unit (e.g., wei for ETH)
    // Additional fields
    [key: string]: unknown;
  };
  // Account capacities for routing
  accounts?: Array<{
    counterpartyId: string;
    tokenCapacities: Map<number, {
      inCapacity: bigint;
      outCapacity: bigint;
    }>;
  }>;
};

export interface GossipLayer {
  profiles: Map<string, Profile>;
  announce: (profile: Profile) => void;
  getProfiles: () => Profile[];
}

export function createGossipLayer(): GossipLayer {
  const profiles = new Map<string, Profile>();

  const announce = (profile: Profile): void => {
    // Only update if newer timestamp or no existing profile
    const existing = profiles.get(profile.entityId);
    const newTimestamp = profile.metadata?.lastUpdated || 0;
    const existingTimestamp = existing?.metadata?.lastUpdated || 0;

    if (!existing || newTimestamp > existingTimestamp) {
      profiles.set(profile.entityId, profile);
      console.log(`📡 Gossip updated for ${profile.entityId} (timestamp: ${newTimestamp})`);
    } else {
      console.log(`📡 Gossip ignored older update for ${profile.entityId} (${newTimestamp} <= ${existingTimestamp})`);
    }
  };

  const getProfiles = (): Profile[] => {
    return Array.from(profiles.values());
  };

  return {
    profiles,
    announce,
    getProfiles,
  };
}

// Demo usage (commented out)
/*
const gossipLayer = createGossipLayer();

// Announce Alice's profile
gossipLayer.announce({
  entityId: "alice",
  capabilities: ["trader", "swap:memecoins"],
  hubs: ["hubX1"],
  metadata: { region: "US", version: "1.0.0" }
});

// Announce hubX1's profile
gossipLayer.announce({
  entityId: "hubX1",
  capabilities: ["router", "hub", "swap:all"],
  hubs: [],
  metadata: { capacity: 1000, uptime: "99.9%" }
});

// List all profiles
console.log("All profiles:", gossipLayer.getProfiles());
*/

--- src/rundemo.ts ---
/**
 * XLN Demo Runner (J-MOCKED VERSION)
 * Sets up a clean environment with two single-signer entities and demonstrates a reserve transfer.
 * 
 * NOTE: This console demo uses MOCKED j-events for fast development/testing.
 * The UI "Run Demo" button uses REAL j-watcher with blockchain integration.
 */

import { generateNumberedEntityId } from './entity-factory';
import { getJurisdictionByAddress } from './evm';
import { applyServerInput, processUntilEmpty } from './server';
import { ConsensusConfig, Env } from './types';
import { DEBUG, formatEntityDisplay } from './utils';

// This function simulates the data that a j-watcher would extract from on-chain events
const createDepositEvent = (entityId: string, signerId: string, asset: { asset: string, amount: string, decimals: number, tokenId: number }, eventType: string = 'DEPOSIT') => {
  const event = {
    entityId: entityId,
    signerId: signerId,
    entityTxs: [{
      type: 'j_event' as const,
      data: {
        from: signerId, 
        event: {
          type: 'ReserveUpdated' as const, // The watcher sees a reserve update
          data: {
            entity: entityId,
            tokenId: asset.tokenId,
            newBalance: asset.amount, // The event contains the final new balance
            name: asset.asset,
            symbol: asset.asset,
            decimals: asset.decimals,
          },
        },
        observedAt: Date.now(),
        blockNumber: 1, // Mock block number 
        transactionHash: `0xDEMO_${eventType}_${asset.asset}_${entityId.slice(0, 10)}`,
      },
    }],
  };
  
  if (DEBUG) {
    console.log(`🎭 Mock j_event created: ${eventType} ${asset.amount} ${asset.asset} for entity ${entityId.slice(0, 10)}...`);
  }
  
  return event;
};

const runDemo = async (env: Env): Promise<Env> => {
  if (DEBUG) {
    console.log('🚀 Starting XLN Demo: First Principles');
  }

  const ethereumJurisdiction = await getJurisdictionByAddress('ethereum');
  if (!ethereumJurisdiction) {
    throw new Error('❌ Ethereum jurisdiction not found');
  }

  const s1 = 's1';
  const s2 = 's2';

  console.log(`\n📋 Forming entities e1=[${s1}] and e2=[${s2}]...`);

  const e1_config: ConsensusConfig = {
    mode: 'proposer-based',
    threshold: BigInt(1),
    validators: [s1],
    shares: { [s1]: BigInt(1) },
    jurisdiction: ethereumJurisdiction,
  };
  const e1_id = generateNumberedEntityId(1);

  const e2_config: ConsensusConfig = {
    mode: 'proposer-based',
    threshold: BigInt(1),
    validators: [s2],
    shares: { [s2]: BigInt(1) },
    jurisdiction: ethereumJurisdiction,
  };
  const e2_id = generateNumberedEntityId(2);

  await applyServerInput(env, {
    serverTxs: [
      { type: 'importReplica', entityId: e1_id, signerId: s1, data: { config: e1_config, isProposer: true } },
      { type: 'importReplica', entityId: e2_id, signerId: s2, data: { config: e2_config, isProposer: true } },
    ],
    entityInputs: [],
  });
  await processUntilEmpty(env, []);
  
  // Clear any leftover transactions in mempool
  const e1_replica = env.replicas.get(`${e1_id}:${s1}`);
  const e2_replica = env.replicas.get(`${e2_id}:${s2}`);
  if (e1_replica) {
    console.log(`🧹 Cleared ${e1_replica.mempool.length} leftover transactions from e1 mempool`);
    e1_replica.mempool.length = 0;
  }
  if (e2_replica) {
    console.log(`🧹 Cleared ${e2_replica.mempool.length} leftover transactions from e2 mempool`);
    e2_replica.mempool.length = 0;
  }

  console.log(`✅ Entity ${formatEntityDisplay(e1_id)} and ${formatEntityDisplay(e2_id)} created.`);

  console.log(`\n💰 Prefunding entity ${formatEntityDisplay(e1_id)}...`);
  const initialPortfolio = [
    { asset: 'ETH', amount: '100000000000000000000', decimals: 18, tokenId: 1 },
    { asset: 'USDC', amount: '5000000000', decimals: 6, tokenId: 2 },
  ];

  const depositInputs = initialPortfolio.map(asset => createDepositEvent(e1_id, s1, asset));
  await applyServerInput(env, { serverTxs: [], entityInputs: depositInputs });
  await processUntilEmpty(env, []);
  
  const e1_replica_after_funding = env.replicas.get(`${e1_id}:${s1}`);
  
  // Debug: Check what's actually in reserves
  if (DEBUG) {
    console.log('📊 Debug - Reserves after funding:');
    if (e1_replica_after_funding?.state.reserves) {
      for (const [tokenId, balance] of e1_replica_after_funding.state.reserves.entries()) {
        console.log(`  Token ${tokenId}: ${balance.toString()}`);
      }
    } else {
      console.log('  No reserves found');
    }
  }

  const ethReserve = e1_replica_after_funding?.state.reserves.get('1');
  const expectedETHAmount = 100000000000000000000n;
  
  if (!e1_replica_after_funding) {
    throw new Error('❌ Verification failed: e1 replica not found after funding.');
  }
  
  if (ethReserve === undefined) {
    throw new Error('❌ Verification failed: e1 ETH reserve not found. Available reserves: ' +
      Array.from(e1_replica_after_funding.state.reserves.keys()).join(', '));
  }

  if (ethReserve !== expectedETHAmount) {
    throw new Error(`❌ Verification failed: e1 ETH amount mismatch. Expected: ${expectedETHAmount}, Got: ${ethReserve}`);
  }

  console.log(`✅ ${formatEntityDisplay(e1_id)} funded successfully with ${ethReserve / 10n**18n} ETH.`);

  console.log(`\n💸 Performing reserve transfer from ${formatEntityDisplay(e1_id)} to ${formatEntityDisplay(e2_id)}...`);
  
  const transferAmount = 1000000000000000000n; // 1 ETH
  const transferTokenId = 1;
  
  // Get current balances to calculate new balances after transfer
  const e1_replica_before_transfer = env.replicas.get(`${e1_id}:${s1}`);
  const e2_replica_before_transfer = env.replicas.get(`${e2_id}:${s2}`);
  
  if (!e1_replica_before_transfer) {
    throw new Error('❌ Entity 1 replica not found before transfer');
  }
  
  // Demo code: Default to 0n for display if token not initialized yet
  const e1_current_balance = e1_replica_before_transfer.state.reserves.get('1') ?? 0n;
  const e2_current_balance = e2_replica_before_transfer?.state.reserves.get('1') ?? 0n;
  
  console.log(`📊 Pre-transfer: e1=${e1_current_balance}, e2=${e2_current_balance}`);
  
  // Calculate new balances
  const e1_new_balance = e1_current_balance - transferAmount; // 100 ETH - 1 ETH = 99 ETH
  const e2_new_balance = e2_current_balance + transferAmount; // 0 ETH + 1 ETH = 1 ETH
  
  console.log(`📊 Post-transfer: e1=${e1_new_balance}, e2=${e2_new_balance}`);
  
  // Create j_events to simulate the jurisdiction updating both entities' reserves
  const transferEvents = [
    // Update Entity 1's balance (sender)
    createDepositEvent(e1_id, s1, { 
      asset: 'ETH', 
      amount: e1_new_balance.toString(), 
      decimals: 18, 
      tokenId: transferTokenId 
    }, 'TRANSFER_OUT'),
    // Update Entity 2's balance (receiver)  
    createDepositEvent(e2_id, s2, { 
      asset: 'ETH', 
      amount: e2_new_balance.toString(), 
      decimals: 18, 
      tokenId: transferTokenId 
    }, 'TRANSFER_IN')
  ];

  console.log(`💸 Simulating jurisdiction events for reserve transfer...`);
  await applyServerInput(env, { serverTxs: [], entityInputs: transferEvents });
  await processUntilEmpty(env, []);

  console.log('✅ Transfer transaction submitted.');
  
  const e1_replica_after_transfer = env.replicas.get(`${e1_id}:${s1}`);
  const e2_replica_after_transfer = env.replicas.get(`${e2_id}:${s2}`);
  
  // Debug: Check final reserves for both entities
  if (DEBUG) {
    console.log('📊 Debug - Final reserves after transfer:');
    console.log('Entity 1 reserves:');
    if (e1_replica_after_transfer?.state.reserves) {
      for (const [tokenId, balance] of e1_replica_after_transfer.state.reserves.entries()) {
        console.log(`  Token ${tokenId}: ${balance.toString()}`);
      }
    }
    console.log('Entity 2 reserves:');
    if (e2_replica_after_transfer?.state.reserves) {
      for (const [tokenId, balance] of e2_replica_after_transfer.state.reserves.entries()) {
        console.log(`  Token ${tokenId}: ${balance.toString()}`);
      }
    }
  }
  
  const e1_final_balance = e1_replica_after_transfer?.state.reserves.get('1');
  const e2_final_balance = e2_replica_after_transfer?.state.reserves.get('1');
  
  const expectedE1Balance = 99000000000000000000n; // 100 ETH - 1 ETH transfer = 99 ETH
  const expectedE2Balance = 1000000000000000000n; // 1 ETH transferred

  if (e1_final_balance !== expectedE1Balance) {
    throw new Error(`❌ Verification failed: e1 has incorrect final ETH balance. Expected: ${expectedE1Balance}, Got: ${e1_final_balance}`);
  }
  if (e2_final_balance !== expectedE2Balance) {
    throw new Error(`❌ Verification failed: e2 did not receive ETH. Expected: ${expectedE2Balance}, Got: ${e2_final_balance}`);
  }
  console.log(`✅ State verified: e1 has ${e1_final_balance / 10n**18n} ETH, e2 has ${e2_final_balance / 10n**18n} ETH.`);

  // 🆕 ACCOUNT OPENING AND DIRECT PAYMENT TEST
  console.log(`\n💳 Opening account between ${formatEntityDisplay(e1_id)} and ${formatEntityDisplay(e2_id)}...`);

  // STEP 1: e1 opens account with e2
  const accountOpeningInput = {
    entityId: e1_id,
    signerId: s1,
    entityTxs: [{
      type: 'openAccount' as const,
      data: { targetEntityId: e2_id }
    }]
  };

  await applyServerInput(env, { serverTxs: [], entityInputs: [accountOpeningInput] });
  await processUntilEmpty(env, []);

  console.log(`✅ Account opened between ${formatEntityDisplay(e1_id)} and ${formatEntityDisplay(e2_id)}`);

  // STEP 2: e1 sends direct payment to e2 via account (using credit)
  console.log(`\n💸 ${formatEntityDisplay(e1_id)} sending direct payment to ${formatEntityDisplay(e2_id)}...`);

  const directPaymentInput = {
    entityId: e1_id,
    signerId: s1,
    entityTxs: [{
      type: 'accountInput' as const,
      data: {
        fromEntityId: e1_id,
        toEntityId: e2_id,
        accountTx: {
          type: 'direct_payment' as const,
          data: {
            tokenId: 2, // USD token for reference pricing
            amount: 50000n, // $500 USD payment
            description: 'Demo direct payment from e1 to e2'
          }
        },
        metadata: {
          purpose: 'account_direct_payment',
          description: 'Testing direct payment with global credit limits'
        }
      }
    }]
  };

  await applyServerInput(env, { serverTxs: [], entityInputs: [directPaymentInput] });
  await processUntilEmpty(env, []);

  console.log(`✅ Direct payment sent: $500 USD from ${formatEntityDisplay(e1_id)} to ${formatEntityDisplay(e2_id)}`);

  // STEP 2.5: Verify bilateral balance conservation
  const e1_final_replica = env.replicas.get(`${e1_id}:${s1}`);
  const e2_final_replica = env.replicas.get(`${e2_id}:${s2}`);

  console.log(`\n🔍 BILATERAL BALANCE VERIFICATION:`);

  if (e1_final_replica?.state.accounts.has(e2_id) && e2_final_replica?.state.accounts.has(e1_id)) {
    const e1_account = e1_final_replica.state.accounts.get(e2_id)!;
    const e2_account = e2_final_replica.state.accounts.get(e1_id)!;

    // Check token 2 (USD) balances
    const e1_delta = e1_account.deltas.get(2);
    const e2_delta = e2_account.deltas.get(2);

    if (e1_delta && e2_delta) {
      const e1_total = e1_delta.ondelta + e1_delta.offdelta;
      const e2_total = e2_delta.ondelta + e2_delta.offdelta;
      const sum = e1_total + e2_total;

      console.log(`💰 E1 owes E2: ${e1_total.toString()} cents ($${(Number(e1_total) / 100).toFixed(2)})`);
      console.log(`💰 E2 owes E1: ${e2_total.toString()} cents ($${(Number(e2_total) / 100).toFixed(2)})`);
      console.log(`💰 Sum: ${sum.toString()} cents (should be 0)`);

      if (sum === 0n) {
        console.log(`✅ CONSERVATION LAW VERIFIED: Bilateral balance maintained in rundemo!`);
      } else {
        console.log(`❌ CONSERVATION VIOLATED: Bilateral imbalance detected!`);
      }

      if (e1_total === 50000n && e2_total === -50000n) {
        console.log(`✅ PAYMENT VERIFIED: $500 correctly transferred from E1 to E2`);
      } else {
        console.log(`❌ PAYMENT MISMATCH: Expected E1:+500, E2:-500, got E1:${e1_total}, E2:${e2_total}`);
      }
    } else {
      console.log(`⚠️ Missing deltas for verification`);
    }
  } else {
    console.log(`⚠️ Account machines not found for verification`);
  }

  // STEP 3: Verify account states
  const e1_replica_final = env.replicas.get(`${e1_id}:${s1}`);
  const e2_replica_final = env.replicas.get(`${e2_id}:${s2}`);

  if (e1_replica_final?.state.accounts.has(e2_id)) {
    const e1_account = e1_replica_final.state.accounts.get(e2_id)!;
    console.log(`💳 ${formatEntityDisplay(e1_id)} account with ${formatEntityDisplay(e2_id)}:`);
    console.log(`   Credit limits: own=${e1_account.globalCreditLimits.ownLimit.toString()} USD, peer=${e1_account.globalCreditLimits.peerLimit.toString()} USD`);
    console.log(`   Frame ${e1_account.currentFrame.frameId}: tokens=[${e1_account.currentFrame.tokenIds.join(',')}], deltas=[${e1_account.currentFrame.deltas.map(d => d.toString()).join(',')}]`);
    console.log(`   Sent transitions: ${e1_account.sentTransitions}, mempool: ${e1_account.mempool.length}`);
  }

  if (e2_replica_final?.state.accounts.has(e1_id)) {
    const e2_account = e2_replica_final.state.accounts.get(e1_id)!;
    console.log(`💳 ${formatEntityDisplay(e2_id)} account with ${formatEntityDisplay(e1_id)}:`);
    console.log(`   Credit limits: own=${e2_account.globalCreditLimits.ownLimit.toString()} USD, peer=${e2_account.globalCreditLimits.peerLimit.toString()} USD`);
    console.log(`   Frame ${e2_account.currentFrame.frameId}: tokens=[${e2_account.currentFrame.tokenIds.join(',')}], deltas=[${e2_account.currentFrame.deltas.map(d => d.toString()).join(',')}]`);
    console.log(`   Sent transitions: ${e2_account.sentTransitions}, mempool: ${e2_account.mempool.length}`);
  }

  console.log('\n🎯 J-MOCKED Demo completed with Account System!');
  console.log('📊 Check the dashboard to verify final reserve states and account states.');
  console.log('💳 Account system: 1M USD credit limits, direct payment processed');
  console.log('🌐 For REAL blockchain integration, use the "Run Demo" button in the UI!');

  return env;
};

export { runDemo };

--- src/debug-config.ts ---
/**
 * Simple debug toggle system
 * Set these to false to disable noisy logs
 */

export const DEBUG_LOGS = {
  // Core account flow (keep these)
  ACCOUNT_OPENING: true,
  ACCOUNT_FRAME: true,
  ENTITY_OUTPUT: true,

  // Noisy logs (disable these)
  ACCOUNT_DROPDOWN: false,
  REPLICA_LOOKUP: false,
  MERGE_INPUTS: false,
  CONSENSUS_CHECK: false,
  CLONE_TRACE: false,
  ENCODE_VALIDATION: false,

  // J-Watcher (keep minimal)
  J_WATCHER: false,
  J_EVENTS: false,
};

// Simple log wrapper
export const debugLog = (category: keyof typeof DEBUG_LOGS, ...args: any[]) => {
  if (DEBUG_LOGS[category]) {
    console.log(...args);
  }
};
--- src/utils.ts ---
/**
 * XLN Utility Functions
 * Platform detection, crypto polyfills, logging, and helper functions
 */

import { toSvg } from 'jdenticon';

import { extractNumberFromEntityId } from './entity-factory';

// Global polyfills for browser compatibility
if (typeof global === 'undefined') {
  globalThis.global = globalThis;
}

// Extend global interfaces for browser compatibility
declare global {
  interface Window {
    reinitializeAfterClear?: () => void;
    Buffer: typeof Buffer;
  }

  var global: typeof globalThis;

  interface Uint8Array {
    toString(encoding?: string): string;
  }
}

// Environment detection and compatibility layer
export const isBrowser = typeof window !== 'undefined';

// Simplified crypto compatibility
export const createHash = isBrowser
  ? (_algorithm: string) => ({
      update: (data: string) => ({
        digest: (encoding?: string) => {
          // Create proper 32-byte hash for browser demo using Web Crypto API
          const encoder = new TextEncoder();
          void encoder; // Available for future crypto implementation

          // Simple deterministic hash that produces 32 bytes
          let hash = 0;
          for (let i = 0; i < data.length; i++) {
            const char = data.charCodeAt(i);
            hash = (hash << 5) - hash + char;
            hash = hash & hash; // Convert to 32bit integer
          }

          // Create a 32-byte buffer by repeating and expanding the hash
          const baseHash = Math.abs(hash).toString(16).padStart(8, '0');
          const fullHash = (baseHash + baseHash + baseHash + baseHash).slice(0, 64); // 32 bytes = 64 hex chars

          if (encoding === 'hex') {
            return fullHash;
          } else {
            // Return as Buffer (Uint8Array)
            const bytes = new Uint8Array(32);
            for (let i = 0; i < 32; i++) {
              bytes[i] = parseInt(fullHash.substr(i * 2, 2), 16);
            }
            return Buffer.from(bytes);
          }
        },
      }),
    })
  : // eslint-disable-next-line @typescript-eslint/no-require-imports
    require('crypto').createHash;

export const randomBytes = isBrowser
  ? (size: number): Uint8Array => {
      const array = new Uint8Array(size);
      crypto.getRandomValues(array);
      return array;
    }
  : // eslint-disable-next-line @typescript-eslint/no-require-imports
    require('crypto').randomBytes;

// Simplified Buffer polyfill for browser
const getBuffer = () => {
  if (isBrowser) {
    return {
      from: (data: any, _encoding: string = 'utf8') => {
        if (typeof data === 'string') {
          return new TextEncoder().encode(data);
        }
        return new Uint8Array(data);
      },
    };
  }
  // eslint-disable-next-line @typescript-eslint/no-require-imports
  return require('buffer').Buffer;
};

export const Buffer = getBuffer();

// Browser polyfill for Uint8Array.toString()
if (isBrowser) {
  Uint8Array.prototype.toString = function (_encoding: string = 'utf8') {
    return new TextDecoder().decode(this);
  };
  window.Buffer = Buffer;
}

// Debug compatibility
const createDebug = (namespace: string) => {
  const shouldLog =
    namespace.includes('state') ||
    namespace.includes('tx') ||
    namespace.includes('block') ||
    namespace.includes('error') ||
    namespace.includes('diff') ||
    namespace.includes('info');
  return shouldLog ? console.log.bind(console, `[${namespace}]`) : () => {};
};
// eslint-disable-next-line @typescript-eslint/no-require-imports
const debug = isBrowser ? createDebug : require('debug');

// Configure debug logging with functional approach
export const log = {
  state: debug('state:🔵'),
  tx: debug('tx:🟡'),
  block: debug('block:🟢'),
  error: debug('error:🔴'),
  diff: debug('diff:🟣'),
  info: debug('info:ℹ️'),
};

// Hash utility function
export const hash = (data: Buffer | string): Buffer => {
  const result = createHash('sha256').update(data.toString()).digest();
  // Ensure we always return a Buffer, regardless of what digest() returns
  return Buffer.from(result as any);
};

// Global debug flag
export const DEBUG = true;

// Function to clear the database and reset in-memory history
export const clearDatabase = async (db?: any) => {
  console.log('Clearing database and resetting history...');

  if (db) {
    // High-level: Use the provided database instance (Level polyfill)
    await db.clear();
    console.log('✅ Database cleared via provided instance');
  } else {
    // Fallback: Clear the correct database name based on environment
    if (typeof indexedDB !== 'undefined') {
      // Browser: Clear IndexedDB with the same name that Level polyfill uses
      const dbNames = ['db', 'level-js-db', 'level-db']; // Common Level.js database names

      try {
        // Clear all possible database names that Level.js might use
        const clearPromises = dbNames.map(dbName => {
          return new Promise<void>(resolve => {
            const deleteReq = indexedDB.deleteDatabase(dbName);
            deleteReq.onsuccess = () => {
              console.log(`✅ Cleared IndexedDB: ${dbName}`);
              resolve();
            };
            deleteReq.onerror = () => {
              console.log(`⚠️ Could not clear IndexedDB: ${dbName} (may not exist)`);
              resolve(); // Don't fail if database doesn't exist
            };
            deleteReq.onblocked = () => {
              console.log(`⚠️ IndexedDB deletion blocked: ${dbName}`);
              resolve();
            };
          });
        });

        await Promise.all(clearPromises);
        console.log('✅ All databases cleared, re-initializing...');

        // Trigger re-initialization instead of page reload
        // TODO: delete deprecated reinitializeAfterClear
        if (typeof window !== 'undefined' && window.reinitializeAfterClear) {
          window.reinitializeAfterClear();
        }
        return;
      } catch (error) {
        console.log('❌ Error clearing IndexedDB:', error);
        if (typeof window !== 'undefined' && window.reinitializeAfterClear) {
          window.reinitializeAfterClear();
        }
        return;
      }
    }
  }
  console.log('Database cleared.');
};

// === ENTITY DISPLAY HELPERS ===

/**
 * Format entity ID for display
 * @param entityId - The entity ID to format
 * @returns Human-readable entity name with icon
 */
export const formatEntityDisplay = (entityId: string): string => {
  if (!entityId) {
    return 'undefined';
  }
  
  const number = extractNumberFromEntityId(entityId);
  if (number !== null) {
    // Numbered entity: show just the number with entity icon
    return number.toString();
  } else {
    // Lazy entity: show the full hash
    return entityId;
  }
};

/**
 * Get entity display info with avatar
 * @param entityId - The entity ID
 * @returns Object with display name and avatar
 */
export const getEntityDisplayInfo = (entityId: string): { name: string; avatar: string; type: 'numbered' | 'lazy' } => {
  if (!entityId) {
    return {
      name: 'Entity (undefined)',
      avatar: '❓',
      type: 'numbered',
    };
  }
  
  const number = extractNumberFromEntityId(entityId);
  if (number !== null) {
    return {
      name: `Entity #${number}`,
      avatar: generateEntityAvatar(entityId),
      type: 'numbered',
    };
  } else {
    return {
      name: entityId,
      avatar: generateEntityAvatar(entityId),
      type: 'lazy',
    };
  }
};

// === SIGNER DISPLAY HELPERS ===

/**
 * Demo signer mappings (using Hardhat default addresses)
 */
export const DEMO_SIGNERS = {
  alice: {
    name: 'alice.eth',
    address: '0x70997970C51812dc3A010C7d01b50e0d17dc79C8',
  },
  bob: {
    name: 'bob.eth',
    address: '0x3C44CdDdB6a900fa2b585dd299e03d12FA4293BC',
  },
  carol: {
    name: 'carol.eth',
    address: '0x90F79bf6EB2c4f870365E785982E1f101E93b906',
  },
  david: {
    name: 'david.eth',
    address: '0x15d34AAf54267DB7D7c367839AAf71A00a2C6A65',
  },
  eve: {
    name: 'eve.eth',
    address: '0x9965507D1a55bcC2695C58ba16FB37d819B0A4dc',
  },
};

/**
 * Format signer for display (name.eth with avatar indicator)
 * @param signerId - The signer ID to format
 * @returns Formatted signer display
 */
export const formatSignerDisplay = (signerId: string): string => {
  const signerInfo = DEMO_SIGNERS[signerId as keyof typeof DEMO_SIGNERS];
  if (signerInfo) {
    // Add avatar emoji as visual indicator (would be actual image in UI)
    return `👤 ${signerInfo.name}`;
  }
  // If not a demo signer, assume it's already an address
  return signerId;
};

/**
 * Format signer for display with address tooltip info
 * @param signerId - The signer ID to format
 * @returns Object with display name and address
 */
export const getSignerDisplayInfo = (signerId: string): { name: string; address: string; avatar: string } => {
  const signerInfo = DEMO_SIGNERS[signerId as keyof typeof DEMO_SIGNERS];
  if (signerInfo) {
    return {
      name: signerInfo.name,
      address: signerInfo.address,
      avatar: generateSignerAvatar(signerId),
    };
  }
  return {
    name: signerId,
    address: signerId,
    avatar: generateSignerAvatar(signerId),
  };
};

/**
 * Get address for demo signer
 * @param signerId - The signer ID
 * @returns Ethereum address
 */
export const getSignerAddress = (signerId: string): string => {
  const signerInfo = DEMO_SIGNERS[signerId as keyof typeof DEMO_SIGNERS];
  if (signerInfo) {
    return signerInfo.address;
  }
  // If not a demo signer, assume it's already an address
  return signerId;
};

// === AVATAR GENERATION ===

/**
 * Generate identicon avatar for entity
 * @param entityId - The entity ID to generate avatar for
 * @returns Base64 encoded SVG avatar
 */
export const generateEntityAvatar = (entityId: string): string => {
  try {
    // Use entity ID as seed for deterministic avatar
    const svg = toSvg(entityId, 40); // 40px size
    // Convert SVG to data URL (browser-compatible)
    return `data:image/svg+xml,${encodeURIComponent(svg)}`;
  } catch (error) {
    // Fallback: simple colored circle
    return generateFallbackAvatar(entityId);
  }
};

/**
 * Generate identicon avatar for signer
 * @param signerId - The signer ID to generate avatar for
 * @returns Base64 encoded SVG avatar
 */
export const generateSignerAvatar = (signerId: string): string => {
  try {
    // Use signer address for avatar generation
    const address = getSignerAddress(signerId);
    const svg = toSvg(address, 32); // 32px size for signers
    // Convert SVG to data URL (browser-compatible)
    return `data:image/svg+xml,${encodeURIComponent(svg)}`;
  } catch (error) {
    return generateFallbackAvatar(signerId);
  }
};

/**
 * Generate simple fallback avatar (colored circle)
 * @param seed - String to generate color from
 * @returns SVG data URL
 */
const generateFallbackAvatar = (seed: string): string => {
  // Simple hash to generate color
  let hash = 0;
  for (let i = 0; i < seed.length; i++) {
    hash = ((hash << 5) - hash + seed.charCodeAt(i)) & 0xffffffff;
  }

  // Generate HSL color
  const hue = Math.abs(hash) % 360;
  const saturation = 70;
  const lightness = 50;

  const svg = `<svg width="32" height="32" xmlns="http://www.w3.org/2000/svg">
    <circle cx="16" cy="16" r="16" fill="hsl(${hue}, ${saturation}%, ${lightness}%)"/>
  </svg>`;

  const base64 = Buffer.from(svg).toString('base64');
  return `data:image/svg+xml;base64,${base64}`;
};

// === CRYPTOGRAPHIC UTILITIES ===

/**
 * Browser-compatible hash function using window.crypto
 * @param content - String content to hash
 * @returns Promise<string> - Full SHA-256 hash with 0x prefix
 */
export async function cryptoHash(content: string): Promise<string> {
  const encoder = new TextEncoder();
  const data = encoder.encode(content);
  const hashBuffer = await crypto.subtle.digest('SHA-256', data);
  const hashArray = new Uint8Array(hashBuffer);
  const hashHex = Array.from(hashArray).map(b => b.toString(16).padStart(2, '0')).join('');
  return `0x${hashHex}`;
}

/**
 * Hash any object deterministically
 * @param obj - Object to hash
 * @returns Promise<string> - Full SHA-256 hash
 */
export async function hashObject(obj: any): Promise<string> {
  const content = deterministicStringify(obj);
  return await cryptoHash(content);
}

/**
 * Hash for 20-byte addresses (like old_src)
 * @param content - String content to hash
 * @returns Promise<string> - First 20 bytes as hex
 */
export async function hash20(content: string): Promise<string> {
  const fullHash = await cryptoHash(content);
  return fullHash.slice(0, 42); // 0x + 40 chars = 20 bytes
}

// Keep old names for backward compatibility
export const sha256Hash = cryptoHash;
export const sha256Hash20 = hash20;

/**
 * Deterministic object serialization for hashing
 * @param obj - Object to serialize
 * @returns string - Deterministic JSON string
 */
export function deterministicStringify(obj: any): string {
  return JSON.stringify(obj, (_key, value) => {
    if (typeof value === 'bigint') {
      return value.toString();
    }
    return value;
  });
}

// Re-export from entity-factory for convenience
export { extractNumberFromEntityId };

--- src/entity-helpers.ts ---
/**
 * Convert bytes32 entityId to human-readable entity number
 */
export function getEntityNumber(entityId: string): number {
  if (!entityId || entityId === '0x' || entityId === '0x0') {
    return 0;
  }
  // Convert hex string to number
  try {
    const num = parseInt(entityId, 16);
    return isNaN(num) ? 0 : num;
  } catch {
    return 0;
  }
}

/**
 * Format entity display - shows entity number
 */
export function formatEntityId(entityId: string): string {
  const num = getEntityNumber(entityId);
  return num > 0 ? `#${num}` : 'Unknown';
}
--- src/jurisdiction-loader.ts ---
/**
 * Centralized jurisdiction loader
 * Single source of truth for loading jurisdictions.json
 * Caches the result to avoid multiple file reads
 */

// Browser-compatible: Use isBrowser check instead of fs
import { isBrowser } from './utils';

interface JurisdictionConfig {
  name: string;
  chainId: number;
  rpc: string;
  contracts: {
    entityProvider: string;
    depository: string;
  };
  explorer: string;
  currency: string;
  status: string;
}

interface JurisdictionsData {
  version: string;
  lastUpdated: string;
  jurisdictions: Record<string, JurisdictionConfig>;
  defaults: {
    timeout: number;
    retryAttempts: number;
    gasLimit: number;
  };
}

let cachedJurisdictions: JurisdictionsData | null = null;

/**
 * Load jurisdictions.json once and cache the result
 * All parts of the system should use this function
 */
export function loadJurisdictions(): JurisdictionsData {
  // Browser compatibility check
  if (isBrowser) {
    throw new Error('loadJurisdictions() not available in browser - use evm.ts generateJurisdictions() instead');
  }

  // Return cached result if available (Node.js only)
  if (cachedJurisdictions) {
    return cachedJurisdictions;
  }

  try {
    const fs = require('fs'); // Dynamic require for Node.js only
    const jurisdictionsContent = fs.readFileSync('./jurisdictions.json', 'utf8');
    cachedJurisdictions = JSON.parse(jurisdictionsContent);

    console.log('📋 Jurisdictions loaded from file (cached for future use)');
    console.log(`  ├─ Version: ${cachedJurisdictions?.version}`);
    console.log(`  ├─ Last updated: ${cachedJurisdictions?.lastUpdated}`);
    console.log(`  └─ Jurisdictions: ${Object.keys(cachedJurisdictions?.jurisdictions || {}).join(', ')}`);

    return cachedJurisdictions!;
  } catch (error) {
    console.error('❌ Failed to load jurisdictions.json:', error);
    // Return a default structure if file doesn't exist
    cachedJurisdictions = {
      version: "1.0.0",
      lastUpdated: new Date().toISOString(),
      jurisdictions: {},
      defaults: {
        timeout: 30000,
        retryAttempts: 3,
        gasLimit: 1000000
      }
    };
    return cachedJurisdictions;
  }
}

/**
 * Clear the cache (useful for testing or when file is updated)
 */
export function clearJurisdictionsCache(): void {
  cachedJurisdictions = null;
  console.log('🔄 Jurisdictions cache cleared');
}

/**
 * Get cached jurisdictions without loading
 * Returns null if not loaded yet
 */
export function getCachedJurisdictions(): JurisdictionsData | null {
  return cachedJurisdictions;
}
--- src/gossip-loader.ts ---
import { Profile } from './gossip';

export async function loadPersistedProfiles(db: any, gossip: { announce: (p: Profile) => void }) {
  try {
    let profileCount = 0;
    const iterator = db.iterator({ gte: 'profile:', lt: 'profile:\xFF' });

    for await (const [key, value] of iterator) {
      try {
        const profile = JSON.parse(value);
        gossip.announce({
          entityId: profile.entityId,
          capabilities: profile.capabilities || [],
          hubs: profile.hubs || [],
          metadata: {
            name: profile.name,
            avatar: profile.avatar,
            bio: profile.bio,
            website: profile.website,
            lastUpdated: profile.lastUpdated,
            hankoSignature: profile.hankoSignature,
          },
        });
        profileCount++;
      } catch (parseError) {
        console.warn(`⚠️ Failed to parse profile from key ${key}:`, parseError);
      }
    }

    console.log(`📡 Restored ${profileCount} profiles from DB into gossip`);
    return profileCount;
  } catch (error) {
    console.error('❌ Failed to load persisted profiles:', error);
    return 0;
  }
}

--- src/account-consensus.ts ---
/**
 * XLN Account Consensus System
 *
 * Implements bilateral consensus between two entities for off-chain account settlement.
 * Based on old_src Channel.ts but adapted for entity-deterministic architecture.
 *
 * Key Concepts:
 * - AccountMachine: Bilateral state machine between two entities
 * - Giant Per-Token Table: Map<tokenId, Delta> like old_src channels
 * - Global Credit Limits: USD-denominated credit limits (simplified)
 * - Frame-Based Consensus: Bilateral agreement on account state changes
 * - Event Bubbling: Account events bubble up to E-Machine for entity messages
 */

import { AccountMachine, AccountFrame, AccountTx, AccountInput } from './types';
import { cloneAccountMachine } from './state-helpers';
import { deriveDelta, getDefaultCreditLimit, isLeft } from './account-utils';
import { signAccountFrame, verifyAccountSignature } from './account-tx/crypto';
import { cryptoHash as hash, hash20 } from './utils';
import { safeStringify, buffersEqual } from './serialization-utils';
import { validateAccountFrame as validateAccountFrameStrict } from './validation-utils';
import { encode } from './snapshot-coder';

// Removed createValidAccountSnapshot - using simplified AccountSnapshot interface

// === CONSTANTS ===
const MEMPOOL_LIMIT = 1000;
const MAX_MESSAGE_COUNTER = 1000000;

// === VALIDATION ===

/**
 * Validate account frame (frame-level validation)
 */
export function validateAccountFrame(frame: AccountFrame): boolean {
  if (frame.frameId < 0) return false;
  if (frame.accountTxs.length > 100) return false;
  if (frame.tokenIds.length !== frame.deltas.length) return false;

  const now = Date.now();
  if (Math.abs(frame.timestamp - now) > 300000) return false; // 5 min drift

  return true;
}

/**
 * Validate message counter (strict replay protection)
 */
export function validateMessageCounter(accountMachine: AccountMachine, counter: number): boolean {
  if (counter <= 0 || counter > MAX_MESSAGE_COUNTER) return false;

  // Strict counter validation: must be greater than last acked
  if (counter <= accountMachine.ackedTransitions) {
    console.log(`❌ Counter replay: ${counter} <= ${accountMachine.ackedTransitions}`);
    return false;
  }

  // Counter must be reasonable (not too far in future)
  const now = Date.now();
  if (counter > now + 60000) { // Max 1 minute in future
    console.log(`❌ Counter too far in future: ${counter} vs ${now}`);
    return false;
  }

  return true;
}

// === FRAME HASH COMPUTATION ===

async function createFrameHash(frame: AccountFrame): Promise<string> {
  // Use browser-compatible crypto for proper deterministic hashing
  const txsContent = frame.accountTxs.map(tx =>
    `${tx.type}:${safeStringify(tx.data)}`
  ).join('|');

  const content = `${frame.frameId}-${frame.timestamp}-${txsContent}-${frame.tokenIds.join(',')}-${frame.deltas.map(d => d.toString()).join(',')}`;

  // Use hash20 to get first 20 bytes like old_src
  return await hash20(content);
}

// === TRANSACTION PROCESSING ===


/**
 * Process AccountTx with proper direction handling (like old_src Channel)
 */
export function processAccountTx(
  accountMachine: AccountMachine,
  accountTx: AccountTx,
  isOurFrame: boolean = true
): { success: boolean; events: string[]; error?: string } {
  console.log(`🔄 Processing ${accountTx.type} for ${accountMachine.counterpartyEntityId.slice(-4)} (ourFrame: ${isOurFrame})`);

  const events: string[] = [];

  switch (accountTx.type) {
    case 'direct_payment': {
      const { tokenId, amount, route, description } = accountTx.data;

      // Get or create delta
      let delta = accountMachine.deltas.get(tokenId);
      if (!delta) {
        const defaultCreditLimit = getDefaultCreditLimit(tokenId);
        delta = {
          tokenId,
          collateral: 0n,
          ondelta: 0n,
          offdelta: 0n,
          leftCreditLimit: defaultCreditLimit,
          rightCreditLimit: defaultCreditLimit,
          leftAllowence: 0n,
          rightAllowence: 0n,
        };
        accountMachine.deltas.set(tokenId, delta);
      }

      // Determine canonical direction relative to left/right entities
      const leftEntity = accountMachine.proofHeader.fromEntity < accountMachine.proofHeader.toEntity
        ? accountMachine.proofHeader.fromEntity
        : accountMachine.proofHeader.toEntity;
      const rightEntity = leftEntity === accountMachine.proofHeader.fromEntity
        ? accountMachine.proofHeader.toEntity
        : accountMachine.proofHeader.fromEntity;

      // Identify payer entity explicitly (fallback to heuristics for legacy frames)
      let paymentFromEntity = accountTx.data.fromEntityId;
      if (!paymentFromEntity) {
        if (isOurFrame) {
          paymentFromEntity = accountMachine.proofHeader.fromEntity;
        } else {
          paymentFromEntity = accountMachine.counterpartyEntityId;
        }
      }

      let paymentToEntity = accountTx.data.toEntityId;
      if (!paymentToEntity) {
        paymentToEntity = paymentFromEntity === accountMachine.proofHeader.fromEntity
          ? accountMachine.proofHeader.toEntity
          : accountMachine.proofHeader.fromEntity;
      }

      if (!paymentFromEntity || !paymentToEntity) {
        return {
          success: false,
          error: 'FINANCIAL-SAFETY: Unable to determine payment endpoints',
          events,
        };
      }

      // Canonical delta: always relative to left entity (like Channel.ts reference)
      let canonicalDelta: bigint;
      if (paymentFromEntity === leftEntity && paymentToEntity === rightEntity) {
        canonicalDelta = amount; // left paying right
      } else if (paymentFromEntity === rightEntity && paymentToEntity === leftEntity) {
        canonicalDelta = -amount; // right paying left
      } else {
        // As a fallback, compare IDs for deterministic ordering
        canonicalDelta = paymentFromEntity < paymentToEntity ? amount : -amount;
      }

      const isLeftEntity = accountMachine.proofHeader.fromEntity < accountMachine.proofHeader.toEntity;

      // Check capacity using deriveDelta (perspective-aware)
      const derived = deriveDelta(delta, isLeftEntity);
      if (isOurFrame && amount > derived.outCapacity) {
        return {
          success: false,
          error: `Insufficient capacity: need ${amount.toString()}, available ${derived.outCapacity.toString()}`,
          events,
        };
      }

      // Check global credit limits for the USD-denominated token (token 2)
      const newDelta = delta.ondelta + delta.offdelta + canonicalDelta;
      if (isOurFrame && tokenId === 2 && newDelta > accountMachine.globalCreditLimits.peerLimit) {
        return {
          success: false,
          error: `Exceeds global credit limit: ${newDelta.toString()} > ${accountMachine.globalCreditLimits.peerLimit.toString()}`,
          events,
        };
      }

      // Apply canonical delta (identical on both sides)
      delta.offdelta += canonicalDelta;

      // Events differ by perspective but state is identical
      if (isOurFrame) {
        events.push(`💸 Sent ${amount.toString()} token ${tokenId} to Entity ${accountMachine.counterpartyEntityId.slice(-4)} ${description ? '(' + description + ')' : ''}`);
      } else {
        events.push(`💰 Received ${amount.toString()} token ${tokenId} from Entity ${paymentFromEntity.slice(-4)} ${description ? '(' + description + ')' : ''}`);
      }

      // Update current frame
      const tokenIndex = accountMachine.currentFrame.tokenIds.indexOf(tokenId);
      const totalDelta = delta.ondelta + delta.offdelta;

      if (tokenIndex >= 0) {
        accountMachine.currentFrame.deltas[tokenIndex] = totalDelta;
      } else {
        accountMachine.currentFrame.tokenIds.push(tokenId);
        accountMachine.currentFrame.deltas.push(totalDelta);
      }

      // Check if we need to forward the payment (multi-hop routing)
      const isOutgoing = paymentFromEntity === accountMachine.proofHeader.fromEntity;
      if (route && route.length > 1 && !isOutgoing) {
        // We received the payment, but it's not for us - forward to next hop
        const nextHop = route[0]; // Current entity should be route[0]
        const finalTarget = route[route.length - 1];
        if (!finalTarget) {
          console.error(`❌ Empty route in payment - invalid payment routing`);
          return { success: false, error: 'Invalid payment route', events };
        }

        if (accountMachine.counterpartyEntityId === nextHop) {
          // This is wrong - we received from the entity we should forward to
          console.error(`❌ Routing error: received from ${nextHop} but should forward to them`);
        } else {
          // Add forwarding event
          events.push(
            `↪️ Forwarding payment to ${finalTarget.slice(-4)} via ${route.length} more hops`
          );

          // Note: The actual forwarding happens through entity-consensus
          // which will create a new AccountTx for the next hop
          // Store the route info in the account machine for entity-consensus to process
          accountMachine.pendingForward = {
            tokenId,
            amount,
            route: route.slice(1), // Remove current hop
            ...(description ? { description } : {}),
          };
        }
      }

      return { success: true, events };
    }

    default:
      // Type-safe error handling for unknown AccountTx types
      const unknownType = 'type' in accountTx ? accountTx.type : 'MISSING_TYPE';
      return { success: false, error: `Unknown accountTx type: ${unknownType}`, events };
  }
}

// === FRAME CONSENSUS ===

/**
 * Propose account frame (like old_src Channel consensus)
 */
export async function proposeAccountFrame(
  accountMachine: AccountMachine
): Promise<{ success: boolean; accountInput?: AccountInput; events: string[]; error?: string }> {
  console.log(`🚀 E-MACHINE: Proposing account frame for ${accountMachine.counterpartyEntityId.slice(-4)}`);
  console.log(`🚀 E-MACHINE: Account state - mempool=${accountMachine.mempool.length}, pendingFrame=${!!accountMachine.pendingFrame}, currentFrameId=${accountMachine.currentFrameId}`);

  const events: string[] = [];

  // Mempool size validation
  if (accountMachine.mempool.length > MEMPOOL_LIMIT) {
    console.log(`❌ E-MACHINE: Mempool overflow ${accountMachine.mempool.length} > ${MEMPOOL_LIMIT}`);
    return { success: false, error: `Mempool overflow: ${accountMachine.mempool.length} > ${MEMPOOL_LIMIT}`, events };
  }

  if (accountMachine.mempool.length === 0) {
    console.log(`❌ E-MACHINE: No transactions in mempool to propose`);
    return { success: false, error: 'No transactions to propose', events };
  }

  // Check if we have a pending frame waiting for ACK
  if (accountMachine.pendingFrame) {
    console.log(`⏳ E-MACHINE: Still waiting for ACK on pending frame #${accountMachine.pendingFrame.frameId}`);
    return { success: false, error: 'Waiting for ACK on pending frame', events };
  }

  console.log(`✅ E-MACHINE: Creating frame with ${accountMachine.mempool.length} transactions...`);

  // Clone account machine for validation
  const clonedMachine = cloneAccountMachine(accountMachine);

  // Process all transactions on the clone
  const allEvents: string[] = [];
  for (const accountTx of accountMachine.mempool) {
    const result = processAccountTx(clonedMachine, accountTx, true); // Processing our own transactions

    if (!result.success) {
      return { success: false, error: `Tx validation failed: ${result.error}`, events: allEvents };
    }

    allEvents.push(...result.events);
  }

  // CRITICAL FIX: Extract FULL delta state from clonedMachine.deltas (after processing)
  // This was the consensus bug - we were using old currentFrame instead of new deltas
  const finalTokenIds: number[] = [];
  const finalDeltas: bigint[] = [];

  // Sort by tokenId for deterministic ordering
  const sortedTokens = Array.from(clonedMachine.deltas.entries()).sort((a, b) => a[0] - b[0]);

  for (const [tokenId, delta] of sortedTokens) {
    finalTokenIds.push(tokenId);
    // Calculate net delta: offdelta - ondelta (+ collateral for reserves)
    const netDelta = delta.offdelta - delta.ondelta;
    finalDeltas.push(netDelta);
  }

  console.log(`📊 Frame state after processing: ${finalTokenIds.length} tokens`);
  console.log(`📊 TokenIds: [${finalTokenIds.join(', ')}]`);
  console.log(`📊 Deltas: [${finalDeltas.map(d => d.toString()).join(', ')}]`);

  // Create account frame matching the real AccountFrame interface
  const frameData = {
    frameId: accountMachine.currentFrameId + 1,
    timestamp: Date.now(), // Keep as number
    accountTxs: [...accountMachine.mempool],
    previousStateHash: accountMachine.currentFrameId === 0 ? 'genesis' : await createFrameHash({
      frameId: accountMachine.currentFrameId,
      timestamp: accountMachine.currentFrame.timestamp,
      accountTxs: [],
      previousStateHash: '',
      stateHash: '',
      tokenIds: accountMachine.currentFrame.tokenIds,
      deltas: accountMachine.currentFrame.deltas,
    }),
    stateHash: '', // Will be filled after hash calculation
    tokenIds: finalTokenIds, // Use computed state from clonedMachine.deltas
    deltas: finalDeltas       // Use computed state from clonedMachine.deltas
  };

  // Calculate state hash
  frameData.stateHash = await createFrameHash(frameData as any);

  // VALIDATE AT SOURCE: Guaranteed type safety from this point forward
  const newFrame = validateAccountFrameStrict(frameData, 'proposeAccountFrame');

  // No more defensive checks needed - frame is guaranteed valid!

  // Generate signature
  const signature = signAccountFrame(accountMachine.proofHeader.fromEntity, newFrame.stateHash);

  // Set pending state
  accountMachine.pendingFrame = newFrame;
  accountMachine.sentTransitions = accountMachine.mempool.length;
  accountMachine.clonedForValidation = clonedMachine;

  // Clear mempool
  accountMachine.mempool = [];

  events.push(`🚀 Proposed frame ${newFrame.frameId} with ${newFrame.accountTxs.length} transactions`);

  const accountInput: AccountInput = {
    fromEntityId: accountMachine.proofHeader.fromEntity,
    toEntityId: accountMachine.proofHeader.toEntity,
    frameId: newFrame.frameId,
    newAccountFrame: newFrame,
    newSignatures: [signature],
    counter: ++accountMachine.proofHeader.cooperativeNonce, // CHANNEL.TS REFERENCE: Line 536 - use cooperativeNonce as counter
  };

  return { success: true, accountInput, events };
}

/**
 * Handle received AccountInput (bilateral consensus)
 */
export function handleAccountInput(
  accountMachine: AccountMachine,
  input: AccountInput
): { success: boolean; response?: AccountInput; events: string[]; error?: string } {
  console.log(`📨 A-MACHINE: Received AccountInput from ${input.fromEntityId.slice(-4)}`);

  const events: string[] = [];

  // Counter validation (replay protection) - only for established channels
  if (input.counter && accountMachine.currentFrameId > 0) {
    const counterValid = validateMessageCounter(accountMachine, input.counter);
    console.log(`🔍 Counter validation: ${input.counter} vs acked=${accountMachine.ackedTransitions}, frameId=${accountMachine.currentFrameId}, valid=${counterValid}`);

    if (!counterValid) {
      return { success: false, error: `Invalid message counter: ${input.counter} vs ${accountMachine.ackedTransitions}`, events };
    }
  } else if (input.counter) {
    console.log(`🔍 Initial frame - accepting counter ${input.counter} without strict validation`);
  }

  // Update acked counter
  if (input.counter) {
    accountMachine.ackedTransitions = Math.max(accountMachine.ackedTransitions, input.counter);
  }

  // Handle pending frame confirmation
  if (accountMachine.pendingFrame && input.frameId === accountMachine.pendingFrame.frameId && input.prevSignatures) {
    console.log(`✅ Received confirmation for pending frame ${input.frameId}`);

    const frameHash = accountMachine.pendingFrame.stateHash;
    const expectedSigner = accountMachine.proofHeader.toEntity;

    const signature = input.prevSignatures[0];
    if (input.prevSignatures.length > 0 && signature && verifyAccountSignature(expectedSigner, frameHash, signature)) {
      // Commit using cloned state
      if (accountMachine.clonedForValidation) {
        accountMachine.deltas = accountMachine.clonedForValidation.deltas;
        accountMachine.currentFrame = {
          frameId: accountMachine.pendingFrame.frameId,
          timestamp: accountMachine.pendingFrame.timestamp,
          tokenIds: accountMachine.pendingFrame.tokenIds,
          deltas: accountMachine.pendingFrame.deltas,
        };
        accountMachine.currentFrameId = accountMachine.pendingFrame.frameId;

        // Add confirmed frame to history
        accountMachine.frameHistory.push({...accountMachine.pendingFrame});
        console.log(`📚 Frame ${accountMachine.pendingFrame.frameId} added to history (total: ${accountMachine.frameHistory.length})`);
      }

      // Clear pending state
      delete accountMachine.pendingFrame;
      accountMachine.sentTransitions = 0;
      delete accountMachine.clonedForValidation;
      accountMachine.rollbackCount = Math.max(0, accountMachine.rollbackCount - 1); // Successful confirmation reduces rollback

      events.push(`✅ Frame ${input.frameId} confirmed and committed`);
      return { success: true, events };
    } else {
      return { success: false, error: 'Invalid confirmation signature', events };
    }
  }

  // Handle new frame proposal
  if (input.newAccountFrame) {
    const receivedFrame = input.newAccountFrame;

    if (!validateAccountFrame(receivedFrame)) {
      return { success: false, error: 'Invalid frame structure', events };
    }

    // Handle simultaneous proposals - both sides can propose
    // If we have a pending frame and receive one with same ID, we need to handle it
    if (receivedFrame.frameId === accountMachine.currentFrameId + 1 && accountMachine.pendingFrame &&
        accountMachine.pendingFrame.frameId === receivedFrame.frameId) {
      console.log(`🔄 Simultaneous proposals detected for frame ${receivedFrame.frameId}`);

      // Compare frame hashes to decide which to accept (deterministic tiebreaker)
      const ourHash = accountMachine.pendingFrame.stateHash;
      const theirHash = receivedFrame.stateHash;

      if (ourHash < theirHash) {
        console.log(`📤 Our frame wins (hash comparison), ignoring received frame`);
        // Keep our pending frame, ignore theirs
        return { success: false, error: 'Frame conflict - our frame has priority', events };
      } else {
        console.log(`📥 Their frame wins (hash comparison), accepting and rolling back ours`);
        // Accept their frame, rollback ours
        delete accountMachine.pendingFrame;
        accountMachine.sentTransitions = 0;
        delete accountMachine.clonedForValidation;
        // Continue to process their frame
      }
    }

    // Verify frame sequence
    if (receivedFrame.frameId !== accountMachine.currentFrameId + 1) {
      console.log(`❌ Frame sequence mismatch: expected ${accountMachine.currentFrameId + 1}, got ${receivedFrame.frameId}`);
      return { success: false, error: `Frame sequence mismatch: expected ${accountMachine.currentFrameId + 1}, got ${receivedFrame.frameId}`, events };
    }

    // Verify signatures
    if (input.newSignatures && input.newSignatures.length > 0) {
      const signature = input.newSignatures[0];
      if (!signature) {
        return { success: false, error: 'Missing signature in newSignatures array', events };
      }
      const isValid = verifyAccountSignature(input.fromEntityId, receivedFrame.stateHash, signature);
      if (!isValid) {
        return { success: false, error: 'Invalid frame signature', events };
      }
    }

    // Apply frame transactions to clone (as receiver)
    const clonedMachine = cloneAccountMachine(accountMachine);
    const processEvents: string[] = [];

    for (const accountTx of receivedFrame.accountTxs) {
      // When receiving a frame, we process transactions from counterparty's perspective (incoming)
      const result = processAccountTx(clonedMachine, accountTx, false); // Processing their transactions = incoming
      if (!result.success) {
        return { success: false, error: `Frame application failed: ${result.error}`, events };
      }
      processEvents.push(...result.events);
    }

    // STATE VERIFICATION: Compare our computed state with their claimed state (like old_src Channel.ts)
    const ourComputedState = encode(clonedMachine.deltas);

    // Reconstruct their claimed state from the frame
    const theirClaimedDeltas = new Map();
    receivedFrame.tokenIds?.forEach((tokenId, i) => {
      const existingDelta = accountMachine.deltas.get(tokenId);
      if (existingDelta) {
        // Frame contains total delta (ondelta + offdelta), we need to reconstruct the full delta
        const totalClaimed = receivedFrame.deltas[i];
        theirClaimedDeltas.set(tokenId, {
          ...existingDelta,
          // Assume ondelta stays same, frame delta represents new total
          offdelta: totalClaimed! - existingDelta.ondelta
        });
      }
    });
    const theirClaimedState = encode(theirClaimedDeltas);

    console.log(`🔍 STATE-VERIFY Frame ${receivedFrame.frameId}:`);
    console.log(`  Our computed:  ${ourComputedState.toString('hex').slice(0, 32)}...`);
    console.log(`  Their claimed: ${theirClaimedState.toString('hex').slice(0, 32)}...`);

    if (!buffersEqual(ourComputedState, theirClaimedState)) {
      console.error(`❌ CONSENSUS-FAILURE: Both sides computed different final states!`);

      // DUMP EVERYTHING - FULL DATA STRUCTURES
      console.error(`❌ FULL CONSENSUS FAILURE DUMP:`);
      console.error(`❌ AccountMachine BEFORE:`, safeStringify(accountMachine));
      console.error(`❌ ClonedMachine AFTER:`, safeStringify(clonedMachine));
      console.error(`❌ ReceivedFrame COMPLETE:`, safeStringify(receivedFrame));
      console.error(`❌ TheirClaimedDeltas COMPLETE:`, safeStringify(Object.fromEntries(theirClaimedDeltas)));
      console.error(`❌ OurComputedState BUFFER:`, Array.from(ourComputedState).map(b => b.toString(16).padStart(2,'0')).join(''));
      console.error(`❌ TheirClaimedState BUFFER:`, Array.from(theirClaimedState).map(b => b.toString(16).padStart(2,'0')).join(''));
      const isLeftEntity = isLeft(accountMachine.proofHeader.fromEntity, accountMachine.proofHeader.toEntity);
      console.error(`❌ isLeft=${isLeftEntity}, fromEntity=${accountMachine.proofHeader.fromEntity}, toEntity=${accountMachine.proofHeader.toEntity}`);

      return { success: false, error: `Bilateral consensus failure - states don't match`, events };
    }

    console.log(`✅ CONSENSUS-SUCCESS: Both sides computed identical state for frame ${receivedFrame.frameId}`);

    // Commit frame
    accountMachine.deltas = clonedMachine.deltas;
    accountMachine.currentFrame = {
      frameId: receivedFrame.frameId,
      timestamp: receivedFrame.timestamp,
      tokenIds: receivedFrame.tokenIds,
      deltas: receivedFrame.deltas,
    };
    accountMachine.currentFrameId = receivedFrame.frameId;

    // Add accepted frame to history
    accountMachine.frameHistory.push({...receivedFrame});
    console.log(`📚 Frame ${receivedFrame.frameId} accepted and added to history (total: ${accountMachine.frameHistory.length})`);

    events.push(...processEvents);
    events.push(`🤝 Accepted frame ${receivedFrame.frameId} from Entity ${input.fromEntityId.slice(-4)}`);

    // Send confirmation
    const confirmationSig = signAccountFrame(accountMachine.proofHeader.fromEntity, receivedFrame.stateHash);
    const response: AccountInput = {
      fromEntityId: accountMachine.proofHeader.fromEntity,
      toEntityId: input.fromEntityId,
      frameId: receivedFrame.frameId,
      prevSignatures: [confirmationSig],
      counter: ++accountMachine.proofHeader.cooperativeNonce, // CHANNEL.TS REFERENCE: Line 536 - use cooperativeNonce as counter
    };

    return { success: true, response, events };
  }

  return { success: true, events };
}

// === E-MACHINE INTEGRATION ===

/**
 * Add transaction to account mempool with limits
 */
export function addToAccountMempool(accountMachine: AccountMachine, accountTx: AccountTx): boolean {
  if (accountMachine.mempool.length >= MEMPOOL_LIMIT) {
    console.log(`❌ Mempool full: ${accountMachine.mempool.length} >= ${MEMPOOL_LIMIT}`);
    return false;
  }

  accountMachine.mempool.push(accountTx);
  console.log(`📥 Added ${accountTx.type} to mempool (${accountMachine.mempool.length}/${MEMPOOL_LIMIT})`);
  return true;
}

/**
 * Check if account should auto-propose frame
 */
export function shouldProposeFrame(accountMachine: AccountMachine): boolean {
  // Should propose if:
  // 1. Has transactions in mempool
  // 2. No pending frame waiting for confirmation
  // Note: BOTH sides can propose in bilateral consensus (not just the proposer)
  return accountMachine.mempool.length > 0 && !accountMachine.pendingFrame;
}

/**
 * Get accounts that should propose frames (for E-Machine auto-propose)
 */
export function getAccountsToProposeFrames(entityState: any): string[] {
  const accountsToProposeFrames: string[] = [];

  // Check if accounts exists and is iterable
  if (!entityState.accounts || !(entityState.accounts instanceof Map)) {
    console.log(`⚠️ No accounts or accounts not a Map: ${typeof entityState.accounts}`);
    return accountsToProposeFrames;
  }

  for (const [counterpartyEntityId, accountMachine] of entityState.accounts) {
    if (shouldProposeFrame(accountMachine)) {
      accountsToProposeFrames.push(counterpartyEntityId);
    }
  }

  return accountsToProposeFrames;
}

// === PROOF GENERATION (for future J-Machine integration) ===

/**
 * Generate account proof for dispute resolution (like old_src Channel.getSubchannelProofs)
 * Must be ABI-compatible with Depository contract
 */
export async function generateAccountProof(accountMachine: AccountMachine): Promise<{ proofHash: string; signature: string }> {
  // Update proofBody with current state (like old_src does before signing)
  accountMachine.proofBody = {
    tokenIds: Array.from(accountMachine.deltas.keys()).sort((a, b) => a - b), // Deterministic order
    deltas: Array.from(accountMachine.deltas.keys())
      .sort((a, b) => a - b)
      .map(tokenId => {
        const delta = accountMachine.deltas.get(tokenId);
        if (!delta) {
          console.error(`❌ Missing delta for tokenId ${tokenId} in account ${accountMachine.counterpartyEntityId}`);
          throw new Error(`Critical financial data missing: delta for token ${tokenId}`);
        }
        return delta.ondelta + delta.offdelta; // Total delta for each token
      }),
  };

  // Create proof structure compatible with Depository.sol
  const proofData = {
    fromEntity: accountMachine.proofHeader.fromEntity,
    toEntity: accountMachine.proofHeader.toEntity,
    cooperativeNonce: accountMachine.proofHeader.cooperativeNonce,
    disputeNonce: accountMachine.proofHeader.disputeNonce,
    tokenIds: accountMachine.proofBody.tokenIds,
    deltas: accountMachine.proofBody.deltas.map(d => d.toString()), // Convert BigInt for JSON
  };

  // Create deterministic proof hash using browser-compatible crypto
  const proofContent = safeStringify(proofData);
  const fullHash = await hash(proofContent);
  const proofHash = fullHash.slice(2); // Remove 0x prefix for compatibility

  // Generate hanko signature (like old_src does)
  const signature = signAccountFrame(accountMachine.proofHeader.fromEntity, `0x${proofHash}`);

  // Store signature for later use
  accountMachine.hankoSignature = signature;

  console.log(`🔐 Generated account proof: ${accountMachine.proofBody.tokenIds.length} tokens, hash: 0x${proofHash.slice(0, 20)}...`);
  console.log(`🔐 ProofBody tokens: [${accountMachine.proofBody.tokenIds.join(',')}]`);
  console.log(`🔐 ProofBody deltas: [${accountMachine.proofBody.deltas.map(d => d.toString()).join(',')}]`);

  return { proofHash: `0x${proofHash}`, signature };
}

--- src/types.ts ---
/**
 * XLN Type Definitions
 * All interfaces and type definitions used across the XLN system
 */

import type { Profile } from './gossip.js';

export interface JurisdictionConfig {
  address: string;
  name: string;
  entityProviderAddress: string;
  depositoryAddress: string;
  chainId?: number;
}

export interface ConsensusConfig {
  mode: 'proposer-based' | 'gossip-based';
  threshold: bigint;
  validators: string[];
  shares: { [validatorId: string]: bigint };
  jurisdiction?: JurisdictionConfig;
}

export interface ServerInput {
  serverTxs: ServerTx[];
  entityInputs: EntityInput[];
}

export interface ServerTx {
  type: 'importReplica';
  entityId: string;
  signerId: string;
  data: {
    config: ConsensusConfig;
    isProposer: boolean;
  };
}

export interface EntityInput {
  entityId: string;
  signerId: string;
  entityTxs?: EntityTx[];
  precommits?: Map<string, string>; // signerId -> signature
  proposedFrame?: ProposedEntityFrame;
}

export interface Proposal {
  id: string; // hash of the proposal
  proposer: string;
  action: ProposalAction;
  // TODO: refactor votes to use VoteData
  votes: Map<string, 'yes' | 'no' | 'abstain' | { choice: 'yes' | 'no' | 'abstain'; comment: string }>;
  status: 'pending' | 'executed' | 'rejected';
  created: number; // entity timestamp when proposal was created (deterministic)
}

export interface ProposalAction {
  type: 'collective_message';
  data: {
    message: string;
  };
}

export interface VoteData {
  proposalId: string;
  voter: string;
  choice: 'yes' | 'no' | 'abstain';
  comment?: string;
}

/**
 * Jurisdiction event data for j_event transactions
 * Flattened structure (no nested event object)
 */
export interface JurisdictionEventData {
  from: string;
  event: {
    type: string; // e.g. "reserveToReserve", "GovernanceEnabled"
    data: any;
  };
  observedAt: number;
  blockNumber: number;
  transactionHash: string;
}

export interface AccountTxInput {
  fromEntityId: string;
  toEntityId: string;
  accountTx: AccountTx; // The actual account transaction to process
  metadata?: {
    purpose?: string;
    description?: string;
  };
}

export type EntityTx =
  | {
      type: 'chat';
      data: { from: string; message: string };
    }
  | {
      type: 'propose';
      data: { action: ProposalAction; proposer: string };
    }
  | {
      type: 'vote';
      data: { proposalId: string; voter: string; choice: 'yes' | 'no'; comment?: string };
    }
  | {
      type: 'profile-update';
      data: { profile: any }; // replace with concrete profile type if available
    }
  | {
      type: 'j_event';
      data: JurisdictionEventData;
    }
  | {
      type: 'accountInput';
      data: AccountInput;
    }
  | {
      type: 'openAccount';
      data: { targetEntityId: string };
    }
  | {
      type: 'directPayment';
      data: {
        targetEntityId: string;
        tokenId: number;
        amount: bigint;
        route: string[]; // Full path from source to target
        description?: string;
      };
    }
  | {
      type: 'settleDiffs';
      data: {
        counterpartyEntityId: string;
        diffs: Array<{
          tokenId: number;
          leftDiff: bigint;   // Positive = credit, Negative = debit
          rightDiff: bigint;
          collateralDiff: bigint;
          ondeltaDiff: bigint;
        }>;
        description?: string; // e.g., "Fund collateral from reserve"
      };
    };

export interface AssetBalance {
  amount: bigint; // Balance in smallest unit (wei, cents, shares)
  // Note: symbol, decimals, contractAddress come from token registry, not stored here
}

// Account machine structures for signed and collateralized accounts between entities
export interface AccountDelta {
  tokenId: number;
  delta: bigint; // Positive = we owe them, Negative = they owe us
}

// Simple account state snapshot (for currentFrame)
export interface AccountSnapshot {
  frameId: number;
  timestamp: number;
  tokenIds: number[]; // Array of token IDs in this account
  deltas: bigint[]; // Array of deltas corresponding to tokenIds
  stateHash?: string; // Optional hash for cryptographic verification
}

export interface AccountMachine {
  counterpartyEntityId: string;
  mempool: AccountTx[]; // Unprocessed account transactions
  currentFrame: AccountSnapshot; // Current agreed state
  sentTransitions: number; // Number of transitions sent but not yet confirmed
  ackedTransitions: number; // Number of transitions acknowledged by counterparty

  // Per-token delta states (giant per-token table like old_src)
  deltas: Map<number, Delta>; // tokenId -> Delta

  // Global credit limits (in reference currency - USDC)
  globalCreditLimits: {
    ownLimit: bigint; // How much credit we extend to counterparty (USD)
    peerLimit: bigint; // How much credit counterparty extends to us (USD)
  };

  // Frame-based consensus (like old_src Channel, consistent with entity frames)
  currentFrameId: number;
  pendingFrame?: AccountFrame;
  pendingSignatures: string[];

  // Rollback support for bilateral disagreements
  rollbackCount: number;

  // CHANNEL.TS REFERENCE: Proper message counters (NOT timestamps!)
  sendCounter: number;    // Incremented for each outgoing message
  receiveCounter: number; // Incremented for each incoming message
  // Removed isProposer - use isLeft() function like old_src Channel.ts instead

  // Cloned state for validation before committing (replaces dryRun)
  clonedForValidation?: AccountMachine;

  // Proof structures for dispute resolution
  proofHeader: {
    fromEntity: string; // Our entity ID
    toEntity: string; // Counterparty entity ID
    cooperativeNonce: number;
    disputeNonce: number;
  };
  proofBody: {
    tokenIds: number[];
    deltas: bigint[];
  };
  hankoSignature?: string; // Last signed proof by counterparty
  // Historical frame log - grows until manually pruned by entity
  frameHistory: AccountFrame[]; // All confirmed bilateral frames in chronological order

  // Payment routing: temporary storage for multi-hop payments
  pendingForward?: {
    tokenId: number;
    amount: bigint;
    route: string[];
    description?: string;
  };
}

// Account frame structure for bilateral consensus (renamed from AccountBlock)
export interface AccountFrame {
  frameId: number;
  timestamp: number;
  accountTxs: AccountTx[]; // Renamed from transitions
  previousStateHash: string;
  stateHash: string;
  // Removed isProposer - both sides can propose bilaterally
  tokenIds: number[]; // Array of token IDs in this frame
  deltas: bigint[]; // Array of deltas corresponding to tokenIds
}

// Unified AccountInput interface (merging transaction-level and frame-level inputs)
export interface AccountInput {
  fromEntityId: string;
  toEntityId: string;

  // For transaction-level inputs
  accountTx?: AccountTx; // Single account transaction to process
  metadata?: {
    purpose?: string;
    description?: string;
  };

  // For frame-level inputs (consensus)
  frameId?: number; // Frame-based consensus
  prevSignatures?: string[]; // Previous signatures (acknowledging their frame)
  newAccountFrame?: AccountFrame; // New account frame we're proposing
  newSignatures?: string[]; // Our signatures on the new frame
  counter?: number; // Message counter for ordering (replay protection)
}

// Delta structure for per-token account state (based on old_src)
export interface Delta {
  tokenId: number;
  collateral: bigint;
  ondelta: bigint; // On-chain delta
  offdelta: bigint; // Off-chain delta
  leftCreditLimit: bigint;
  rightCreditLimit: bigint;
  leftAllowence: bigint;
  rightAllowence: bigint;
}

// Derived account balance information per token
export interface DerivedDelta {
  delta: bigint;
  collateral: bigint;
  inCollateral: bigint;
  outCollateral: bigint;
  inOwnCredit: bigint;
  outPeerCredit: bigint;
  inAllowence: bigint;
  outAllowence: bigint;
  totalCapacity: bigint;
  ownCreditLimit: bigint;
  peerCreditLimit: bigint;
  inCapacity: bigint;
  outCapacity: bigint;
  outOwnCredit: bigint;
  inPeerCredit: bigint;
  ascii: string; // ASCII visualization from deriveDelta (like old_src)
}

// Account transaction types
export type AccountTx =
  | { type: 'account_payment'; data: { tokenId: number; amount: bigint } }
  | { type: 'direct_payment'; data: { tokenId: number; amount: bigint; route?: string[]; description?: string; fromEntityId?: string; toEntityId?: string } }
  | { type: 'set_credit_limit'; data: { tokenId: number; amount: bigint; isForSelf: boolean } }
  | { type: 'account_frame'; data: { frame: AccountFrame; processedTransactions: number; fromEntity: string } }
  | {
      type: 'account_settle';
      data: {
        tokenId: number;
        ownReserve: string;
        counterpartyReserve: string;
        collateral: string;
        ondelta: string;
        side: 'left' | 'right';
        blockNumber: number;
        transactionHash: string;
      };
    };

export interface EntityState {
  entityId: string; // The entity ID this state belongs to
  height: number;
  timestamp: number;
  nonces: Map<string, number>;
  messages: string[];
  proposals: Map<string, Proposal>;
  config: ConsensusConfig;

  // 💰 Financial state
  reserves: Map<string, bigint>; // tokenId -> amount only, metadata from TOKEN_REGISTRY
  accounts: Map<string, AccountMachine>; // counterpartyEntityId -> account state
  // 🔭 J-machine tracking
  jBlock: number; // Last processed J-machine block number

  // 🔗 Account machine integration
  accountInputQueue?: AccountInput[]; // Queue of settlement events to be processed by a-machine
}

export interface ProposedEntityFrame {
  height: number;
  txs: EntityTx[];
  hash: string;
  newState: EntityState;
  signatures: Map<string, string>; // signerId -> signature
}

export interface EntityReplica {
  entityId: string;
  signerId: string;
  state: EntityState;
  mempool: EntityTx[];
  proposal?: ProposedEntityFrame;
  lockedFrame?: ProposedEntityFrame; // Frame this validator is locked/precommitted to
  isProposer: boolean;
}

export interface Env {
  replicas: Map<string, EntityReplica>;
  height: number;
  timestamp: number;
  serverInput: ServerInput; // Persistent storage for merged inputs
  history: EnvSnapshot[]; // Time machine snapshots - single source of truth
  gossip: any; // Gossip layer for network profiles
  // Future: add config, utilities, etc.
}

export interface ServerSnapshot {
  height: number;
  entities: Record<string, EntityState>;
  gossip: {
    profiles: Record<string, Profile>;
  };
}

export interface EnvSnapshot {
  height: number;
  timestamp: number;
  replicas: Map<string, EntityReplica>;
  serverInput: ServerInput;
  serverOutputs: EntityInput[];
  description: string;
  gossip?: {
    profiles: Record<string, Profile>;
  };
}

// Entity types
export type EntityType = 'lazy' | 'numbered' | 'named';

// Constants
export const ENC = 'hex' as const;

// === HANKO BYTES SYSTEM (Final Design) ===
export interface HankoBytes {
  placeholders: Buffer[]; // Entity IDs that failed to sign (index 0..N-1)
  packedSignatures: Buffer; // EOA signatures → yesEntities (index N..M-1)
  claims: HankoClaim[]; // Entity claims to verify (index M..∞)
}

export interface HankoClaim {
  entityId: Buffer;
  entityIndexes: number[];
  weights: number[];
  threshold: number;
  expectedQuorumHash: Buffer;
}

export interface HankoVerificationResult {
  valid: boolean;
  entityId: Buffer;
  signedHash: Buffer;
  yesEntities: Buffer[];
  noEntities: Buffer[];
  completionPercentage: number; // 0-100% completion
  errors?: string[];
}

export interface HankoMergeResult {
  merged: HankoBytes;
  addedSignatures: number;
  completionBefore: number;
  completionAfter: number;
  log: string[];
}

/**
 * Context for hanko verification
 */
export interface HankoContext {
  timestamp: number;
  blockNumber?: number;
  networkId?: number;
}

// === PROFILE & NAME RESOLUTION TYPES ===

/**
 * Entity profile stored in gossip layer
 */
export interface EntityProfile {
  entityId: string;
  name: string; // Human-readable name e.g., "Alice Corp", "Bob's DAO"
  avatar?: string; // Custom avatar URL (fallback to generated identicon)
  bio?: string; // Short description
  website?: string; // Optional website URL
  lastUpdated: number; // Timestamp of last update
  hankoSignature: string; // Signature proving entity ownership
}

/**
 * Profile update transaction data
 */
export interface ProfileUpdateTx {
  name?: string;
  avatar?: string;
  bio?: string;
  website?: string;
}

/**
 * Name index for autocomplete
 */
export interface NameIndex {
  [name: string]: string; // name -> entityId mapping
}

/**
 * Autocomplete search result
 */
export interface NameSearchResult {
  entityId: string;
  name: string;
  avatar: string;
  relevance: number; // Search relevance score 0-1
}

--- src/gossip-helper.ts ---
/**
 * Helper functions for gossip profile management
 * Builds and broadcasts entity profiles with account information
 */

import type { EntityState } from './types';
import type { Profile } from './gossip';
import { deriveDelta, isLeft } from './account-utils';

/**
 * Build gossip profile from entity state
 * Includes all account capacities for routing
 */
export function buildEntityProfile(entityState: EntityState): Profile {
  const accounts: Profile['accounts'] = [];

  // Build account capacities from all accounts
  for (const [counterpartyId, accountMachine] of entityState.accounts.entries()) {
    const tokenCapacities = new Map<number, {
      inCapacity: bigint;
      outCapacity: bigint;
    }>();

    // Calculate capacities for each token
    for (const [tokenId, delta] of accountMachine.deltas.entries()) {
      const isLeftEntity = isLeft(accountMachine.proofHeader.fromEntity, accountMachine.proofHeader.toEntity);
      const derived = deriveDelta(delta, isLeftEntity);
      tokenCapacities.set(tokenId, {
        inCapacity: derived.inCapacity,
        outCapacity: derived.outCapacity,
      });
    }

    accounts.push({
      counterpartyId,
      tokenCapacities,
    });
  }

  // Build profile
  const profile: Profile = {
    entityId: entityState.entityId,
    capabilities: [], // TODO: Add capabilities based on entity features
    hubs: [], // TODO: Track hub connections
    metadata: {
      lastUpdated: Date.now(),
      isHub: false, // TODO: Determine from capabilities
      routingFeePPM: 100, // Default 100 PPM (0.01%)
      baseFee: 0n,
    },
    accounts,
  };

  return profile;
}

/**
 * Create a ServerTx to broadcast profile update
 */
export function createProfileBroadcastTx(entityState: EntityState): any {
  const profile = buildEntityProfile(entityState);

  return {
    type: 'gossipBroadcast',
    data: {
      profile,
      timestamp: Date.now(),
    },
  };
}
--- src/logger.ts ---
// Log filtering system for debugging
export interface LogConfig {
  ENTITY_TX: boolean;
  ACCOUNT_OPEN: boolean;
  SIGNER_LOOKUP: boolean;
  PROCESS_CASCADE: boolean;
  FRAME_CONSENSUS: boolean;
  ENTITY_OUTPUT: boolean;
  ENTITY_INPUT: boolean;
  SERVER_TICK: boolean;
  J_WATCHER: boolean;
  BLOCKCHAIN: boolean;
  GOSSIP: boolean;
  R2R_FLOW: boolean;
  ACCOUNT_STATE: boolean;
}

// Default log config - toggle these to debug specific flows
export const LOG_CONFIG: LogConfig = {
  ENTITY_TX: true,
  ACCOUNT_OPEN: true,
  SIGNER_LOOKUP: true,
  PROCESS_CASCADE: true,
  FRAME_CONSENSUS: false,
  ENTITY_OUTPUT: true,
  ENTITY_INPUT: true,
  SERVER_TICK: false,
  J_WATCHER: false,
  BLOCKCHAIN: false,
  GOSSIP: false,
  R2R_FLOW: true, // Enable to debug r2r receiver issues
  ACCOUNT_STATE: true,
};

// Helper to check if logging is enabled for a category
export function shouldLog(category: keyof LogConfig): boolean {
  return LOG_CONFIG[category] ?? false;
}

// Conditional logger
export function log(category: keyof LogConfig, ...args: any[]): void {
  if (shouldLog(category)) {
    console.log(...args);
  }
}

// Debug helper to show current config
export function showLogConfig(): void {
  console.log('📊 Current Log Configuration:');
  Object.entries(LOG_CONFIG).forEach(([key, enabled]) => {
    console.log(`  ${enabled ? '✅' : '❌'} ${key}`);
  });
}

// Runtime config setter (for debugging from console)
export function setLogConfig(category: keyof LogConfig, enabled: boolean): void {
  LOG_CONFIG[category] = enabled;
  console.log(`🔧 Log category "${category}" set to ${enabled ? 'ON' : 'OFF'}`);
}

// Enable all logs
export function enableAllLogs(): void {
  Object.keys(LOG_CONFIG).forEach(key => {
    LOG_CONFIG[key as keyof LogConfig] = true;
  });
  console.log('✅ All logs enabled');
}

// Disable all logs
export function disableAllLogs(): void {
  Object.keys(LOG_CONFIG).forEach(key => {
    LOG_CONFIG[key as keyof LogConfig] = false;
  });
  console.log('❌ All logs disabled');
}

// Extend Window interface for debugging
declare global {
  interface Window {
    logConfig: {
      show: typeof showLogConfig;
      set: typeof setLogConfig;
      enableAll: typeof enableAllLogs;
      disableAll: typeof disableAllLogs;
      config: typeof LOG_CONFIG;
    };
  }
}

// Export to window for runtime debugging
if (typeof window !== 'undefined') {
  window.logConfig = {
    show: showLogConfig,
    set: setLogConfig,
    enableAll: enableAllLogs,
    disableAll: disableAllLogs,
    config: LOG_CONFIG,
  };
  console.log('🔧 Log config available at window.logConfig');
}
--- src/entity-tx/validation.ts ---
// Security validation helpers: validateNonce, validateMessage
import { log } from '../utils';

export const validateNonce = (currentNonce: number, expectedNonce: number, from: string): boolean => {
  try {
    if (expectedNonce !== currentNonce + 1) {
      log.error(`❌ Invalid nonce from ${from}: expected ${currentNonce + 1}, got ${expectedNonce}`);
      return false;
    }
    return true;
  } catch (error) {
    log.error(`❌ Nonce validation error: ${error}`);
    return false;
  }
};

export const validateMessage = (message: string): boolean => {
  try {
    if (typeof message !== 'string') {
      log.error(`❌ Message must be string, got: ${typeof message}`);
      return false;
    }
    if (message.length > 1000) {
      log.error(`❌ Message too long: ${message.length} > 1000 chars`);
      return false;
    }
    if (message.length === 0) {
      log.error(`❌ Empty message not allowed`);
      return false;
    }
    return true;
  } catch (error) {
    log.error(`❌ Message validation error: ${error}`);
    return false;
  }
};

--- src/entity-tx/apply.ts ---
import { calculateQuorumPower } from '../entity-consensus';
import { formatEntityId } from '../entity-helpers';
import { processProfileUpdate } from '../name-resolution';
import { db } from '../server';
import { EntityState, EntityTx, Env, Proposal, Delta, AccountTx, AccountInput, EntityInput } from '../types';
import { DEBUG, log } from '../utils';
import { safeStringify } from '../serialization-utils';
import { buildEntityProfile } from '../gossip-helper';
import { createDemoDelta, getDefaultCreditLimit } from '../account-utils';
// import { addToReserves, subtractFromReserves } from './financial'; // Currently unused
import { handleAccountInput } from './handlers/account';
import { handleJEvent } from './j-events';
import { executeProposal, generateProposalId } from './proposals';
import { validateMessage } from './validation';
import { cloneEntityState } from '../state-helpers';
import { submitSettle } from '../evm';

export const applyEntityTx = async (env: Env, entityState: EntityState, entityTx: EntityTx): Promise<{ newState: EntityState, outputs: EntityInput[] }> => {
  if (!entityTx) {
    console.error(`❌ EntityTx is undefined!`);
    return { newState: entityState, outputs: [] };
  }

  console.log(`🚨🚨 APPLY-ENTITY-TX: type="${entityTx?.type}" (typeof: ${typeof entityTx?.type})`);
  console.log(`🚨🚨 APPLY-ENTITY-TX: data=`, safeStringify(entityTx?.data, 2));
  console.log(`🚨🚨 APPLY-ENTITY-TX: Available types: profile-update, j_event, accountInput, openAccount, directPayment`);
  try {
    if (entityTx.type === 'chat') {
      const { from, message } = entityTx.data;

      if (!validateMessage(message)) {
        log.error(`❌ Invalid chat message from ${from}`);
        return { newState: entityState, outputs: [] }; // Return unchanged state
      }

      const currentNonce = entityState.nonces.get(from) || 0;
      const expectedNonce = currentNonce + 1;

      const newEntityState = cloneEntityState(entityState);

      newEntityState.nonces.set(from, expectedNonce);
      newEntityState.messages.push(`${from}: ${message}`);

      if (newEntityState.messages.length > 10) {
        newEntityState.messages.shift();
      }

      return { newState: newEntityState, outputs: [] };
    }

    if (entityTx.type === 'propose') {
      const { action, proposer } = entityTx.data;
      const proposalId = generateProposalId(action, proposer, entityState);

      if (DEBUG) console.log(`    📝 Creating proposal ${proposalId} by ${proposer}: ${action.data.message}`);

      const proposal: Proposal = {
        id: proposalId,
        proposer,
        action,
        // explicitly type votes map to match Proposal.vote value type
        votes: new Map<string, 'yes' | 'no' | 'abstain' | { choice: 'yes' | 'no' | 'abstain'; comment: string }>([
          [proposer, 'yes'],
        ]),
        status: 'pending',
        created: entityState.timestamp,
      };

      const proposerPower = entityState.config.shares[proposer] || BigInt(0);
      const shouldExecuteImmediately = proposerPower >= entityState.config.threshold;

      let newEntityState = cloneEntityState(entityState);

      if (shouldExecuteImmediately) {
        proposal.status = 'executed';
        newEntityState = executeProposal(newEntityState, proposal);
        if (DEBUG)
          console.log(
            `    ⚡ Proposal executed immediately - proposer has ${proposerPower} >= ${entityState.config.threshold} threshold`,
          );
      } else {
        if (DEBUG)
          console.log(
            `    ⏳ Proposal pending votes - proposer has ${proposerPower} < ${entityState.config.threshold} threshold`,
          );
      }

      newEntityState.proposals.set(proposalId, proposal);
      return { newState: newEntityState, outputs: [] };
    }

    if (entityTx.type === 'vote') {
      console.log(`🗳️ PROCESSING VOTE: entityTx.data=`, entityTx.data);
      const { proposalId, voter, choice, comment } = entityTx.data;
      const proposal = entityState.proposals.get(proposalId);

      console.log(`🗳️ Vote lookup: proposalId=${proposalId}, found=${!!proposal}, status=${proposal?.status}`);
      console.log(`🗳️ Available proposals:`, Array.from(entityState.proposals.keys()));

      if (!proposal || proposal.status !== 'pending') {
        console.log(`    ❌ Vote ignored - proposal ${proposalId.slice(0, 12)}... not found or not pending`);
        return { newState: entityState, outputs: [] };
      }

      console.log(`    🗳️  Vote by ${voter}: ${choice} on proposal ${proposalId.slice(0, 12)}...`);

      const newEntityState = cloneEntityState(entityState);

      const updatedProposal = {
        ...proposal,
        votes: new Map(proposal.votes),
      };
      // Only create the object variant when comment is provided (comment must be string)
      const voteData: 'yes' | 'no' | 'abstain' | { choice: 'yes' | 'no' | 'abstain'; comment: string } =
        comment !== undefined ? ({ choice, comment } as { choice: 'yes' | 'no' | 'abstain'; comment: string }) : choice;
      updatedProposal.votes.set(voter, voteData);

      const yesVoters = Array.from(updatedProposal.votes.entries())
        .filter(([_voter, voteData]) => {
          const vote = typeof voteData === 'object' ? voteData.choice : voteData;
          return vote === 'yes';
        })
        .map(([voter, _voteData]) => voter);

      const totalYesPower = calculateQuorumPower(entityState.config, yesVoters);

      if (DEBUG) {
        const totalShares = Object.values(entityState.config.shares).reduce((sum, val) => sum + val, BigInt(0));
        const percentage = ((Number(totalYesPower) / Number(entityState.config.threshold)) * 100).toFixed(1);
        console.log(
          `    🔍 Proposal votes: ${totalYesPower} / ${totalShares} [${percentage}% threshold${Number(totalYesPower) >= Number(entityState.config.threshold) ? '+' : ''}]`,
        );
      }

      if (totalYesPower >= entityState.config.threshold) {
        updatedProposal.status = 'executed';
        const executedState = executeProposal(newEntityState, updatedProposal);
        executedState.proposals.set(proposalId, updatedProposal);
        return { newState: executedState, outputs: [] };
      }

      newEntityState.proposals.set(proposalId, updatedProposal);
      return { newState: newEntityState, outputs: [] };
    }

    if (entityTx.type === 'profile-update') {
      console.log(`🏷️ Profile update transaction processing - data:`, entityTx.data);

      // Extract profile update data
      const profileData = entityTx.data.profile;
      console.log(`🏷️ Extracted profileData:`, profileData);

      if (profileData && profileData.entityId) {
        console.log(`🏷️ Calling processProfileUpdate for entity ${profileData.entityId}`);
        // Process profile update synchronously to ensure gossip is updated before snapshot
        try {
          await processProfileUpdate(db, profileData.entityId, profileData, profileData.hankoSignature || '', env);
        } catch (error) {
          console.error(`❌ Failed to process profile update for ${profileData.entityId}:`, error);
        }
      } else {
        console.warn(`⚠️ Invalid profile-update transaction data:`, entityTx.data);
        console.warn(`⚠️ ProfileData missing or invalid:`, profileData);
      }

      return { newState: entityState, outputs: [] };
    }

    if (entityTx.type === 'j_event') {
      const newState = handleJEvent(entityState, entityTx.data);
      return { newState, outputs: [] };
    }

    if (entityTx.type === 'accountInput') {
      const result = await handleAccountInput(entityState, entityTx.data, env);
      return result;
    }

    if (entityTx.type === 'openAccount') {
      console.log(`💳 OPEN-ACCOUNT: Opening account with ${entityTx.data.targetEntityId}`);

      const newState = cloneEntityState(entityState);
      const outputs: EntityInput[] = [];

      // Add chat message about account opening
      newState.messages.push(`💳 Opening account with Entity ${formatEntityId(entityTx.data.targetEntityId)}...`);

      // STEP 1: Create local account machine
      if (!newState.accounts.has(entityTx.data.targetEntityId)) {
        console.log(`💳 LOCAL-ACCOUNT: Creating local account with Entity ${formatEntityId(entityTx.data.targetEntityId)}...`);

        // Initialize with default USDT delta showing credit limits
        const initialDeltas = new Map<number, Delta>();
        initialDeltas.set(2, createDemoDelta(2, 0n, 0n)); // USDT token

        newState.accounts.set(entityTx.data.targetEntityId, {
          counterpartyEntityId: entityTx.data.targetEntityId,
          mempool: [],
          currentFrame: { frameId: 0, timestamp: Date.now(), tokenIds: [], deltas: [] },
          sentTransitions: 0,
          ackedTransitions: 0,
          deltas: initialDeltas,
          globalCreditLimits: {
            ownLimit: getDefaultCreditLimit(3), // We extend 1M USD credit (USDC) to counterparty
            peerLimit: getDefaultCreditLimit(3), // Counterparty extends same credit to us
          },
          // Frame-based consensus fields
          currentFrameId: 0,
          pendingSignatures: [],
          rollbackCount: 0,
          // CHANNEL.TS REFERENCE: Proper message counters (NOT timestamps!)
          sendCounter: 0,    // Like Channel.ts line 131
          receiveCounter: 0, // Like Channel.ts line 132
          // Removed isProposer - use isLeft() function like old_src Channel.ts
          proofHeader: {
            fromEntity: entityState.entityId,
            toEntity: entityTx.data.targetEntityId,
            cooperativeNonce: 0,
            disputeNonce: 0,
          },
          proofBody: { tokenIds: [], deltas: [] },
          frameHistory: [] // Initialize empty frame history
        });
      }

      // STEP 2: Send initial AccountInput to target entity to establish bilateral account
      console.log(`💳 Sending initial AccountInput to ${formatEntityId(entityTx.data.targetEntityId)} to establish account`);

      // Create AccountInput with initial account opening handshake
      const accountInput: AccountInput = {
        fromEntityId: entityState.entityId,
        toEntityId: entityTx.data.targetEntityId,
        accountTx: {
          type: 'account_payment',
          data: {
            tokenId: 2, // USDT - initial account opening transaction
            amount: 0n
          }
        }
      };

      // Get the proposer of the target entity (default to 'alice' if not found)
      let targetProposerId = 'alice';
      const targetReplicaKeys = Array.from(env.replicas.keys()).filter(key => key.startsWith(entityTx.data.targetEntityId + ':'));
      if (targetReplicaKeys.length > 0) {
        const firstKey = targetReplicaKeys[0];
        if (firstKey) {
          const firstTargetReplica = env.replicas.get(firstKey);
          const firstValidator = firstTargetReplica?.state.config.validators[0];
          if (firstValidator) {
            targetProposerId = firstValidator;
          }
        }
      }
      console.log(`💳 Target entity ${entityTx.data.targetEntityId.slice(0,10)} has proposer: ${targetProposerId}`);

      // Queue AccountInput to be sent to target entity
      outputs.push({
        entityId: entityTx.data.targetEntityId,
        signerId: targetProposerId,
        entityTxs: [{
          type: 'accountInput',
          data: accountInput
        }]
      });
      console.log(`📤 Queued AccountInput for Entity ${formatEntityId(entityTx.data.targetEntityId)}`);

      // Add success message to chat
      newState.messages.push(`✅ Account opening request sent to Entity ${formatEntityId(entityTx.data.targetEntityId)}`);

      // Broadcast updated profile to gossip layer
      if (env.gossip) {
        const profile = buildEntityProfile(newState);
        env.gossip.announce(profile);
        console.log(`📡 Broadcast profile for ${entityState.entityId} with ${newState.accounts.size} accounts`);
      }

      return { newState, outputs };
    }

    if (entityTx.type === 'directPayment') {
      console.log(`💸 DIRECT-PAYMENT: Initiating payment to ${entityTx.data.targetEntityId}`);

      const newState = cloneEntityState(entityState);
      const outputs: EntityInput[] = [];

      // Extract payment details
      let { targetEntityId, tokenId, amount, route, description } = entityTx.data;

      // If no route provided, check for direct account or calculate route
      if (!route || route.length === 0) {
        // Check if we have a direct account with target
        if (newState.accounts.has(targetEntityId)) {
          console.log(`💸 Direct account exists with ${formatEntityId(targetEntityId)}`);
          route = [entityState.entityId, targetEntityId];
        } else {
          // Find route through network using gossip
          console.log(`💸 No direct account, finding route to ${formatEntityId(targetEntityId)}`);

          // Try to find a route through the network
          if (env.gossip) {
            const networkGraph = env.gossip.getNetworkGraph();
            const paths = networkGraph.findPaths(entityState.entityId, targetEntityId);

            if (paths.length > 0) {
              // Use the shortest path
              route = paths[0].path;
              console.log(`💸 Found route: ${route.map(e => formatEntityId(e)).join(' → ')}`);
            } else {
              console.error(`❌ No route found to ${formatEntityId(targetEntityId)}`);
              newState.messages.push(`❌ Payment failed: No route to ${formatEntityId(targetEntityId)}`);
              return { newState, outputs: [] };
            }
          } else {
            console.error(`❌ Cannot find route: Gossip layer not available`);
            newState.messages.push(`❌ Payment failed: Network routing unavailable`);
            return { newState, outputs: [] };
          }
        }
      }

      // Validate route starts with current entity
      if (route.length < 2 || route[0] !== entityState.entityId) {
        console.error(`❌ Invalid route: doesn't start with current entity`);
        return { newState: entityState, outputs: [] };
      }

      // Determine next hop
      const nextHop = route[1];
      if (!nextHop) {
        console.error(`❌ Invalid route: no next hop specified in route`);
        return { newState: entityState, outputs: [] };
      }

      // Check if we have an account with next hop
      if (!newState.accounts.has(nextHop)) {
        console.error(`❌ No account with next hop: ${nextHop}`);
        newState.messages.push(`❌ Payment failed: No account with ${formatEntityId(nextHop)}`);
        return { newState, outputs: [] };
      }

      // Create AccountTx for the payment
      const accountTx: AccountTx = {
        type: 'direct_payment',
        data: {
          tokenId,
          amount,
          route: route.slice(1), // Remove current entity from route
          description: description || `Payment to ${formatEntityId(targetEntityId)}`,
        },
      };

      // Add to account machine mempool
      const accountMachine = newState.accounts.get(nextHop);
      if (accountMachine) {
        accountMachine.mempool.push(accountTx);
        console.log(`💸 Added payment to mempool for account with ${formatEntityId(nextHop)}`);
        console.log(`💸 Account mempool now has ${accountMachine.mempool.length} pending transactions`);
        const isLeft = accountMachine.proofHeader.fromEntity < accountMachine.proofHeader.toEntity;
        console.log(`💸 Is left entity: ${isLeft}, Has pending frame: ${!!accountMachine.pendingFrame}`);

        // Message about payment initiation
        newState.messages.push(
          `💸 Sending ${amount} (token ${tokenId}) to ${formatEntityId(targetEntityId)} via ${route.length - 1} hops`
        );

        // The payment is now in our local mempool with the next hop
        // It will be processed through bilateral consensus in the next round
        // The auto-propose logic in entity-consensus will handle proposing the frame
        console.log(`💸 Payment queued for bilateral consensus with ${formatEntityId(nextHop)}`);
        console.log(`💸 Account ${formatEntityId(nextHop)} should be added to proposableAccounts`);

        // Note: The entity-consensus applyEntityFrame will add this account to proposableAccounts
        // and trigger bilateral frame proposal at the end of the processing round

        // Return a trigger output to ensure processUntilEmpty continues
        // This ensures the AUTO-PROPOSE logic runs to process the payment
        const firstValidator = entityState.config.validators[0];
        if (firstValidator) {
          outputs.push({
            entityId: entityState.entityId,
            signerId: firstValidator,
            entityTxs: [] // Empty transaction array - just triggers processing
          });
        }
        console.log(`💸 Added processing trigger to ensure bilateral consensus runs`);
      }

      return { newState, outputs };
    }

    if (entityTx.type === 'settleDiffs') {
      console.log(`🏦 SETTLE-DIFFS: Processing settlement with ${entityTx.data.counterpartyEntityId}`);

      const newState = cloneEntityState(entityState);
      const { counterpartyEntityId, diffs, description } = entityTx.data;

      // Step 1: Validate invariant for all diffs
      for (const diff of diffs) {
        const sum = diff.leftDiff + diff.rightDiff + diff.collateralDiff;
        if (sum !== 0n) {
          console.error(`❌ INVARIANT-VIOLATION: leftDiff + rightDiff + collateralDiff = ${sum} (must be 0)`);
          throw new Error(`Settlement invariant violation: ${sum} !== 0`);
        }
      }

      // Step 2: Validate account exists
      if (!newState.accounts.has(counterpartyEntityId)) {
        console.error(`❌ No account exists with ${formatEntityId(counterpartyEntityId)}`);
        throw new Error(`No account with ${counterpartyEntityId}`);
      }

      // Step 3: Determine canonical left/right order
      const isLeft = entityState.entityId < counterpartyEntityId;
      const leftEntity = isLeft ? entityState.entityId : counterpartyEntityId;
      const rightEntity = isLeft ? counterpartyEntityId : entityState.entityId;

      console.log(`🏦 Canonical order: left=${leftEntity.slice(0,10)}..., right=${rightEntity.slice(0,10)}...`);
      console.log(`🏦 We are: ${isLeft ? 'LEFT' : 'RIGHT'}`);

      // Step 4: Get jurisdiction config
      const jurisdiction = entityState.config.jurisdiction;
      if (!jurisdiction) {
        throw new Error('No jurisdiction configured for this entity');
      }

      // Step 5: Convert diffs to contract format (preserve perspective)
      const contractDiffs = diffs.map(d => ({
        tokenId: d.tokenId,
        leftDiff: d.leftDiff.toString(),
        rightDiff: d.rightDiff.toString(),
        collateralDiff: d.collateralDiff.toString(),
        ondeltaDiff: d.ondeltaDiff.toString(),
      }));

      console.log(`🏦 Calling submitSettle with diffs:`, safeStringify(contractDiffs, 2));

      // Step 6: Call Depository.settle() - fire and forget (j-watcher handles result)
      try {
        const result = await submitSettle(jurisdiction, leftEntity, rightEntity, contractDiffs);
        console.log(`✅ Settlement transaction sent: ${result.txHash}`);

        // Add message to chat
        newState.messages.push(
          `🏦 ${description || 'Settlement'} tx: ${result.txHash.slice(0, 10)}... (block ${result.blockNumber})`
        );
      } catch (error) {
        console.error(`❌ Settlement transaction failed:`, error);
        newState.messages.push(`❌ Settlement failed: ${(error as Error).message}`);
        throw error; // Re-throw to trigger outer catch
      }

      return { newState, outputs: [] };
    }

    return { newState: entityState, outputs: [] };
  } catch (error) {
    log.error(`❌ Transaction execution error: ${error}`);
    return { newState: entityState, outputs: [] }; // Return unchanged state on error
  }
};

--- src/entity-tx/proposals.ts ---
// import { calculateQuorumPower } from '../entity-consensus'; // TODO: Remove if not needed
import { EntityState, Proposal, ProposalAction } from '../types';
import { createHash, DEBUG } from '../utils';

export const generateProposalId = (action: ProposalAction, proposer: string, entityState: EntityState): string => {
  const proposalData = JSON.stringify({
    type: action.type,
    data: action.data,
    proposer,
    timestamp: entityState.timestamp,
  });

  const hash = createHash('sha256').update(proposalData).digest('hex');
  return `prop_${hash.slice(0, 12)}`;
};

export const executeProposal = (entityState: EntityState, proposal: Proposal): EntityState => {
  if (proposal.action.type === 'collective_message') {
    const message = `[COLLECTIVE] ${proposal.action.data.message}`;
    if (DEBUG) console.log(`    🏛️  Executing collective proposal: "${message}"`);

    const newMessages = [...entityState.messages, message];

    if (newMessages.length > 10) {
      newMessages.shift();
    }

    return {
      ...entityState,
      messages: newMessages,
    };
  }
  return entityState;
};

--- src/entity-tx/financial.ts ---
import { AssetBalance } from '../types';

// Financial helpers: formatAssetAmount, addToReserves, subtractFromReserves
// Use unified financial utilities with ethers.js
export { formatAssetAmount } from '../financial-utils';

export const addToReserves = (
  reserves: Map<string, AssetBalance>,
  symbol: string,
  amount: bigint,
  _decimals: number,
  _contractAddress?: string,
): void => {
  const existing = reserves.get(symbol);
  if (existing) {
    existing.amount += amount;
  } else {
    reserves.set(symbol, { amount });
  }
};

export const subtractFromReserves = (reserves: Map<string, AssetBalance>, symbol: string, amount: bigint): boolean => {
  const existing = reserves.get(symbol);
  if (!existing || existing.amount < amount) {
    return false; // Insufficient balance
  }
  existing.amount -= amount;
  if (existing.amount === 0n) {
    reserves.delete(symbol);
  }
  return true;
};

--- src/entity-tx/j-events.ts ---
import { EntityState } from '../types';
import { DEBUG } from '../utils';
import { cloneEntityState } from '../state-helpers';

// Token registry for consistent naming (matches contract prefunding)
const TOKEN_REGISTRY: Record<number, { symbol: string; name: string; decimals: number }> = {
  1: { symbol: 'ETH', name: 'Ethereum', decimals: 18 },
  2: { symbol: 'USDC', name: 'USD Coin', decimals: 18 },
};

const getTokenSymbol = (tokenId: number): string => {
  return TOKEN_REGISTRY[tokenId]?.symbol || `TKN${tokenId}`;
};

const getTokenDecimals = (tokenId: number): number => {
  return TOKEN_REGISTRY[tokenId]?.decimals || 18;
};

export const handleJEvent = (entityState: EntityState, entityTxData: any): EntityState => {
  const { from, event, observedAt, blockNumber, transactionHash } = entityTxData;

  // Reject events from blocks we've already processed - handle undefined jBlock
  const currentJBlock = entityState.jBlock || 0;
  console.log(`🔍 J-EVENT-CHECK: ${event.type} block=${blockNumber} vs entity.jBlock=${currentJBlock} (raw=${entityState.jBlock}), from=${from}`);
  if (blockNumber <= currentJBlock) {
    console.log(`🔄 IGNORING OLD J-EVENT: ${event.type} from block ${blockNumber} (entity already at j-block ${entityState.jBlock})`);
    return entityState;
  }
  console.log(`✅ J-EVENT-ACCEPTED: ${event.type} block=${blockNumber} > entity.jBlock=${entityState.jBlock}, will process`);

  const newEntityState = cloneEntityState(entityState);
  // Update jBlock to current event block
  newEntityState.jBlock = blockNumber ?? (entityState.jBlock ?? 0);

  // Create elaborate j-event message with full details
  const timestamp = new Date(observedAt).toLocaleTimeString();
  const txHashShort = transactionHash ? transactionHash.slice(0, 10) + '...' : 'unknown';
  
  let elaborateMessage = '';
  
  if (event.type === 'reserve_transferred') {
    const { from: fromEntity, to: toEntity, tokenId, amount, direction } = event.data;
    const tokenSymbol = getTokenSymbol(tokenId);
    const decimals = getTokenDecimals(tokenId);
    const amountDisplay = (Number(amount) / (10 ** decimals)).toFixed(4);
    
    if (direction === 'sent') {
      elaborateMessage = `💸 ${from} observed RESERVE TRANSFER: Sent ${amountDisplay} ${tokenSymbol} to Entity ${toEntity.slice(-1)}
📍 Block: ${blockNumber} | ⏰ ${timestamp} | 🔗 Tx: ${txHashShort}
🎯 Event: ReserveTransferred | 🔢 TokenID: ${tokenId} | 💰 Amount: ${amount} (raw)`;
    } else {
      elaborateMessage = `💰 ${from} observed RESERVE TRANSFER: Received ${amountDisplay} ${tokenSymbol} from Entity ${fromEntity.slice(-1)}
📍 Block: ${blockNumber} | ⏰ ${timestamp} | 🔗 Tx: ${txHashShort}
🎯 Event: ReserveTransferred | 🔢 TokenID: ${tokenId} | 💰 Amount: ${amount} (raw)`;
    }
  } else if (event.type === 'ReserveUpdated') {
    const { tokenId, newBalance } = event.data;
    const tokenSymbol = getTokenSymbol(tokenId);
    const decimals = getTokenDecimals(tokenId);
    const balanceDisplay = (Number(newBalance) / (10 ** decimals)).toFixed(4);
    
    elaborateMessage = `📊 ${from} observed RESERVE UPDATE: ${tokenSymbol} balance now ${balanceDisplay} (accepted: event.block=${blockNumber} > entity.jBlock=${currentJBlock})
📍 Block: ${blockNumber} | ⏰ ${timestamp} | 🔗 Tx: ${txHashShort}
🎯 Event: ReserveUpdated | 🔢 TokenID: ${tokenId} | 💰 New Balance: ${newBalance} (raw)
🏦 Decimals: ${decimals} | 🔤 Symbol: ${tokenSymbol}`;
  } else if (event.type === 'SettlementProcessed') {
    const { counterpartyEntityId, tokenId, ownReserve, counterpartyReserve, collateral, ondelta, side } = event.data;
    const tokenSymbol = getTokenSymbol(tokenId);
    const decimals = getTokenDecimals(tokenId);
    const ownBalanceDisplay = (Number(ownReserve) / (10 ** decimals)).toFixed(4);
    const counterpartyBalanceDisplay = (Number(counterpartyReserve) / (10 ** decimals)).toFixed(4);
    const collateralDisplay = (Number(collateral) / (10 ** decimals)).toFixed(4);
    
    elaborateMessage = `⚖️ ${from} observed SETTLEMENT: ${tokenSymbol} settled with Entity ${counterpartyEntityId.slice(-4)}
📍 Block: ${blockNumber} | ⏰ ${timestamp} | 🔗 Tx: ${txHashShort}
🎯 Event: SettlementProcessed | 🔢 TokenID: ${tokenId} | 👤 Side: ${side}
💰 Own Reserve: ${ownBalanceDisplay} | 🤝 Counterparty: ${counterpartyBalanceDisplay}
🔒 Collateral: ${collateralDisplay} | 📊 OnDelta: ${ondelta}`;
  } else {
    elaborateMessage = `🔍 ${from} observed J-EVENT: ${event.type}
📍 Block: ${blockNumber} | ⏰ ${timestamp} | 🔗 Tx: ${txHashShort}
📋 Data: ${JSON.stringify(event.data, null, 2)}`;
  }
  
  newEntityState.messages.push(elaborateMessage);

  if (event.type === 'ReserveUpdated') {
    const { entity, tokenId, newBalance } = event.data;
    
    if (entity === entityState.entityId) {
      newEntityState.reserves.set(String(tokenId), BigInt(newBalance));
      if (DEBUG) console.log(`✅ Reserve updated for ${entity.slice(0,10)}...: Token ${tokenId} new balance is ${newBalance}`);
    }
  } else if (event.type === 'reserve_transferred') {
    const { tokenId, amount, direction } = event.data;
    
    // Update reserves based on transfer direction - entityState guaranteed by validation
    if (direction === 'sent') {
      const currentReserve = newEntityState.reserves.get(String(tokenId));
      if (currentReserve === undefined) {
        // Initialize reserve to 0n if not present (new token)
        newEntityState.reserves.set(String(tokenId), 0n);
        console.warn(`🔍 RESERVE-INIT: Initialized new token ${tokenId} reserve to 0n`);
      }
      const actualReserve = newEntityState.reserves.get(String(tokenId))!; // Now guaranteed to exist
      const newAmount = actualReserve - BigInt(amount);
      newEntityState.reserves.set(String(tokenId), newAmount >= 0n ? newAmount : 0n);
      // Message already added above
    } else if (direction === 'received') {
      const currentReserve = newEntityState.reserves.get(String(tokenId));
      if (currentReserve === undefined) {
        // Initialize reserve to 0n if not present (new token)
        newEntityState.reserves.set(String(tokenId), 0n);
        console.warn(`🔍 RESERVE-INIT: Initialized new token ${tokenId} reserve to 0n`);
      }
      const actualReserve = newEntityState.reserves.get(String(tokenId))!; // Now guaranteed to exist
      newEntityState.reserves.set(String(tokenId), actualReserve + BigInt(amount));
      // Message already added above
    }
    
    if (DEBUG) console.log(`✅ Reserve transfer processed: ${direction} ${amount} token ${tokenId}`);
  } else if (event.type === 'SettlementProcessed') {
    const { counterpartyEntityId, tokenId, ownReserve, counterpartyReserve, collateral, ondelta, side } = event.data;
    
    // Update own reserves based on the settlement
    newEntityState.reserves.set(String(tokenId), BigInt(ownReserve));
    
    // Create accountInput to feed into a-machine for bilateral consensus
    // This enables the settlement event to be processed by the account machine
    const accountInput = {
      fromEntityId: entityState.entityId,
      toEntityId: counterpartyEntityId,
      accountTx: {
        type: 'account_settle' as const,
        data: {
          tokenId: Number(tokenId),
          ownReserve: ownReserve,
          counterpartyReserve: counterpartyReserve,
          collateral: collateral,
          ondelta: ondelta,
          side: side,
          blockNumber: blockNumber,
          transactionHash: transactionHash
        }
      },
      metadata: {
        purpose: 'settlement_consensus',
        description: `Settlement event from j-machine for token ${tokenId}`
      }
    };
    
    // Add to entity's account inputs queue for processing
    // This will be processed by the account handler to update bilateral account state
    if (!newEntityState.accountInputQueue) {
      newEntityState.accountInputQueue = [];
    }
    newEntityState.accountInputQueue.push(accountInput);
    
    if (DEBUG) console.log(`✅ SettlementProcessed: Created accountInput for token ${tokenId} with counterparty ${counterpartyEntityId.slice(0,10)}...`);
  } else {
    newEntityState.messages.push(`⚠️ Unhandled j-event type: ${event.type}`);
  }

  return newEntityState;
};

--- src/entity-tx/index.ts ---
export * from './apply';
export * from './financial';
export * from './handlers/account';
export * from './j-events';
export * from './proposals';
export * from './validation';

--- src/entity-tx/handlers/account.ts ---
import { AccountInput, EntityState, Env, EntityInput } from '../../types';
import { handleAccountInput as processAccountInput } from '../../account-consensus';
import { cloneEntityState } from '../../state-helpers';
import { formatEntityId } from '../../entity-helpers';
import { createDemoDelta, getDefaultCreditLimit } from '../../account-utils';

export async function handleAccountInput(state: EntityState, input: AccountInput, env: Env): Promise<{ newState: EntityState; outputs: EntityInput[] }> {
  console.log(`🚀 APPLY accountInput: ${input.fromEntityId} → ${input.toEntityId}`, input.accountTx);

  // Create immutable copy of current state
  const newState: EntityState = cloneEntityState(state);
  const outputs: EntityInput[] = [];

  // Add chat message about receiving account input
  if (input.accountTx && input.accountTx.type) {
    newState.messages.push(`📨 Received ${input.accountTx.type} from Entity ${input.fromEntityId.slice(-4)}`);
  } else if (!input.accountTx) {
    console.warn(`⚠️ Received accountInput without accountTx from ${input.fromEntityId}`);
    newState.messages.push(`📨 Received account request from Entity ${input.fromEntityId.slice(-4)}`);
  }

  // Get or create account machine for this counterparty (fromEntityId is who we're creating an account WITH)
  let accountMachine = newState.accounts.get(input.fromEntityId);
  if (!accountMachine) {
    // Initialize with default USDC delta showing credit limits (no collateral initially)
    const initialDeltas = new Map();
    initialDeltas.set(2, createDemoDelta(2, 0n, 0n));

    accountMachine = {
      counterpartyEntityId: input.fromEntityId,
      mempool: [],
      currentFrame: {
        frameId: 0,
        timestamp: Date.now(),
        tokenIds: [],
        deltas: [],
      },
      sentTransitions: 0,
      ackedTransitions: 0,
      deltas: initialDeltas,
      globalCreditLimits: {
        ownLimit: getDefaultCreditLimit(2),
        peerLimit: getDefaultCreditLimit(2),
      },
      // Frame-based consensus fields
      currentFrameId: 0,
      pendingSignatures: [],
      rollbackCount: 0,
      // CHANNEL.TS REFERENCE: Proper message counters (NOT timestamps!)
      sendCounter: 0,    // Like Channel.ts line 131
      receiveCounter: 0, // Like Channel.ts line 132
      // Removed isProposer - use isLeft() function like old_src Channel.ts
      proofHeader: {
        fromEntity: state.entityId,
        toEntity: input.fromEntityId,  // Fixed: should be fromEntityId
        cooperativeNonce: 0,
        disputeNonce: 0,
      },
      proofBody: {
        tokenIds: [1, 2, 3],
        deltas: [0n, -100n, 50n],
      },
      frameHistory: [] // Initialize empty frame history
    };
    newState.accounts.set(input.fromEntityId, accountMachine);  // Fixed: use fromEntityId as key
    console.log(`💳 Created new account machine for counterparty ${input.fromEntityId}`);
  }

  // FINTECH-SAFETY: Ensure accountMachine exists after creation/retrieval
  if (!accountMachine) {
    throw new Error(`CRITICAL: AccountMachine creation failed for ${input.fromEntityId}`);
  }

  // Process the account transaction immediately based on type
  if (input.accountTx && input.accountTx.type === 'account_payment' && input.accountTx.data.amount === 0n) {
    // Handle incoming account opening (account_payment with 0 amount indicates account opening)
    console.log(`💳 Received account opening request from Entity ${input.fromEntityId.slice(-4)}`);

    // Account already created above, just acknowledge
    newState.messages.push(`✅ Account opened with Entity ${formatEntityId(input.fromEntityId)}`);
    console.log(`💳 Account established with Entity ${input.fromEntityId.slice(-4)}`);

    // No need to send a response - accounts are symmetric
    // Both sides create their account independently
  } else if (input.accountTx && input.accountTx.type === 'account_settle') {
    // Process settlement event from blockchain
    const settleData = input.accountTx.data;
    const tokenId = settleData.tokenId;

    console.log(`💰 Processing settlement for token ${tokenId}:`, settleData);

    // Get or create delta for this token
    let delta = accountMachine.deltas.get(tokenId);
    if (!delta) {
      delta = createDemoDelta(tokenId, 0n, 0n);
      accountMachine.deltas.set(tokenId, delta);
    }

    // Update delta with settlement data
    delta.collateral = BigInt(settleData.collateral);
    delta.ondelta = BigInt(settleData.ondelta);

    console.log(`💰 Updated delta for token ${tokenId}:`, {
      tokenId: delta.tokenId,
      collateral: delta.collateral.toString(),
      ondelta: delta.ondelta.toString(),
      offdelta: delta.offdelta.toString(),
    });

    // Update current frame with new settlement
    const frameTokenIds = accountMachine.currentFrame.tokenIds;
    const frameDeltas = [...accountMachine.currentFrame.deltas];

    const tokenIndex = frameTokenIds.indexOf(tokenId);
    if (tokenIndex >= 0) {
      // Update existing token in frame
      frameDeltas[tokenIndex] = delta.ondelta + delta.offdelta;
    } else {
      // Add new token to frame
      frameTokenIds.push(tokenId);
      frameDeltas.push(delta.ondelta + delta.offdelta);
    }

    accountMachine.currentFrame = {
      frameId: accountMachine.currentFrame.frameId + 1,
      timestamp: Date.now(),
      tokenIds: frameTokenIds,
      deltas: frameDeltas,
    };

    // Add chat message about the settlement
    const message = `💰 Settlement processed: Token ${tokenId}, Collateral ${settleData.collateral}, OnDelta ${settleData.ondelta}`;
    newState.messages.push(message);

    console.log(`✅ Settlement processed for Entity ${input.toEntityId.slice(-4)}, Token ${tokenId}`);
  } else if (input.frameId || input.newAccountFrame) {
    // Handle frame-level consensus using production account-consensus system
    console.log(`🤝 Processing frame-level AccountInput from ${input.fromEntityId.slice(-4)}`);

    const result = processAccountInput(accountMachine, input);

    if (result.success) {
      // Add events to entity messages
      newState.messages.push(...result.events);

      // If there's a response, queue it for sending back
      if (result.response) {
        console.log(`📤 Sending AccountInput ACK back to ${result.response.toEntityId.slice(-4)}`);

        // Get the proposer of the target entity
        let targetProposerId = 'alice'; // Default fallback
        const targetReplicaKeys = Array.from(env.replicas.keys()).filter(key => key.startsWith((result.response?.toEntityId || '') + ':'));
        if (targetReplicaKeys.length > 0) {
          const firstTargetReplica = env.replicas.get(targetReplicaKeys[0]!);
          if (firstTargetReplica?.state.config.validators[0]) {
            targetProposerId = firstTargetReplica.state.config.validators[0];
          }
        }

        // Create output to send ACK back to counterparty
        outputs.push({
          entityId: result.response?.toEntityId || '',
          signerId: targetProposerId,
          entityTxs: [{
            type: 'accountInput',
            data: result.response
          }]
        });

        console.log(`✅ ACK queued for Entity ${result.response.toEntityId.slice(-4)}`);
      }
    } else {
      console.log(`❌ Frame consensus failed: ${result.error}`);
      newState.messages.push(`❌ Frame consensus failed with Entity ${input.fromEntityId.slice(-4)}: ${result.error}`);
    }
  } else if (input.accountTx) {
    // Special handling for direct_payment - needs to be forwarded
    if (input.accountTx && input.accountTx.type === 'direct_payment') {
      const paymentData = input.accountTx.data;
      console.log(`💸 Processing direct_payment relay: route=${paymentData.route}, amount=${paymentData.amount}`);

      // Check if we're the final destination
      if (!paymentData.route || paymentData.route.length === 0) {
        // We are the final destination - payment complete!
        newState.messages.push(`💰 Received payment: ${paymentData.amount} (token ${paymentData.tokenId}) - ${paymentData.description}`);
        console.log(`✅ Payment received at final destination`);
        // IMPORTANT: Do NOT add to mempool - payment is already in the frame being processed
        // The frame consensus already handled this transaction
      } else if (paymentData.route.length === 1 && paymentData.route[0] === state.entityId) {
        // Route contains only us - we're the destination
        newState.messages.push(`💰 Received payment: ${paymentData.amount} (token ${paymentData.tokenId}) - ${paymentData.description}`);
        console.log(`✅ Payment received at final destination (single hop)`);
        // IMPORTANT: Do NOT add to mempool - payment is already in the frame being processed
        // The frame consensus already handled this transaction
      } else {
        // We need to forward the payment to the next hop
        const nextHop = paymentData.route[0];
        const remainingRoute = paymentData.route.slice(1);

        console.log(`💸 Forwarding payment to next hop: ${nextHop}, remaining route: ${remainingRoute}`);

        // Check if we have an account with next hop
        if (!nextHop || !newState.accounts.has(nextHop)) {
          console.error(`❌ Cannot forward payment: No account with ${nextHop}`);
          newState.messages.push(`❌ Payment routing failed: No account with Entity ${nextHop?.slice(-4) || 'unknown'}`);
        } else {
          // Create forwarded payment AccountTx
          const forwardedPayment = {
            type: 'direct_payment' as const,
            data: {
              tokenId: paymentData.tokenId,
              amount: paymentData.amount,
              route: remainingRoute,
              ...(paymentData.description ? { description: paymentData.description } : {}),
              fromEntityId: state.entityId,
              toEntityId: nextHop,
            },
          };

          // Add to mempool for the next hop account
          const nextHopAccount = newState.accounts.get(nextHop);
          if (nextHopAccount) {
            nextHopAccount.mempool.push(forwardedPayment);
            newState.messages.push(`⚡ Relaying payment to Entity ${nextHop?.slice(-4)} (${remainingRoute.length} hops remaining)`);
            console.log(`📤 Payment forwarded to ${nextHop} account mempool`);
          }
        }
      }
    } else if (input.accountTx) {
      // Handle other transaction types
      // IMPORTANT: Do NOT add incoming transactions to our mempool
      // The transactions will be processed when they arrive in a frame
      console.log(`📥 Received ${input.accountTx.type} from ${input.fromEntityId.slice(-4)} - will be processed in next frame`);

      // Just acknowledge receipt - don't add to mempool
      newState.messages.push(`📨 Received ${input.accountTx.type} from Entity ${input.fromEntityId.slice(-4)}`);
    }
  }

  return { newState, outputs };
}

--- src/name-resolution.ts ---
/**
 * Name Resolution & Profile Management System
 *
 * Combines basic name registry with gossip layer for profile storage.
 * Includes autocomplete functionality and hanko-signed profile updates.
 */

import { EntityProfile, EntityTx, Env, NameIndex, NameSearchResult, ProfileUpdateTx } from './types';
import { formatEntityDisplay, generateEntityAvatar } from './utils';

// === PROFILE STORAGE ===

/**
 * Store entity profile in gossip layer
 */
export const storeProfile = async (db: any, profile: EntityProfile): Promise<void> => {
  if (!db) {
    console.warn('Database not available for profile storage');
    return;
  }

  try {
    // Store profile
    await db.put(`profile:${profile.entityId}`, JSON.stringify(profile));

    // Update name index for autocomplete
    await updateNameIndex(db, profile.name, profile.entityId);

    console.log(`📝 Stored profile for ${profile.name} (${formatEntityDisplay(profile.entityId)})`);
  } catch (error) {
    console.error('Error storing profile:', error);
  }
};

/**
 * Get entity profile from gossip layer
 */
export const getProfile = async (db: any, entityId: string): Promise<EntityProfile | null> => {
  if (!db) return null;

  try {
    const data = await db.get(`profile:${entityId}`);
    return JSON.parse(data) as EntityProfile;
  } catch (error) {
    // Profile doesn't exist - return null
    return null;
  }
};

/**
 * Update name index for autocomplete
 */
const updateNameIndex = async (db: any, name: string, entityId: string): Promise<void> => {
  try {
    // Get existing index
    let nameIndex: NameIndex = {};
    try {
      const data = await db.get('name-index');
      nameIndex = JSON.parse(data);
    } catch {
      // Index doesn't exist yet
    }

    // Update index
    nameIndex[name.toLowerCase()] = entityId;

    // Store updated index
    await db.put('name-index', JSON.stringify(nameIndex));
  } catch (error) {
    console.error('Error updating name index:', error);
  }
};

// === AUTOCOMPLETE SYSTEM ===

/**
 * Search entity names with autocomplete
 */
export const searchEntityNames = async (db: any, query: string, limit: number = 10): Promise<NameSearchResult[]> => {
  if (!db || !query.trim()) return [];

  try {
    // Get name index
    const data = await db.get('name-index');
    const nameIndex: NameIndex = JSON.parse(data);

    const queryLower = query.toLowerCase();
    const results: NameSearchResult[] = [];

    // Search through names
    for (const [name, entityId] of Object.entries(nameIndex)) {
      if (name.includes(queryLower)) {
        // Calculate relevance score
        let relevance = 0;
        if (name.startsWith(queryLower)) {
          relevance = 1.0; // Exact prefix match
        } else if (name.includes(queryLower)) {
          relevance = 0.7; // Contains query
        }

        // Get avatar (generated or custom)
        const profile = await getProfile(db, entityId);
        const avatar = profile?.avatar || generateEntityAvatar(entityId);

        results.push({
          entityId,
          name: profile?.name || formatEntityDisplay(entityId),
          avatar,
          relevance,
        });
      }
    }

    // Sort by relevance and name
    results.sort((a, b) => {
      if (a.relevance !== b.relevance) {
        return b.relevance - a.relevance; // Higher relevance first
      }
      return a.name.localeCompare(b.name); // Alphabetical
    });

    return results.slice(0, limit);
  } catch (error) {
    console.error('Error searching entity names:', error);
    return [];
  }
};

// === PROFILE UPDATES VIA CONSENSUS ===

/**
 * Create profile update transaction
 */
export const createProfileUpdateTx = (updates: ProfileUpdateTx): EntityTx => {
  return {
    type: 'profile-update' as const,
    data: updates, // Remove unsafe type assertion
  } as EntityTx;
};

/**
 * Process profile update transaction
 */
export const processProfileUpdate = async (
  db: any,
  entityId: string,
  updates: ProfileUpdateTx,
  hankoSignature: string,
  env?: Env,
): Promise<void> => {
  console.log(`🏷️ processProfileUpdate called for ${entityId} with updates:`, updates);
  try {
    // Get existing profile or create new one
    let profile = await getProfile(db, entityId);

    if (!profile) {
      // Create new profile with defaults
      profile = {
        entityId,
        name: formatEntityDisplay(entityId), // Default to formatted entity ID
        lastUpdated: Date.now(),
        hankoSignature,
      };
    }

    // Apply updates
    if (updates.name !== undefined) profile.name = updates.name;
    if (updates.avatar !== undefined) profile.avatar = updates.avatar;
    if (updates.bio !== undefined) profile.bio = updates.bio;
    if (updates.website !== undefined) profile.website = updates.website;

    // Update metadata
    profile.lastUpdated = Date.now();
    profile.hankoSignature = hankoSignature;

    // Sync to gossip layer FIRST (before storing) to ensure it's captured in snapshots
    if (env?.gossip?.announce) {
      try {
        env.gossip.announce({
          entityId,
          capabilities: [], // ProfileUpdateTx doesn't include capabilities - use empty default
          hubs: [], // ProfileUpdateTx doesn't include hubs - use empty default
          metadata: {
            name: profile.name,
            avatar: profile.avatar,
            bio: profile.bio,
            website: profile.website,
            lastUpdated: profile.lastUpdated,
            hankoSignature: profile.hankoSignature,
          },
        });
        console.log(`📡 Synced profile update to gossip: ${entityId}`);
      } catch (gossipError) {
        console.error(`❌ Failed to sync profile to gossip layer for ${entityId}:`, gossipError);
      }
    }

    // Store updated profile to database after gossip sync
    await storeProfile(db, profile);

    console.log(`✅ Updated profile for ${profile.name} (${formatEntityDisplay(entityId)})`);
  } catch (error) {
    console.error('Error processing profile update:', error);
  }
};
// === NAME RESOLUTION HELPERS ===

/**
 * Resolve entity ID to display name
 */
export const resolveEntityName = async (db: any, entityId: string): Promise<string> => {
  const profile = await getProfile(db, entityId);
  return profile?.name || formatEntityDisplay(entityId);
};

/**
 * Get entity display info (name + avatar)
 */
export const getEntityDisplayInfo = async (db: any, entityId: string): Promise<{ name: string; avatar: string }> => {
  const profile = await getProfile(db, entityId);
  return {
    name: profile?.name || formatEntityDisplay(entityId),
    avatar: profile?.avatar || generateEntityAvatar(entityId),
  };
};

--- src/serialization-utils.ts ---
/**
 * BigInt-safe serialization utilities
 * Handles JSON serialization with BigInt values across the XLN codebase
 */

/**
 * Converts BigInt values to strings for JSON serialization
 * @param key - JSON key
 * @param value - JSON value
 * @returns Serializable value
 */
export function bigIntReplacer(_key: string, value: any): any {
  if (typeof value === 'bigint') {
    return `BigInt(${value.toString()})`;
  }
  // Handle Map objects
  if (value instanceof Map) {
    return Object.fromEntries(value);
  }
  // Handle Set objects
  if (value instanceof Set) {
    return Array.from(value);
  }
  // Handle Buffer objects
  if (value && typeof value === 'object' && value.type === 'Buffer' && Array.isArray(value.data)) {
    return `Buffer(${value.data.length} bytes)`;
  }
  // Handle Functions
  if (typeof value === 'function') {
    return `[Function: ${value.name || 'anonymous'}]`;
  }
  return value;
}

/**
 * BigInt-safe JSON.stringify replacement
 * @param obj - Object to stringify
 * @param space - Formatting space (optional)
 * @returns JSON string
 */
export function safeStringify(obj: any, space?: number): string {
  try {
    return JSON.stringify(obj, bigIntReplacer, space);
  } catch (err) {
    return `[Error stringifying: ${(err as Error).message}]`;
  }
}

/**
 * BigInt-safe console logging for debugging
 * @param message - Log message
 * @param obj - Object to log (optional)
 */
export function safeLog(message: string, obj?: any): void {
  if (obj !== undefined) {
    console.log(message, safeStringify(obj, 2));
  } else {
    console.log(message);
  }
}

/**
 * Parse BigInt strings back to BigInt values
 * @param key - JSON key
 * @param value - JSON value
 * @returns Parsed value with BigInt restored
 */
export function bigIntReviver(_key: string, value: any): any {
  if (typeof value === 'string' && value.startsWith('BigInt(') && value.endsWith(')')) {
    const bigintStr = value.slice(7, -1); // Remove 'BigInt(' and ')'
    return BigInt(bigintStr);
  }
  return value;
}

/**
 * BigInt-safe JSON.parse replacement
 * @param jsonString - JSON string to parse
 * @returns Parsed object with BigInt values restored
 */
export function safeParse(jsonString: string): any {
  try {
    return JSON.parse(jsonString, bigIntReviver);
  } catch (err) {
    throw new Error(`Failed to parse JSON: ${(err as Error).message}`);
  }
}

/**
 * Universal Buffer comparison (works in both Node.js and browser)
 * @param buf1 - First buffer
 * @param buf2 - Second buffer
 * @returns 0 if equal, -1 if buf1 < buf2, 1 if buf1 > buf2
 */
export function bufferCompare(buf1: Buffer, buf2: Buffer): number {
  if (typeof Buffer !== 'undefined' && Buffer.compare) {
    // Node.js environment
    return Buffer.compare(buf1, buf2);
  } else {
    // Browser environment - compare as hex strings
    const hex1 = buf1.toString('hex');
    const hex2 = buf2.toString('hex');
    if (hex1 === hex2) return 0;
    return hex1 < hex2 ? -1 : 1;
  }
}

/**
 * Universal Buffer equality check
 * @param buf1 - First buffer
 * @param buf2 - Second buffer
 * @returns true if buffers are equal
 */
export function buffersEqual(buf1: Buffer, buf2: Buffer): boolean {
  return bufferCompare(buf1, buf2) === 0;
}
--- src/test-hanko-basic.ts ---
/**
 * Basic Hanko tests - stub implementation
 */

export async function runBasicHankoTests(): Promise<boolean> {
  console.log('🔍 Running basic Hanko tests...');

  // TODO: Implement actual Hanko tests
  console.log('  ✅ Placeholder test passed');

  return true;
}
--- src/snapshot-coder.ts ---
/**
 * Unified encoder/decoder for snapshots with configurable JSON/msgpack methods.
 * Set USE_MSGPACK = true for msgpack with integrity hashing, false for simple JSON.
 */

// Configuration flag - change this to test different encoders
const USE_MSGPACK = false;

// JSON encoder imports and setup
const jsonReplacer = (key: string, value: any) => {
  if (key === 'clonedForValidation') {
    return undefined;
  }
  if (value instanceof Map) {
    return { _dataType: 'Map', value: Array.from(value.entries()) };
  }
  if (typeof value === 'bigint') {
    return { _dataType: 'BigInt', value: value.toString() };
  }
  return value;
};

const jsonReviver = (_key: string, value: any) => {
  if (typeof value === 'object' && value !== null) {
    if (value._dataType === 'Map') return new Map(value.value);
    if (value._dataType === 'BigInt') return BigInt(value.value);
  }
  return value;
};

// Msgpack encoder setup - lazy initialization to avoid browser issues
let packr: any = null;
let sha256: any = null;

// Lazy initialization function for msgpack
const initMsgpack = async () => {
  if (packr) return packr; // Already initialized

  try {
    const { Packr } = await import('msgpackr');
    const { createHash } = await import('./utils.js');

    sha256 = (data: Buffer): Buffer => createHash('sha256').update(data).digest();

    packr = new Packr({
      structures: [[BigInt, (value: bigint) => value.toString(), (str: string) => BigInt(str)]],
    });

    return packr;
  } catch (error) {
    console.warn('Failed to load msgpack dependencies:', error);
    throw error;
  }
};

/**
 * Recursively traverses an object and converts any Map instances into
 * arrays of [key, value] pairs, sorted by key. This is essential for
 * ensuring that serialization is deterministic.
 */
function deterministicDeepSort(obj: any): any {
  if (obj instanceof Map) {
    const entries = Array.from(obj.entries());
    // Sort entries by key to ensure deterministic output.
    entries.sort((a, b) => (a[0] < b[0] ? -1 : 1));
    // Recursively process values in case they contain Maps.
    return entries.map(([k, v]) => [k, deterministicDeepSort(v)]);
  }
  if (Array.isArray(obj)) {
    return obj.map(deterministicDeepSort);
  }
  if (typeof obj === 'object' && obj !== null) {
    const newObj: { [key: string]: any } = {};
    const sortedKeys = Object.keys(obj).sort();
    for (const key of sortedKeys) {
      newObj[key] = deterministicDeepSort(obj[key]);
    }
    return newObj;
  }
  return obj;
}

/**
 * Reconstructs Map objects from the key-sorted arrays created by deterministicDeepSort.
 * This is the reverse operation used during deserialization.
 */
function reconstructMaps(obj: any): any {
  if (Array.isArray(obj)) {
    // Check if it's a key-value pair array that should be a Map
    const isMapArray = obj.every(item => Array.isArray(item) && item.length === 2);
    if (isMapArray) {
      return new Map(obj.map(([k, v]) => [k, reconstructMaps(v)]));
    }
    return obj.map(reconstructMaps);
  }
  if (typeof obj === 'object' && obj !== null) {
    const newObj: { [key: string]: any } = {};
    for (const key in obj) {
      newObj[key] = reconstructMaps(obj[key]);
    }
    return newObj;
  }
  return obj;
}

// Define the structure of the persisted tuple for msgpack format
type SnapshotTuple = [
  number, // height
  any, // serverInput
  Buffer, // hashOfSerializedReplicas
  any, // deterministically sorted replicas
];

/**
 * Encodes data using the configured method (JSON or msgpack)
 */
export const encode = (data: any): Buffer => {
  // CRITICAL: Validate financial state before encoding
  if (data && data.replicas) {
    console.log(`🔍 ENCODE-VALIDATION: Checking ${data.replicas.size} replicas for jBlock integrity`);
    for (const [replicaKey, replica] of data.replicas.entries()) {
      console.log(`🔍 ENCODE-CHECK: Replica ${replicaKey} exists: ${!!replica}, state exists: ${!!replica?.state}`);
      if (replica && replica.state) {
        const jBlock = replica.state.jBlock;
        console.log(`🔍 ENCODE-JBLOCK: ${replicaKey} jBlock=${jBlock} (${typeof jBlock})`);
        if (typeof jBlock !== 'number') {
          console.error(`💥 CRITICAL: Attempting to save invalid jBlock for replica ${replicaKey}`);
          console.error(`💥   Expected: number, Got: ${typeof jBlock}, Value: ${jBlock}`);
          console.error(`💥   AUTO-FIXING: Setting jBlock to 0 and continuing save`);
          replica.state.jBlock = 0; // Auto-repair corruption
        }
      }
    }
  }

  if (USE_MSGPACK) {
    // For msgpack mode, we need to use async initialization
    // This should not happen in current config (USE_MSGPACK = false)
    throw new Error('Msgpack mode requires async initialization - use encodeAsync instead');
  } else {
    // Simple JSON encoding
    return Buffer.from(JSON.stringify(data, jsonReplacer));
  }
};

/**
 * Decodes data using the configured method (JSON or msgpack)
 */
export const decode = (buffer: Buffer): any => {
  if (USE_MSGPACK) {
    // For msgpack mode, we need to use async initialization
    // This should not happen in current config (USE_MSGPACK = false)
    throw new Error('Msgpack mode requires async initialization - use decodeAsync instead');
  } else {
    // Simple JSON decoding
    const decoded = JSON.parse(buffer.toString(), jsonReviver);

    // CRITICAL: Validate financial state integrity after deserialization
    if (decoded && decoded.replicas) {
      for (const [replicaKey, replica] of decoded.replicas.entries()) {
        if (replica && replica.state) {
          const jBlock = replica.state.jBlock;
          if (typeof jBlock !== 'number') {
            // IMPORTANT: Don't reset to 0 - this causes re-processing of ALL events!
            // If jBlock is missing, use the snapshot height as a safe fallback
            const fallbackJBlock = Number(decoded.height) || 0;
            console.warn(`⚠️ jBlock missing for replica ${replicaKey}, using height ${fallbackJBlock} as fallback`);
            replica.state.jBlock = fallbackJBlock;
          }
        }
      }
    }

    return decoded;
  }
};

/**
 * Async version for msgpack encoding
 */
export const encodeAsync = async (data: any): Promise<Buffer> => {
  if (USE_MSGPACK) {
    const packrInstance = await initMsgpack();

    // Msgpack encoding with integrity hashing
    const sortedReplicas = deterministicDeepSort(data.replicas || new Map());
    const serializedReplicas = packrInstance.pack(sortedReplicas);
    const hashOfReplicas = sha256(serializedReplicas);

    const snapshotTuple: SnapshotTuple = [
      data.height || 0,
      deterministicDeepSort(data.serverInput || {}),
      hashOfReplicas,
      sortedReplicas,
    ];

    return packrInstance.pack(snapshotTuple);
  } else {
    // Fallback to sync JSON encoding
    return encode(data);
  }
};

/**
 * Async version for msgpack decoding
 */
export const decodeAsync = async (buffer: Buffer): Promise<any> => {
  if (USE_MSGPACK) {
    const packrInstance = await initMsgpack();

    // Msgpack decoding with integrity verification
    const decodedTuple = packrInstance.unpack(buffer) as SnapshotTuple;

    if (!Array.isArray(decodedTuple) || decodedTuple.length !== 4) {
      throw new Error('Invalid snapshot format: Expected a 4-element tuple.');
    }

    const [height, serverInput, hashOfReplicas, sortedReplicas] = decodedTuple;

    // Security/Integrity Check: Verify the hash of the replicas.
    const serializedReplicas = packrInstance.pack(sortedReplicas);
    const calculatedHash = sha256(serializedReplicas);
    // Browser-compatible buffer comparison
    if (hashOfReplicas.toString('hex') !== calculatedHash.toString('hex')) {
      throw new Error('State integrity check failed: Replica hash does not match.');
    }

    // Reconstruct the original object, converting sorted arrays back to Maps.
    const replicas = reconstructMaps(sortedReplicas);

    return {
      height,
      serverInput: reconstructMaps(serverInput),
      replicas,
      // Add timestamp for compatibility
      timestamp: Date.now(),
      // Note: gossip layer will be re-created by server on restore
    };
  } else {
    // Fallback to sync JSON decoding
    return decode(buffer);
  }
};

// Export the configuration flag for external use/testing
export { USE_MSGPACK };

--- src/hanko-real.ts ---
/**
 * 🎯 XLN Hanko Bytes - REAL Ethereum Implementation
 *
 * 🚨 CRITICAL DESIGN PHILOSOPHY: "ASSUME YES" FLASHLOAN GOVERNANCE 🚨
 *
 * This implementation INTENTIONALLY allows entities to mutually validate without EOA signatures.
 * This is NOT a bug - it's a feature for flexible governance structures.
 *
 * KEY DESIGN PRINCIPLES:
 * 1. ✅ Protocol flexibility: Allow exotic governance structures
 * 2. ✅ UI enforcement: Policy decisions belong in application layer
 * 3. ✅ Gas efficiency: Avoid complex graph traversal on-chain
 * 4. ✅ Atomic validation: All-or-nothing verification like flashloans
 *
 * EXAMPLE "LOOPHOLE" THAT IS INTENDED:
 * ```
 * EntityA: { threshold: 1, delegates: [EntityB] }
 * EntityB: { threshold: 1, delegates: [EntityA] }
 * Hanko: {
 *   placeholders: [],
 *   packedSignatures: "0x", // ZERO EOA signatures!
 *   claims: [
 *     { entityId: EntityA, entityIndexes: [1], weights: [100], threshold: 100 },
 *     { entityId: EntityB, entityIndexes: [0], weights: [100], threshold: 100 }
 *   ]
 * }
 * ```
 * Result: ✅ Both entities validate each other → Hanko succeeds!
 *
 * WHY THIS IS INTENDED:
 * - Real entities will include EOAs for practical control
 * - UI can enforce "at least 1 EOA" policies if desired
 * - Enables sophisticated delegation chains
 * - Alternative solutions are expensive and still gameable
 *
 * Uses actual secp256k1 signatures compatible with Solidity ecrecover
 */

import { ethers } from 'ethers';

import { HankoBytes, HankoClaim } from './types';
import { createHash, randomBytes } from './utils';

// Browser-compatible Buffer.concat replacement
const bufferConcat = (buffers: Buffer[]): Buffer => {
  if (typeof Buffer.concat === 'function') {
    return Buffer.concat(buffers);
  } else {
    // Browser fallback: manual concatenation
    const totalLength = buffers.reduce((sum, buf) => sum + buf.length, 0);
    const result = new Uint8Array(totalLength);
    let offset = 0;
    for (const buf of buffers) {
      result.set(buf, offset);
      offset += buf.length;
    }
    return Buffer.from(result);
  }
};

// Browser-compatible Buffer.alloc replacement
const bufferAlloc = (size: number, fill?: number): Buffer => {
  if (typeof Buffer.alloc === 'function') {
    return Buffer.alloc(size, fill);
  } else {
    // Browser fallback: create and fill manually
    const result = new Uint8Array(size);
    if (fill !== undefined) {
      result.fill(fill);
    }
    return Buffer.from(result);
  }
};

// === REAL ETHEREUM SIGNATURES ===

/**
 * Create REAL Ethereum signature using secp256k1
 */
export async function createRealSignature(hash: Buffer, privateKey: Buffer): Promise<Buffer> {
  try {
    // Create wallet from private key
    const wallet = new ethers.Wallet(ethers.hexlify(privateKey));

    // Sign the hash (ethers automatically prefixes with \x19Ethereum Signed Message)
    // For raw hash signing without prefix, we need to use wallet._signingKey
    const signature = await wallet.signMessage(ethers.getBytes(hash));

    // Parse signature components
    const sig = ethers.Signature.from(signature);

    // Convert to 65-byte format (r + s + v)
    const r = ethers.getBytes(sig.r);
    const s = ethers.getBytes(sig.s);
    const v = sig.v;

    // Ensure r and s are 32 bytes each
    const rPadded = new Uint8Array(32);
    const sPadded = new Uint8Array(32);
    rPadded.set(r, 32 - r.length);
    sPadded.set(s, 32 - s.length);

    return bufferConcat([Buffer.from(rPadded), Buffer.from(sPadded), Buffer.from([v])]);
  } catch (error) {
    console.error(`❌ Failed to create signature: ${error}`);
    throw error;
  }
};

/**
 * Create DIRECT hash signature (no message prefix)
 * This matches what Solidity ecrecover expects
 */
export const createDirectHashSignature = async (hash: Buffer, privateKey: Buffer): Promise<Buffer> => {
  try {

    // Sign the raw hash directly (no message prefix)
    const hashHex = ethers.hexlify(hash);

    // For direct hash signing, we need to use the signing key directly
    const signingKey = new ethers.SigningKey(ethers.hexlify(privateKey));
    const sig = signingKey.sign(hashHex);

    // Convert to Buffer format
    const r = ethers.getBytes(sig.r);
    const s = ethers.getBytes(sig.s);
    const v = sig.v;

    const rPadded = new Uint8Array(32);
    const sPadded = new Uint8Array(32);
    rPadded.set(r, 32 - r.length);
    sPadded.set(s, 32 - s.length);

    console.log(
      `🔑 Created signature: r=${ethers.hexlify(r).slice(0, 10)}..., s=${ethers.hexlify(s).slice(0, 10)}..., v=${v}`,
    );

    return bufferConcat([Buffer.from(rPadded), Buffer.from(sPadded), Buffer.from([v])]);
  } catch (error) {
    console.error(`❌ Failed to create direct hash signature: ${error}`);
    throw error;
  }
};

/**
 * Verify signature recovery works (for testing)
 */
export const verifySignatureRecovery = async (
  hash: Buffer,
  signature: Buffer,
  expectedAddress: string,
): Promise<boolean> => {
  try {
    // Extract components
    const r = ethers.hexlify(signature.slice(0, 32));
    const s = ethers.hexlify(signature.slice(32, 64));
    const v = signature[64];

    // Recover address (convert v to yParity for ethers v6)
    const yParity = (v! >= 27 ? v! - 27 : v!) as 0 | 1;
    const recoveredAddress = ethers.recoverAddress(ethers.hexlify(hash), { r, s, v: v!, yParity });

    const matches = recoveredAddress.toLowerCase() === expectedAddress.toLowerCase();
    console.log(
      `🔍 Recovery test: expected=${expectedAddress.slice(0, 10)}..., recovered=${recoveredAddress.slice(0, 10)}..., match=${matches}`,
    );

    return matches;
  } catch (error) {
    console.error(`❌ Failed to verify signature recovery: ${error}`);
    return false;
  }
};

// === SIGNATURE PACKING (Real Version) ===

export const packRealSignatures = (signatures: Buffer[]): Buffer => {
  console.log(`📦 Packing ${signatures.length} REAL signatures...`);

  if (signatures.length === 0) {
    return bufferAlloc(0);
  }

  // Validate all signatures are exactly 65 bytes
  for (let i = 0; i < signatures.length; i++) {
    if (!signatures[i] || signatures[i]!.length !== 65) {
      throw new Error(`Invalid signature ${i}: ${signatures[i]?.length || 0} bytes (expected 65)`);
    }

    const v = signatures[i]![64];
    if (v !== 27 && v !== 28) {
      throw new Error(`Invalid v value in signature ${i}: ${v} (expected 27 or 28)`);
    }
  }

  // Pack R,S values
  const rsValues = bufferAlloc(signatures.length * 64);
  let rsOffset = 0;

  for (const sig of signatures) {
    // Browser-compatible copy: extract R,S (first 64 bytes) and copy to rsValues
    const rsBytes = sig.slice(0, 64);
    rsValues.set(rsBytes, rsOffset);
    rsOffset += 64;
  }

  // Pack V values as bits
  const vBytesNeeded = Math.ceil(signatures.length / 8);
  const vValues = bufferAlloc(vBytesNeeded);

  for (let i = 0; i < signatures.length; i++) {
    const vByte = signatures[i]![64];
    const byteIndex = Math.floor(i / 8);
    const bitIndex = i % 8;

    if (vByte === 28) {
      vValues[byteIndex]! |= 1 << bitIndex;
    }
  }

  const packed = bufferConcat([rsValues, vValues]);
  console.log(`✅ Packed ${signatures.length} real signatures: ${packed.length} bytes`);

  return packed;
};

// === SIGNATURE DETECTION AND PACKING ===

/**
 * Detect signature count from packed signatures length
 */
export const detectSignatureCount = (packedSignatures: Buffer): number => {
  if (packedSignatures.length === 0) return 0;

  // Try different signature counts until we find the right one
  // Formula: length = count * 64 + ceil(count / 8)
  for (let count = 1; count <= 16000; count++) {
    const expectedRSBytes = count * 64;
    const expectedVBytes = Math.ceil(count / 8);
    const expectedTotal = expectedRSBytes + expectedVBytes;

    if (packedSignatures.length === expectedTotal) {
      console.log(`🔍 Detected ${count} signatures from ${packedSignatures.length} bytes`);
      return count;
    }

    // Early exit if we've exceeded possible length
    if (expectedTotal > packedSignatures.length) {
      break;
    }
  }

  throw new Error(`Invalid packed signature length: ${packedSignatures.length} bytes - cannot detect count`);
};

export const unpackRealSignatures = (packedSignatures: Buffer): Buffer[] => {
  const signatureCount = detectSignatureCount(packedSignatures);
  console.log(`📦 Unpacking ${signatureCount} REAL signatures...`);

  if (signatureCount === 0) return [];

  const expectedRSBytes = signatureCount * 64;
  const expectedVBytes = Math.ceil(signatureCount / 8);
  const expectedTotal = expectedRSBytes + expectedVBytes;

  if (packedSignatures.length !== expectedTotal) {
    throw new Error(`Invalid packed signature length: ${packedSignatures.length} (expected ${expectedTotal})`);
  }

  const rsValues = packedSignatures.slice(0, expectedRSBytes);
  const vValues = packedSignatures.slice(expectedRSBytes);
  const signatures: Buffer[] = [];

  for (let i = 0; i < signatureCount; i++) {
    const rs = rsValues.slice(i * 64, (i + 1) * 64);

    const byteIndex = Math.floor(i / 8);
    const bitIndex = i % 8;
    const vBit = (vValues[byteIndex]! >> bitIndex) & 1;
    const vByte = vBit === 0 ? 27 : 28;

    const signature = bufferConcat([rs, Buffer.from([vByte])]);
    signatures.push(signature);
  }

  console.log(`✅ Unpacked ${signatures.length} real signatures`);
  return signatures;
};

// === REAL HANKO BUILDING ===

/**
 * 💡 WHY WE DON'T TRACK SIGNATURE USAGE (Response to Junior's Concern)
 *
 * Question: "How do you ensure signatures are actually used in claims?"
 *
 * ANSWER: We intentionally DON'T track this because:
 *
 * 1. 🔄 CIRCULAR REFERENCE PROBLEM:
 *    EntityA → EntityB → EntityA means neither "uses" direct signatures
 *    But this is VALID hierarchical governance we want to support
 *
 * 2. 💰 GAS COST EXPLOSION:
 *    Tracking would require O(n²) analysis of claim dependency graphs
 *    Current approach: O(n) sequential processing with assumptions
 *
 * 3. 🎯 STILL GAMEABLE:
 *    Even with tracking, attacker can include "decoy" signatures:
 *    - Add 1 real signature that IS referenced by some claim
 *    - Add circular claims that don't use that signature
 *    - System still validates circular parts independently
 *
 * 4. 🛡️  PROTOCOL VS POLICY:
 *    Protocol provides flexible primitive
 *    UI/Application enforces business rules (e.g., "require EOA in root")
 *
 * EXAMPLE WHY TRACKING FAILS:
 * ```
 * packedSignatures: [RealSig1]  // ← Used by ClaimC
 * claims: [
 *   ClaimA: refs ClaimB,    // ← Circular validation
 *   ClaimB: refs ClaimA,    // ← Still works without RealSig1!
 *   ClaimC: refs RealSig1   // ← Uses the signature
 * ]
 * ```
 * Tracking would say "✅ RealSig1 is used" but ClaimA/B still validate circularly.
 */
export const buildRealHanko = async (
  hashToSign: Buffer,
  config: {
    noEntities: Buffer[];
    privateKeys: Buffer[]; // Real private keys
    claims: {
      entityId: Buffer;
      entityIndexes: number[];
      weights: number[];
      threshold: number;
      expectedQuorumHash: Buffer;
    }[];
  },
): Promise<HankoBytes> => {
  console.log(`🖋️  Building REAL hanko: ${config.claims.length} claims, ${config.privateKeys.length} signatures`);

  // Create REAL Ethereum signatures
  const signatures: Buffer[] = [];
  const signerAddresses: string[] = [];

  for (let i = 0; i < config.privateKeys.length; i++) {
    const privateKey = config.privateKeys[i]!;

    // Get the address for this private key
    const wallet = new ethers.Wallet(ethers.hexlify(privateKey));
    signerAddresses.push(wallet.address);

    console.log(`🔑 Signing with key ${i + 1}/${config.privateKeys.length}: ${wallet.address.slice(0, 10)}...`);

    // Create real signature
    const signature = await createDirectHashSignature(hashToSign!, privateKey);
    signatures.push(signature);

    // Verify the signature works
    const verifySuccess = await verifySignatureRecovery(hashToSign!, signature, wallet.address);
    if (!verifySuccess) {
      throw new Error(`Signature verification failed for key ${i}`);
    }
  }

  // Pack signatures
  const packedSignatures = packRealSignatures(signatures);

  // Build claims
  const claims: HankoClaim[] = config.claims.map(claim => ({
    entityId: claim.entityId,
    entityIndexes: claim.entityIndexes,
    weights: claim.weights,
    threshold: claim.threshold,
    expectedQuorumHash: claim.expectedQuorumHash,
  }));

  const hanko: HankoBytes = {
    placeholders: config.noEntities, // Failed entities (index 0..N-1)
    packedSignatures, // EOA signatures (index N..M-1)
    claims, // Entity claims (index M..∞)
  };

  console.log(`✅ Built REAL hanko with verifiable signatures`);
  console.log(`   📋 Signers: ${signerAddresses.map(addr => addr.slice(0, 10) + '...').join(', ')}`);
  console.log(`   📊 Signature count: ${signatures.length} (detected from length)`);

  return hanko;
};

/**
 * 🔥 FLASHLOAN GOVERNANCE SIMULATION - "ASSUME YES" in TypeScript
 *
 * This function mirrors the Solidity flashloan governance logic on the client side.
 * Used for gas optimization: pre-recover entities to avoid on-chain signature recovery.
 *
 * CRITICAL: This implements the SAME optimistic assumptions as Solidity:
 * - When claim X references claim Y, we assume Y = YES regardless of verification order
 * - If ANY claim later fails its threshold → entire validation should fail
 * - Enables circular references to mutually validate (INTENDED behavior)
 *
 * EXAMPLE CIRCULAR VALIDATION:
 * Claims: [
 *   { entityId: A, entityIndexes: [3], weights: [100], threshold: 100 }, // refs claim 1 (B)
 *   { entityId: B, entityIndexes: [2], weights: [100], threshold: 100 }  // refs claim 0 (A)
 * ]
 *
 * Processing:
 * 1. Claim 0: Assume B=YES → 100 ≥ 100 → A passes ✅
 * 2. Claim 1: Assume A=YES → 100 ≥ 100 → B passes ✅
 * 3. Both entities added to yesEntities → circular validation succeeds!
 *
 * Recover hanko signatures and return processed entities (for gas optimization)
 */
export const recoverHankoEntities = async (
  hanko: HankoBytes,
  hash: Buffer,
): Promise<{
  yesEntities: Buffer[];
  noEntities: Buffer[];
  claims: HankoClaim[];
}> => {
  console.log('🔍 Recovering hanko entities with flashloan governance...');

  // Step 1: Unpack and recover signatures
  const signatures = unpackRealSignatures(hanko.packedSignatures);
  const yesEntities: Buffer[] = [];

  for (let i = 0; i < signatures.length; i++) {
    try {
      // Use ethers to recover the signer address
      const sig = signatures[i]!;
      const r = ethers.hexlify(sig.slice(0, 32));
      const s = ethers.hexlify(sig.slice(32, 64));
      const v = sig[64];

      const yParity = (v! >= 27 ? v! - 27 : v!) as 0 | 1;
      const recoveredAddress = ethers.recoverAddress(ethers.hexlify(hash), { r, s, v: v!, yParity });

      // Convert address to bytes32 (same format as Solidity)
      const addressAsBytes32 = Buffer.from(ethers.zeroPadValue(recoveredAddress, 32).slice(2), 'hex');

      yesEntities.push(addressAsBytes32);
      console.log(`✅ Recovered signer ${i + 1}: ${recoveredAddress.slice(0, 10)}...`);
    } catch (error) {
      console.log(`❌ Failed to recover signature ${i + 1}: ${error}`);
    }
  }

  // Step 2: 🔥 FLASHLOAN GOVERNANCE - optimistically assume all claims pass
  //
  // 🚨 KEY INSIGHT: We process claims sequentially but assume ALL future claims = YES
  // This mirrors the Solidity behavior and enables circular validation
  //
  // CONCRETE EXAMPLE:
  // Claim 0: EntityA needs EntityB (assume YES) → A gets added to yesEntities
  // Claim 1: EntityB needs EntityA (assume YES) → B gets added to yesEntities
  // Result: Both A and B are in yesEntities → mutual validation succeeds!

  for (let claimIndex = 0; claimIndex < hanko.claims.length; claimIndex++) {
    const claim = hanko.claims[claimIndex];
    if (!claim) continue;

    console.log(
      `🔄 Processing claim ${claimIndex + 1}/${hanko.claims.length}: Entity ${ethers.hexlify(claim.entityId).slice(0, 10)}...`,
    );

    // Calculate voting power with flashloan assumptions
    let totalVotingPower = 0;
    const totalEntities = hanko.placeholders.length + signatures.length + hanko.claims.length;

    for (let i = 0; i < claim.entityIndexes.length; i++) {
      const entityIndex = claim.entityIndexes[i];
      if (entityIndex === undefined) continue;

      // Validate bounds
      if (entityIndex >= totalEntities) {
        console.log(`❌ Entity index ${entityIndex} out of bounds (max: ${totalEntities})`);
        continue;
      }

      // Prevent self-reference
      const referencedClaimIndex = entityIndex - hanko.placeholders.length - signatures.length;
      if (referencedClaimIndex === claimIndex) {
        console.log(`❌ Claim ${claimIndex} cannot reference itself`);
        continue;
      }

      if (entityIndex < hanko.placeholders.length) {
        // Index 0..N-1: Placeholder (failed entity) - contributes 0 voting power
        console.log(`  📍 Index ${entityIndex}: Placeholder (no power)`);
        continue;
      } else if (entityIndex < hanko.placeholders.length + signatures.length) {
        // Index N..M-1: EOA signature - verified, contributes full weight
        const weight = claim.weights[i] || 0;
        console.log(`  🔑 Index ${entityIndex}: EOA signature (power: ${weight})`);
        totalVotingPower += weight;
      } else {
        // Index M..∞: Entity claim - ASSUME YES! (flashloan governance)
        const refClaimIdx = referencedClaimIndex;
        const weight = claim.weights[i] || 0;
        console.log(`  🔥 Index ${entityIndex}: ASSUME claim ${refClaimIdx} = YES (power: ${weight})`);
        totalVotingPower += weight;
      }
    }

    // Check threshold
    if (totalVotingPower >= claim.threshold) {
      yesEntities.push(claim.entityId);
      console.log(`✅ Claim ${claimIndex + 1} passed: ${totalVotingPower}/${claim.threshold} (flashloan assumption)`);
    } else {
      console.log(`❌ Claim ${claimIndex + 1} failed: ${totalVotingPower}/${claim.threshold}`);
      // Note: In flashloan governance, any failure means total failure
    }
  }

  console.log(`📊 Flashloan recovery complete: ${yesEntities.length} yes, ${hanko.placeholders.length} placeholders`);

  return {
    yesEntities,
    noEntities: hanko.placeholders,
    claims: hanko.claims,
  };
};

// === FULL CYCLE TEST ===

export const testFullCycle = async (): Promise<{ hanko: HankoBytes; abiEncoded: string; hashToSign: Buffer }> => {
  console.log('\n🧪 === FULL CYCLE TEST: TypeScript → Solidity ===\n');

  // Generate test data
  const hashToSign = createHash('sha256').update('Test hanko message').digest();
  const privateKey1 = randomBytes(32);
  const privateKey2 = randomBytes(32);

  // Get addresses
  const wallet1 = new ethers.Wallet(ethers.hexlify(privateKey1));
  const wallet2 = new ethers.Wallet(ethers.hexlify(privateKey2));

  console.log(`📄 Hash to sign: 0x${hashToSign.toString('hex')}`);
  console.log(`🔑 Signer 1: ${wallet1.address}`);
  console.log(`🔑 Signer 2: ${wallet2.address}`);

  // Create real hanko
  const hanko = await buildRealHanko(hashToSign, {
    noEntities: [],
    privateKeys: [privateKey1, privateKey2],
    claims: [
      {
        entityId: Buffer.from('0000000000000000000000000000000000000000000000000000000000000001', 'hex'),
        entityIndexes: [0, 1], // Both signatures
        weights: [1, 1],
        threshold: 2,
        expectedQuorumHash: randomBytes(32),
      },
    ],
  });

  // Verify unpacking works
  const unpacked = unpackRealSignatures(hanko.packedSignatures);
  console.log(`\n📦 Signature verification:`);

  for (let i = 0; i < unpacked.length; i++) {
    const expectedAddr = i === 0 ? wallet1.address : wallet2.address;
    const verified = await verifySignatureRecovery(hashToSign, unpacked[i]!, expectedAddr);
    console.log(`   Signature ${i + 1}: ${verified ? '✅' : '❌'} ${expectedAddr.slice(0, 10)}...`);
  }

  // Create ABI-encoded data for Solidity (flashloan governance format)
  const abiEncoded = ethers.AbiCoder.defaultAbiCoder().encode(
    ['tuple(bytes32[],bytes,tuple(bytes32,uint256[],uint256[],uint256,bytes32)[])'],
    [
      [
        hanko.placeholders.map(p => '0x' + Buffer.from(p).toString('hex')),
        '0x' + Buffer.from(hanko.packedSignatures).toString('hex'),
        hanko.claims.map(c => [
          '0x' + Buffer.from(c.entityId).toString('hex'),
          c.entityIndexes,
          c.weights,
          c.threshold,
          '0x' + Buffer.from(c.expectedQuorumHash).toString('hex'),
        ]),
      ],
    ],
  );

  console.log(`\n📋 ABI Encoded hanko: ${abiEncoded.length} bytes`);

  return { hanko, abiEncoded, hashToSign };
};

// === GAS OPTIMIZATION TEST ===

export const testGasOptimization = async (): Promise<void> => {
  console.log('\n⛽ === GAS OPTIMIZATION TEST ===\n');

  // Create test hanko
  const { hanko, abiEncoded, hashToSign } = await testFullCycle();

  // Method 1: Send full hanko (higher calldata, more gas)
  console.log(`📊 Method 1 - Full Hanko:`);
  console.log(`   Calldata size: ${abiEncoded.length} bytes`);
  console.log(`   Solidity function: verifyHankoSignature(bytes,bytes32)`);

  // Method 2: Pre-recover entities and send optimized data
  const recovered = await recoverHankoEntities(hanko, hashToSign);

  // Encode optimized data (yesEntities + noEntities + claims)
  const optimizedEncoded = ethers.AbiCoder.defaultAbiCoder().encode(
    ['bytes32[]', 'bytes32[]', 'tuple(bytes32,uint256[],uint256[],uint256,bytes32)[]'],
    [
      recovered.yesEntities.map(entity => '0x' + Buffer.from(entity).toString('hex')),
      recovered.noEntities.map(entity => '0x' + Buffer.from(entity).toString('hex')),
      recovered.claims.map(c => [
        '0x' + Buffer.from(c.entityId).toString('hex'),
        c.entityIndexes,
        c.weights,
        c.threshold,
        '0x' + Buffer.from(c.expectedQuorumHash).toString('hex'),
      ]),
    ],
  );

  console.log(`📊 Method 2 - Pre-recovered:`);
  console.log(`   Calldata size: ${optimizedEncoded.length} bytes`);
  console.log(`   Solidity function: verifyQuorumClaims(bytes32[],bytes32[],HankoClaim[])`);
  console.log(
    `   Gas savings: ~${Math.round((1 - optimizedEncoded.length / abiEncoded.length) * 100)}% calldata reduction`,
  );
  console.log(`   Additional savings: No signature recovery gas cost on-chain`);

  console.log(`\n💡 Recommendation: Use Method 2 for gas-sensitive applications`);
};

// All functions exported above

--- src/routing/pathfinding.ts ---
/**
 * Dijkstra Pathfinding Implementation for Payment Routing
 * Finds optimal payment routes through the network
 */

import type { NetworkGraph, ChannelEdge } from './graph';
import { getEdge } from './graph';

export interface PaymentRoute {
  path: string[]; // Array of entity IDs from source to target
  hops: Array<{
    from: string;
    to: string;
    fee: bigint;
    feePPM: number;
  }>;
  totalFee: bigint;
  totalAmount: bigint; // Amount including fees
  probability: number; // Success probability estimate (0-1)
}

/**
 * Priority queue entry for Dijkstra
 */
interface QueueEntry {
  cost: bigint;
  node: string;
  path: string[];
  totalFee: bigint;
}

export class PathFinder {
  constructor(private graph: NetworkGraph) {}

  /**
   * Find payment routes using modified Dijkstra algorithm
   * Returns up to maxRoutes sorted by total fees
   */
  findRoutes(
    source: string,
    target: string,
    amount: bigint,
    tokenId: number,
    maxRoutes: number = 100
  ): PaymentRoute[] {
    if (source === target) return [];
    if (!this.graph.nodes.has(source) || !this.graph.nodes.has(target)) return [];

    const routes: PaymentRoute[] = [];
    const visited = new Map<string, Set<string>>(); // node -> set of previous nodes

    // Priority queue: [cost, node, path, totalFee]
    const queue: QueueEntry[] = [{
      cost: 0n,
      node: source,
      path: [source],
      totalFee: 0n,
    }];

    while (queue.length > 0 && routes.length < maxRoutes) {
      // Sort by cost (simple priority queue)
      queue.sort((a, b) => {
        if (a.cost < b.cost) return -1;
        if (a.cost > b.cost) return 1;
        return 0;
      });

      const current = queue.shift()!;

      // Check if we've visited this node from this previous node
      const prevNode = current.path[current.path.length - 2] || 'START';
      const visitedFrom = visited.get(current.node) || new Set();
      if (visitedFrom.has(prevNode)) continue;
      visitedFrom.add(prevNode);
      visited.set(current.node, visitedFrom);

      // Found target - build route
      if (current.node === target) {
        const route = this.buildRoute(current.path, amount, tokenId);
        if (route) {
          routes.push(route);
        }
        continue;
      }

      // Explore neighbors
      const edges = this.graph.edges.get(current.node) ?? []; // Explicit undefined handling
      for (const edge of edges) {
        // Skip if wrong token or disabled
        if (edge.tokenId !== tokenId || edge.disabled) continue;

        // Skip if already in path (no loops)
        if (current.path.includes(edge.to)) continue;

        // Calculate required amount at this hop (working backwards)
        const requiredAmount = this.calculateRequiredAmount(
          amount,
          [...current.path, edge.to],
          target,
          tokenId
        );

        // Skip if insufficient capacity
        if (requiredAmount > edge.capacity) continue;

        // Calculate fee for this edge
        const edgeFee = this.calculateFee(edge, requiredAmount);
        const newTotalFee = current.totalFee + edgeFee;

        // Add to queue with updated cost
        queue.push({
          cost: newTotalFee, // Use total fee as cost
          node: edge.to,
          path: [...current.path, edge.to],
          totalFee: newTotalFee,
        });
      }
    }

    // Sort routes by total fee
    return routes.sort((a, b) => {
      if (a.totalFee < b.totalFee) return -1;
      if (a.totalFee > b.totalFee) return 1;
      return 0;
    });
  }

  /**
   * Calculate fee for an edge
   */
  private calculateFee(edge: ChannelEdge, amount: bigint): bigint {
    // Fee = baseFee + (amount * feePPM / 1,000,000)
    const proportionalFee = (amount * BigInt(edge.feePPM)) / 1_000_000n;
    return edge.baseFee + proportionalFee;
  }

  /**
   * Calculate required amount at each hop (working backwards from target)
   */
  private calculateRequiredAmount(
    finalAmount: bigint,
    path: string[],
    target: string,
    tokenId: number
  ): bigint {
    let amount = finalAmount;

    // Work backwards from target to source
    for (let i = path.length - 1; i > 0; i--) {
      if (path[i] === target) continue; // Skip target node

      const edge = getEdge(this.graph, path[i - 1]!, path[i]!, tokenId);
      if (edge) {
        // Add fee that this hop will charge
        amount = amount + this.calculateFee(edge, amount);
      }
    }

    return amount;
  }

  /**
   * Build complete route details from path
   */
  private buildRoute(
    path: string[],
    amount: bigint,
    tokenId: number
  ): PaymentRoute | null {
    if (path.length < 2) return null;

    const hops: PaymentRoute['hops'] = [];
    let totalFee = 0n;
    let currentAmount = amount;

    // Build hops forward, calculating fees
    for (let i = 0; i < path.length - 1; i++) {
      const edge = getEdge(this.graph, path[i]!, path[i + 1]!, tokenId);
      if (!edge) return null;

      const fee = this.calculateFee(edge, currentAmount);
      hops.push({
        from: path[i]!,
        to: path[i + 1]!,
        fee,
        feePPM: edge.feePPM,
      });

      totalFee += fee;
      currentAmount += fee; // Next hop needs more to cover this fee
    }

    // Calculate success probability
    const probability = this.calculateProbability(path, amount, tokenId);

    return {
      path,
      hops,
      totalFee,
      totalAmount: amount + totalFee,
      probability,
    };
  }

  /**
   * Calculate success probability based on channel utilization
   */
  private calculateProbability(
    path: string[],
    amount: bigint,
    tokenId: number
  ): number {
    let probability = 1.0;

    for (let i = 0; i < path.length - 1; i++) {
      const edge = getEdge(this.graph, path[i]!, path[i + 1]!, tokenId);
      if (edge && edge.capacity > 0n) {
        const utilization = Number(amount) / Number(edge.capacity);
        // Higher utilization = lower success probability
        // Using exponential decay: e^(-2 * utilization)
        probability *= Math.exp(-2 * utilization);
      }
    }

    return Math.max(0.01, Math.min(1.0, probability));
  }
}
--- src/routing/graph.ts ---
/**
 * Network Graph Structure for Payment Routing
 * Builds from gossip profiles to create routing graph
 */

import type { Profile } from '../gossip';

export interface ChannelEdge {
  from: string;
  to: string;
  tokenId: number;
  capacity: bigint;
  baseFee: bigint; // Base fee in smallest unit
  feePPM: number; // Fee rate in parts per million
  disabled: boolean;
}

export interface NetworkGraph {
  nodes: Set<string>; // Entity IDs
  edges: Map<string, ChannelEdge[]>; // from -> edges[]

  // Quick lookup for channel capacities
  channelCapacities: Map<string, {
    outbound: bigint;
    inbound: bigint;
  }>;
}

/**
 * Build network graph from gossip profiles
 */
export function buildNetworkGraph(
  profiles: Map<string, Profile>,
  tokenId: number
): NetworkGraph {
  const nodes = new Set<string>();
  const edges = new Map<string, ChannelEdge[]>();
  const channelCapacities = new Map<string, {
    outbound: bigint;
    inbound: bigint;
  }>();

  // Add all entities as nodes
  for (const profile of profiles.values()) {
    nodes.add(profile.entityId);
  }

  // Build edges from account relationships
  for (const profile of profiles.values()) {
    const fromEntity = profile.entityId;
    const fromEdges: ChannelEdge[] = [];

    if (profile.accounts) {
      for (const account of profile.accounts) {
        const toEntity = account.counterpartyId;

        // Only add if counterparty exists in network
        if (!nodes.has(toEntity)) continue;

        // Get capacities for this token
        const tokenCapacity = account.tokenCapacities.get(tokenId);
        if (!tokenCapacity || tokenCapacity.outCapacity === 0n) continue;

        // Get fee configuration from profile with explicit validation
        const metadata = profile.metadata;
        if (!metadata) {
          console.warn(`🚨 ROUTING-SAFETY: Entity ${fromEntity} has no metadata, using safe defaults`);
        }
        const baseFee = metadata?.baseFee ?? 0n; // Explicit null/undefined check
        const feePPM = metadata?.routingFeePPM ?? 100; // Explicit default: 100 PPM (0.01%)

        // Create edge
        const edge: ChannelEdge = {
          from: fromEntity,
          to: toEntity,
          tokenId,
          capacity: tokenCapacity.outCapacity,
          baseFee,
          feePPM,
          disabled: false,
        };

        fromEdges.push(edge);

        // Store channel capacities
        const channelKey = `${fromEntity}:${toEntity}:${tokenId}`;
        channelCapacities.set(channelKey, {
          outbound: tokenCapacity.outCapacity,
          inbound: tokenCapacity.inCapacity,
        });
      }
    }

    if (fromEdges.length > 0) {
      edges.set(fromEntity, fromEdges);
    }
  }

  return {
    nodes,
    edges,
    channelCapacities,
  };
}

/**
 * Get edge between two nodes
 */
export function getEdge(
  graph: NetworkGraph,
  from: string,
  to: string,
  tokenId: number
): ChannelEdge | undefined {
  const edges = graph.edges.get(from) ?? [];  // Explicit undefined handling
  return edges.find(e => e.to === to && e.tokenId === tokenId);
}
--- src/account-tx/direct-payment.ts ---
/**
 * Direct Payment with proper capacity checking using deriveDelta
 * Includes event bubbling back to E-Machine
 */

import { AccountMachine } from '../types';
import { deriveDelta, getDefaultCreditLimit } from '../account-utils';

export type DirectPaymentData = {
  tokenId: number;
  amount: bigint;
  description?: string;
};

/**
 * DirectPayment with global credit limit checking (similar to old_src deriveDelta)
 * Checks capacity constraints before applying payment
 */
export function applyDirectPayment(
  accountMachine: AccountMachine,
  payment: DirectPaymentData,
  isOutgoing: boolean
): { success: boolean; error?: string; events?: string[] } {

  console.log(`💸 DirectPayment: ${payment.amount.toString()} of token ${payment.tokenId}, outgoing: ${isOutgoing}`);

  // Get or create delta for this token
  let delta = accountMachine.deltas.get(payment.tokenId);
  if (!delta) {
    const defaultCreditLimit = getDefaultCreditLimit(payment.tokenId);
    delta = {
      tokenId: payment.tokenId,
      collateral: 0n,
      ondelta: 0n,
      offdelta: 0n,
      leftCreditLimit: defaultCreditLimit,
      rightCreditLimit: defaultCreditLimit,
      leftAllowence: 0n,
      rightAllowence: 0n,
    };
    accountMachine.deltas.set(payment.tokenId, delta);
    console.log(`💳 Created new delta for token ${payment.tokenId}`);
  }

  // Calculate current total delta and new delta after payment
  const currentTotalDelta = delta.ondelta + delta.offdelta;
  const newTotalDelta = isOutgoing ?
    currentTotalDelta + payment.amount : // We owe them more (positive)
    currentTotalDelta - payment.amount;  // They owe us more (negative)

  console.log(`💸 Delta calculation: current=${currentTotalDelta.toString()}, new=${newTotalDelta.toString()}`);

  // Check capacity constraints using deriveDelta (like old_src)
  const isLeft = accountMachine.proofHeader.fromEntity < accountMachine.proofHeader.toEntity;
  const derived = deriveDelta(delta, isLeft); // isLeft like old_src

  if (isOutgoing) {
    // Check if we have enough outbound capacity
    if (payment.amount > derived.outCapacity) {
      return {
        success: false,
        error: `Insufficient capacity: need ${payment.amount.toString()}, available ${derived.outCapacity.toString()}`
      };
    }
    console.log(`💳 Capacity check passed: using ${payment.amount.toString()}/${derived.outCapacity.toString()} capacity`);

    // Also check global credit limits for USD-denominated credit
    if (payment.tokenId === 2 && newTotalDelta > 0n) {
      const creditUsed = newTotalDelta;
      const availableCredit = accountMachine.globalCreditLimits.peerLimit;

      if (creditUsed > availableCredit) {
        return {
          success: false,
          error: `Insufficient global credit: need ${creditUsed.toString()} USD, available ${availableCredit.toString()} USD`
        };
      }
      console.log(`💳 Global credit check passed: using ${creditUsed.toString()}/${availableCredit.toString()} USD credit`);
    }
  }

  // Apply the payment
  if (isOutgoing) {
    delta.offdelta += payment.amount;
    console.log(`💸 Sent ${payment.amount.toString()} token ${payment.tokenId} (we owe them more)`);
  } else {
    delta.offdelta -= payment.amount;
    console.log(`💰 Received ${payment.amount.toString()} token ${payment.tokenId} (they owe us more)`);
  }

  console.log(`💸 Updated offdelta for token ${payment.tokenId}: ${delta.offdelta.toString()}`);

  // Update frame with new delta
  const frameTokenIds = [...accountMachine.currentFrame.tokenIds];
  const frameDeltas = [...accountMachine.currentFrame.deltas];

  const tokenIndex = frameTokenIds.indexOf(payment.tokenId);
  const finalTotalDelta = delta.ondelta + delta.offdelta;

  if (tokenIndex >= 0) {
    frameDeltas[tokenIndex] = finalTotalDelta;
  } else {
    frameTokenIds.push(payment.tokenId);
    frameDeltas.push(finalTotalDelta);
  }

  accountMachine.currentFrame = {
    frameId: accountMachine.currentFrame.frameId + 1,
    timestamp: Date.now(),
    tokenIds: frameTokenIds,
    deltas: frameDeltas,
  };

  console.log(`✅ Payment applied. New frame ${accountMachine.currentFrame.frameId}, delta: ${finalTotalDelta.toString()}`);

  // Generate events to bubble up to E-Machine
  const events = [];
  if (isOutgoing) {
    events.push(`💸 Sent ${payment.amount.toString()} token ${payment.tokenId} to Entity ${accountMachine.counterpartyEntityId.slice(-4)}`);
  } else {
    events.push(`💰 Received ${payment.amount.toString()} token ${payment.tokenId} from Entity ${accountMachine.counterpartyEntityId.slice(-4)}`);
  }

  return { success: true, events };
}

/**
 * Create DirectPayment transaction for mempool
 */
export function createDirectPaymentTx(tokenId: number, amount: bigint, description?: string) {
  return {
    type: 'direct_payment' as const,
    data: {
      tokenId,
      amount,
      description: description || `Direct payment of ${amount.toString()} token ${tokenId}`,
    }
  };
}

--- src/account-tx/crypto.ts ---
/**
 * Mock signature validation for account consensus
 * Deterministic and simple for development/testing
 */

/**
 * Mock sign function - creates deterministic signatures
 */
export function signAccountFrame(
  entityId: string,
  frameHash: string,
  privateData: string = 'mock-private-key'
): string {
  // Create deterministic signature based on signer + frame hash
  const content = `${entityId}-${frameHash}-${privateData}`;
  const signature = `sig_${Buffer.from(content).toString('base64').slice(0, 32)}`;

  console.log(`✍️ Signed frame ${frameHash.slice(0, 10)} by ${entityId.slice(-4)}: ${signature.slice(0, 20)}...`);
  return signature;
}

/**
 * Mock verify function - validates signatures deterministically
 */
export function verifyAccountSignature(
  entityId: string,
  frameHash: string,
  signature: string,
  privateData: string = 'mock-private-key'
): boolean {
  const expectedSignature = signAccountFrame(entityId, frameHash, privateData);
  const isValid = signature === expectedSignature;

  if (isValid) {
    console.log(`✅ Valid signature from ${entityId.slice(-4)} for frame ${frameHash.slice(0, 10)}`);
  } else {
    console.log(`❌ Invalid signature from ${entityId.slice(-4)} for frame ${frameHash.slice(0, 10)}`);
    console.log(`   Expected: ${expectedSignature.slice(0, 20)}...`);
    console.log(`   Received: ${signature.slice(0, 20)}...`);
  }

  return isValid;
}

/**
 * Easy signer function that returns the entity ID from a signature
 */
export function getSignerFromSignature(signature: string, frameHash: string): string | null {
  // Parse signature to extract signer (mock implementation)
  // Real implementation would use cryptographic signature recovery

  if (!signature.startsWith('sig_')) {
    return null;
  }

  // For mock: signature format is sig_BASE64(entityId-frameHash-privateKey)
  try {
    const encoded = signature.slice(4); // Remove 'sig_' prefix
    const decoded = Buffer.from(encoded, 'base64').toString();
    const parts = decoded.split('-');

    if (parts.length >= 2 && parts[1] === frameHash) {
      return parts[0] || null; // Return entityId or null if empty
    }
  } catch (error) {
    console.log(`⚠️ Failed to parse signature: ${error}`);
  }

  return null;
}

/**
 * Validate multiple signatures for account frame
 */
export function validateAccountSignatures(
  frameHash: string,
  signatures: string[],
  expectedSigners: string[]
): { valid: boolean; validSigners: string[] } {
  const validSigners: string[] = [];

  for (const signature of signatures) {
    const signer = getSignerFromSignature(signature, frameHash);

    if (signer && expectedSigners.includes(signer)) {
      if (verifyAccountSignature(signer, frameHash, signature)) {
        validSigners.push(signer);
      }
    }
  }

  const allValid = validSigners.length === expectedSigners.length;

  console.log(`🔍 Signature validation: ${validSigners.length}/${expectedSigners.length} valid (${allValid ? 'PASS' : 'FAIL'})`);

  return { valid: allValid, validSigners };
}
--- src/account-tx/processor.ts ---
/**
 * Simple Account Transaction Processor
 * Minimal implementation for DirectPayment processing
 */

import { AccountMachine, AccountTx } from '../types';
import { applyDirectPayment, DirectPaymentData } from './direct-payment';

/**
 * Determine payment direction based on account context
 * Similar to old_src Channel isLeft logic
 */
function determinePaymentDirection(
  _accountMachine: AccountMachine,
  transaction: AccountTx,
  currentFrameIsOurs: boolean
): boolean {
  // If we're processing our own frame, then direct_payment is outgoing
  // If we're processing counterparty's frame, then their direct_payment is incoming to us

  if (transaction.type === 'direct_payment') {
    return currentFrameIsOurs; // Our frame = outgoing, their frame = incoming
  }

  return true; // Default to outgoing for other types
}

/**
 * Process a single account transaction with proper direction logic
 */
export function processAccountTransaction(
  accountMachine: AccountMachine,
  transaction: AccountTx,
  currentFrameIsOurs: boolean = true
): { success: boolean; error?: string; events?: string[] } {

  console.log(`🔄 Processing account transaction: ${transaction.type} (frameIsOurs: ${currentFrameIsOurs})`);

  switch (transaction.type) {
    case 'account_settle':
      console.log(`💰 Account settlement already processed in account handler`);
      return {
        success: true,
        events: [`⚖️ Settlement processed with Entity ${accountMachine.counterpartyEntityId.slice(-4)}`]
      };

    case 'direct_payment': {
      const isOutgoing = determinePaymentDirection(accountMachine, transaction, currentFrameIsOurs);
      console.log(`💸 DirectPayment direction: ${isOutgoing ? 'OUTGOING' : 'INCOMING'} (processing ${currentFrameIsOurs ? 'our' : 'their'} frame)`);

      return applyDirectPayment(
        accountMachine,
        transaction.data as DirectPaymentData,
        isOutgoing
      );
    }

    default:
      // FINTECH-SAFETY: Never use 'as any' for transaction types
      const txType = 'type' in transaction ? transaction.type : 'INVALID';
      return { success: false, error: `Unknown transaction type: ${txType}` };
  }
}

/**
 * Process all pending transactions in mempool
 */
export function processAccountMempool(accountMachine: AccountMachine): void {
  console.log(`🔄 Processing ${accountMachine.mempool.length} account transactions for ${accountMachine.counterpartyEntityId}`);

  while (accountMachine.mempool.length > 0) {
    const transaction = accountMachine.mempool.shift()!;

    try {
      const result = processAccountTransaction(accountMachine, transaction);

      if (result.success) {
        console.log(`✅ Processed ${transaction.type} successfully`);
        accountMachine.sentTransitions++;
      } else {
        console.error(`❌ Failed to process ${transaction.type}: ${result.error}`);
        accountMachine.mempool.unshift(transaction);
        break;
      }
    } catch (error) {
      console.error(`💥 Error processing ${transaction.type}:`, error);
    }
  }
}
--- src/account-tx/index.ts ---
/**
 * Account Transaction System
 * Simple transaction types and processing only
 * Use account-consensus.ts from src root for frame consensus
 */

// Core DirectPayment functionality
export {
  applyDirectPayment,
  createDirectPaymentTx
} from './direct-payment';

export type { DirectPaymentData } from './direct-payment';

// Transaction processing (legacy - use account-consensus.ts instead)
export {
  processAccountTransaction,
  processAccountMempool
} from './processor';

// Re-export types
export type { AccountMachine, AccountTx, Delta } from '../types';
--- src/evm.ts ---
/**
 * XLN EVM Integration
 * Handles blockchain interactions, jurisdictions, and smart contract operations
 */

import { ethers } from 'ethers';
import { loadJurisdictions } from './jurisdiction-loader';

import { detectEntityType, encodeBoard, extractNumberFromEntityId, hashBoard } from './entity-factory';
import { ConsensusConfig, JurisdictionConfig } from './types';
import { DEBUG, isBrowser } from './utils';

// === ETHEREUM INTEGRATION ===

// Load contract configuration directly in jurisdiction generation
export const ENTITY_PROVIDER_ABI = [
  'function registerNumberedEntity(bytes32 boardHash) external returns (uint256 entityNumber)',
  'function assignName(string memory name, uint256 entityNumber) external',
  'function transferName(string memory name, uint256 newEntityNumber) external',
  'function entities(bytes32 entityId) external view returns (tuple(uint256 boardHash, uint8 status, uint256 activationTime))',
  'function nameToNumber(string memory name) external view returns (uint256)',
  'function numberToName(uint256 entityNumber) external view returns (string memory)',
  'function nextNumber() external view returns (uint256)',
  // Governance functions (governance is auto-setup on entity registration)
  'function getTokenIds(uint256 entityNumber) external pure returns (uint256 controlTokenId, uint256 dividendTokenId)',
  'function getGovernanceInfo(uint256 entityNumber) external view returns (uint256 controlTokenId, uint256 dividendTokenId, uint256 controlSupply, uint256 dividendSupply, bool hasActiveProposal, bytes32 articlesHash)',
  'function balanceOf(address account, uint256 id) external view returns (uint256)',
  'function safeTransferFrom(address from, address to, uint256 id, uint256 amount, bytes data) external',
  // Events
  'event EntityRegistered(bytes32 indexed entityId, uint256 indexed entityNumber, bytes32 boardHash)',
  'event NameAssigned(string indexed name, uint256 indexed entityNumber)',
  'event NameTransferred(string indexed name, uint256 indexed oldEntityNumber, uint256 indexed newEntityNumber)',
  'event GovernanceEnabled(bytes32 indexed entityId, uint256 controlTokenId, uint256 dividendTokenId)',
];

export const DEPOSITORY_ABI = [
  'function debugFundReserves(bytes32 entity, uint256 tokenId, uint256 amount) external',
  'function debugBulkFundEntities() external',
  'function reserveToReserve(bytes32 fromEntity, bytes32 toEntity, uint256 tokenId, uint256 amount) external returns (bool)',
  'function processBatch(bytes32 entity, tuple(tuple(bytes32 receivingEntity, uint256 tokenId, uint256 amount)[] reserveToExternalToken, tuple(bytes32 entity, bytes32 packedToken, uint256 internalTokenId, uint256 amount)[] externalTokenToReserve, tuple(bytes32 receivingEntity, uint256 tokenId, uint256 amount)[] reserveToReserve, tuple(uint256 tokenId, bytes32 receivingEntity, tuple(bytes32 entity, uint256 amount)[] pairs)[] reserveToCollateral, tuple(bytes32 leftEntity, bytes32 rightEntity, tuple(uint256 tokenId, int256 leftDiff, int256 rightDiff, int256 collateralDiff, int256 ondeltaDiff)[] diffs)[] settlements, tuple(bytes32 counterentity, tuple(uint256 tokenId, int256 peerReserveDiff, int256 collateralDiff, int256 ondeltaDiff)[] diffs, uint256[] forgiveDebtsInTokenIds, bytes sig)[] cooperativeUpdate, tuple(bytes32 counterentity, tuple(int256[] offdeltas, uint256[] tokenIds, tuple(address subcontractProviderAddress, bytes encodedBatch, tuple(uint256 deltaIndex, uint256 rightAllowence, uint256 leftAllowence)[] allowences)[] subcontracts) proofbody, bytes initialArguments, bytes finalArguments, bytes sig)[] cooperativeDisputeProof, tuple(bytes32 counterentity, uint256 cooperativeNonce, uint256 disputeNonce, bytes32 proofbodyHash, bytes sig, bytes initialArguments)[] initialDisputeProof, tuple(bytes32 counterentity, uint256 initialCooperativeNonce, uint256 initialDisputeNonce, uint256 disputeUntilBlock, bytes32 initialProofbodyHash, bytes initialArguments, bool startedByLeft, uint256 finalCooperativeNonce, uint256 finalDisputeNonce, tuple(int256[] offdeltas, uint256[] tokenIds, tuple(address subcontractProviderAddress, bytes encodedBatch, tuple(uint256 deltaIndex, uint256 rightAllowence, uint256 leftAllowence)[] allowences)[] subcontracts) finalProofbody, bytes finalArguments, bytes sig)[] finalDisputeProof, tuple(uint256 tokenId, uint256 amount)[] flashloans, uint256 hub_id) batch) external returns (bool)',
  'function prefundAccount(bytes32 counterpartyEntity, uint256 tokenId, uint256 amount) external returns (bool)',
  'function settle(bytes32 leftEntity, bytes32 rightEntity, tuple(uint256 tokenId, int256 leftDiff, int256 rightDiff, int256 collateralDiff)[] diffs) external returns (bool)',
  'function _reserves(bytes32 entity, uint256 tokenId) external view returns (uint256)',
  'event ReserveUpdated(bytes32 indexed entity, uint256 indexed tokenId, uint256 newBalance)',
  'event ReserveTransferred(bytes32 indexed from, bytes32 indexed to, uint256 indexed tokenId, uint256 amount)',
  'event SettlementProcessed(bytes32 indexed leftEntity, bytes32 indexed rightEntity, uint256 indexed tokenId, uint256 leftReserve, uint256 rightReserve, uint256 collateral, int256 ondelta)',
];

export const connectToEthereum = async (jurisdiction: JurisdictionConfig) => {
  try {
    // FINTECH-SAFETY: Validate jurisdiction structure before using
    const rpcUrl = jurisdiction.address;
    const entityProviderAddress = jurisdiction.entityProviderAddress;
    const depositoryAddress = jurisdiction.depositoryAddress;

    // Support legacy format with explicit validation
    if (!rpcUrl && 'rpc' in jurisdiction) {
      console.warn('🚨 JURISDICTION-LEGACY: Using deprecated rpc field, should be address');
    }
    if (!entityProviderAddress && 'contracts' in jurisdiction) {
      console.warn('🚨 JURISDICTION-LEGACY: Using deprecated contracts.entityProvider field');
    }

    if (!rpcUrl) {
      throw new Error('Jurisdiction missing RPC URL (address or rpc property)');
    }
    if (!entityProviderAddress || !depositoryAddress) {
      throw new Error('Jurisdiction missing contract addresses (entityProvider and depository)');
    }

    // Connect to specified RPC node
    const provider = new ethers.JsonRpcProvider(rpcUrl);

    // Use first account for testing (Hardhat account #0)
    const signer = await provider.getSigner(0);

    // Create contract instances
    const entityProvider = new ethers.Contract(entityProviderAddress, ENTITY_PROVIDER_ABI, signer);
    const depository = new ethers.Contract(depositoryAddress, DEPOSITORY_ABI, signer);

    return { provider, signer, entityProvider, depository };
  } catch (error) {
    console.error(`Failed to connect to ${jurisdiction.name}:`, error);
    throw error;
  }
};

// Debug function to fund entity reserves for testing
export const debugFundReserves = async (jurisdiction: JurisdictionConfig, entityId: string, tokenId: number, amount: string) => {
  try {
    console.log(`💰 DEBUG: Funding entity ${entityId.slice(0, 10)} with ${amount} of token ${tokenId}...`);
    
    const { depository } = await connectToEthereum(jurisdiction);
    
    // Fund the entity's reserves for testing
    const tx = await depository['debugFundReserves']!(entityId, tokenId, amount);
    console.log(`📡 Debug funding transaction: ${tx.hash}`);
    
    const receipt = await tx.wait();
    console.log(`✅ Debug funding confirmed in block ${receipt.blockNumber}`);
    
    // Check new balance
    const newBalance = await depository['_reserves']!(entityId, tokenId);
    console.log(`💰 Entity ${entityId.slice(0, 10)} now has ${newBalance.toString()} of token ${tokenId}`);
    
    return { transaction: tx, receipt, newBalance };
  } catch (error) {
    console.error(`❌ Failed to fund reserves:`, error);
    throw error;
  }
};

/**
 * Fund entity with multiple assets and emit ReserveUpdated events
 */
export const fundEntityReserves = async (entityId: string, assets: Array<{ tokenId: number; amount: string; symbol: string }>) => {
  console.log(`💰 Funding entity ${entityId.slice(0, 10)}... with ${assets.length} assets`);
  
  for (const asset of assets) {
    console.log(`  💳 Adding ${asset.symbol}: ${asset.amount} (token ${asset.tokenId})`);
    // TODO: Implement fundReserves function or use debugFundReserves
    console.log(`  - Funding ${entityId.slice(0, 10)} with ${asset.amount} of token ${asset.tokenId}`);
  }
  
  console.log(`✅ Entity ${entityId.slice(0, 10)}... funded with all assets`);
};

// Submit real processBatch transaction to jurisdiction
export const submitPrefundAccount = async (jurisdiction: JurisdictionConfig, entityId: string, counterpartyEntityId: string, tokenId: number, amount: string) => {
  try {
    console.log(`💰 Prefunding account between ${entityId.slice(0, 10)}... and ${counterpartyEntityId.slice(0, 10)}...`);
    console.log(`🔍 TOKEN: ${tokenId}, AMOUNT: ${amount}`);
    
    const { depository, provider } = await connectToEthereum(jurisdiction);
    console.log(`🔍 CONTRACT ADDRESS: ${depository.target}`);
    
    // Check if contract exists
    const code = await provider.getCode(depository.target);
    if (code === '0x') {
      throw new Error('Contract not deployed at this address');
    }
    
    // Check entity has sufficient reserves
    const currentBalance = await depository['_reserves']!(entityId, tokenId);
    console.log(`🔍 Current balance: ${currentBalance.toString()}`);
    console.log(`🔍 Requested amount: ${amount}`);
    
    if (currentBalance < BigInt(amount)) {
      throw new Error(`Insufficient reserves: have ${currentBalance.toString()}, need ${amount}`);
    }
    
    // Call prefundAccount function
    console.log(`📞 Calling prefundAccount(${counterpartyEntityId}, ${tokenId}, ${amount})`);
    const tx = await depository['prefundAccount']!(counterpartyEntityId, tokenId, amount);
    console.log(`⏳ Transaction sent: ${tx.hash}`);
    
    // Wait for confirmation
    const receipt = await tx.wait();
    console.log(`✅ Prefunding confirmed in block ${receipt.blockNumber}`);
    
    return {
      hash: tx.hash,
      receipt: receipt
    };
    
  } catch (error) {
    console.error(`❌ Failed to prefund account:`, error);
    throw error;
  }
};

export const submitProcessBatch = async (jurisdiction: JurisdictionConfig, entityId: string, batch: any) => {
  try {
    console.log(`💸 Submitting processBatch to ${jurisdiction.name} as entity ${entityId.slice(0, 10)}...`);
    console.log(`🔍 BATCH DEBUG:`, JSON.stringify(batch, null, 2));
    console.log(`🔍 ENTITY DEBUG: ${entityId}`);
    console.log(`🔍 JURISDICTION DEBUG:`, jurisdiction);
    console.log(`🔍 JURISDICTION SOURCE: Reading from jurisdictions.json file`);
    console.log(`🔍 DEPOSITORY ADDRESS FROM JURISDICTION: ${jurisdiction.depositoryAddress}`);
    console.log(`🔍 ENTITY PROVIDER ADDRESS FROM JURISDICTION: ${jurisdiction.entityProviderAddress}`);
    
    // Fix batch amounts - convert any JS numbers to wei strings
    if (batch.reserveToReserve) {
      for (let i = 0; i < batch.reserveToReserve.length; i++) {
        const transfer = batch.reserveToReserve[i];
        if (typeof transfer.amount === 'number') {
          // Convert number to wei string
          const weiAmount = (BigInt(Math.floor(transfer.amount * 1e18))).toString();
          console.log(`🔧 Converting amount ${transfer.amount} → ${weiAmount} wei`);
          transfer.amount = weiAmount;
        }
      }
    }
    console.log(`🔍 FIXED BATCH:`, JSON.stringify(batch, null, 2));
    
    const { depository, provider } = await connectToEthereum(jurisdiction);
    console.log(`🔍 CONTRACT ADDRESS: ${depository.target}`);
    
    // Check if contract exists
    const code = await provider.getCode(depository.target);
    console.log(`🔍 CONTRACT CODE LENGTH: ${code.length} characters`);
    
    if (code === '0x') {
      throw new Error('Contract not deployed at this address');
    }
    
    // Test if this is our new contract
    try {
      console.log(`🔍 Testing if contract has debugBulkFundEntities...`);
      await depository['debugBulkFundEntities']?.staticCall?.();
      console.log(`✅ This is our NEW contract with debug functions!`);
    } catch (debugError) {
      console.log(`❌ This is OLD contract - no debug functions:`, (debugError as Error).message);
    }
    
    // Check current balance (entities should be pre-funded in constructor)
    console.log(`🔍 Checking balance for entity ${entityId} token ${batch.reserveToReserve[0]?.tokenId || 1}...`);
    try {
      const currentBalance = await depository['_reserves']!(entityId, batch.reserveToReserve[0]?.tokenId || 1);
      console.log(`🔍 Current balance: ${currentBalance.toString()}`);
      
      if (currentBalance.toString() === '0') {
        console.log(`⚠️ Entity has no reserves - this suggests old contract without pre-funding`);
        throw new Error(`Entity ${entityId.slice(0, 10)} has no reserves! Contract should be pre-funded.`);
      }
    } catch (balanceError) {
      console.log(`❌ Failed to check balance:`, (balanceError as Error).message);
      throw balanceError;
    }
    
    // Debug the exact function call being made
    console.log(`🔍 Function signature: processBatch(bytes32,tuple)`);
    console.log(`🔍 Entity ID: ${entityId}`);
    console.log(`🔍 Batch structure:`, Object.keys(batch));
    console.log(`🔍 reserveToReserve array:`, batch.reserveToReserve);
    
    // Check if function exists in contract interface
    const functionFragments = depository.interface.fragments.filter(f => f.type === 'function');
    const functions = functionFragments.map(f => {
      // Proper typing: FunctionFragment has name property
      return 'name' in f ? (f as { name: string }).name : 'unknown';
    });
    const hasProcessBatch = functions.includes('processBatch');
    console.log(`🔍 Contract has processBatch function: ${hasProcessBatch}`);
    console.log(`🔍 Available functions:`, functions.slice(0, 10), '...');
    
    // DEEP DEBUGGING: Check ABI vs deployed bytecode
    console.log(`🔍 DEEP DEBUG: Contract interface analysis`);
    console.log(`🔍 Contract target address: ${depository.target}`);
    
    // Get function selector for processBatch
    const processBatchFunc = depository.interface.getFunction('processBatch');
    const processBatchSelector = processBatchFunc?.selector || 'NOT_FOUND';
    console.log(`🔍 Function selector: ${processBatchSelector}`);
    
    // Check deployed bytecode contains this selector
    const bytecode = await provider.getCode(depository.target);
    const hasSelector = bytecode.includes(processBatchSelector.slice(2)); // Remove 0x
    console.log(`🔍 Deployed bytecode contains processBatch selector: ${hasSelector}`);
    console.log(`🔍 Bytecode length: ${bytecode.length} chars`);
    
    // Check ABI hash vs expected
    const abiHash = ethers.keccak256(ethers.toUtf8Bytes(JSON.stringify(depository.interface.fragments.map(f => {
      // Proper typing: Fragment has format method
      return 'format' in f && typeof f.format === 'function' ? f.format() : f.toString();
    }))));
    console.log(`🔍 ABI hash: ${abiHash.slice(0, 10)}...`);
    
    // Log exact call data being generated
    const callData = depository.interface.encodeFunctionData('processBatch', [entityId, batch]);
    console.log(`🔍 Call data length: ${callData.length} chars`);
    console.log(`🔍 Call data start: ${callData.slice(0, 20)}...`);
    
    // Try different entity addresses to see if it's entity-specific
    console.log(`🔍 Testing with different entity addresses...`);
    
    // Test entity 0 (should exist from token 0)
    try {
      const balance0 = await depository['_reserves']!("0x0000000000000000000000000000000000000000000000000000000000000000", 0);
      console.log(`🔍 Entity 0 Token 0 balance: ${balance0.toString()}`);
    } catch (e) {
      console.log(`❌ Entity 0 balance check failed: ${(e as Error).message}`);
    }
    
    // Try simpler batch with just empty arrays
    const emptyBatch = {
      reserveToExternalToken: [],
      externalTokenToReserve: [],
      reserveToReserve: [],
      reserveToCollateral: [],
      cooperativeUpdate: [],
      cooperativeDisputeProof: [],
      initialDisputeProof: [],
      finalDisputeProof: [],
      flashloans: [],
      hub_id: 0
    };
    
    console.log(`🔍 Testing empty batch first...`);
    try {
      const emptyResult = await depository['processBatch']?.staticCall(entityId, emptyBatch);
      console.log(`✅ Empty batch works: ${emptyResult}`);
      
      // If empty batch works, try our batch
      console.log(`🔍 Now testing our batch...`);
      const result = await depository['processBatch']?.staticCall(entityId, batch);
      console.log(`✅ Static call successful: ${result}`);
    } catch (staticError) {
      console.error(`❌ Static call failed:`, staticError);

      // Type-safe error handling for ethers.js errors
      const errorDetails: Record<string, unknown> = {};
      if (staticError && typeof staticError === 'object') {
        const errorObj = staticError as Record<string, unknown>;
        const code = errorObj['code'];
        const data = errorObj['data'];
        const reason = errorObj['reason'];
        if (code !== undefined) errorDetails['code'] = code;
        if (data !== undefined) errorDetails['data'] = data;
        if (reason !== undefined) errorDetails['reason'] = reason;
      }
      console.log(`🔍 Error details:`, errorDetails);
      throw staticError;
    }
    
    // First try to estimate gas to get better error info
    console.log(`🔍 Estimating gas for processBatch...`);
    try {
      const gasEstimate = await depository['processBatch']?.estimateGas(entityId, batch);
      console.log(`🔍 Gas estimate: ${gasEstimate?.toString() || 'N/A'}`);
    } catch (gasError) {
      console.error(`❌ Gas estimation failed:`, gasError);
      throw gasError;
    }
    
    // Submit the batch transaction to the real blockchain (entity can sign as any entity for now)
    const tx = await depository['processBatch']!(entityId, batch);
    console.log(`📡 Transaction submitted: ${tx.hash}`);
    
    // Wait for confirmation
    const receipt = await tx.wait();
    console.log(`✅ Transaction confirmed in block ${receipt.blockNumber}`);
    
    return { transaction: tx, receipt };
  } catch (error) {
    console.error(`❌ Failed to submit processBatch to ${jurisdiction.name}:`, error);
    throw error;
  }
};

// Note: setupGovernance is no longer needed - governance is automatically created on entity registration

export const registerNumberedEntityOnChain = async (
  config: ConsensusConfig,
  name: string,
): Promise<{ txHash: string; entityNumber: number }> => {
  if (!config.jurisdiction) {
    throw new Error('Jurisdiction required for on-chain registration');
  }

  try {
    const { entityProvider } = await connectToEthereum(config.jurisdiction);

    const encodedBoard = encodeBoard(config);
    const boardHash = hashBoard(encodedBoard);

    if (DEBUG) console.log(`🏛️ Registering numbered entity "${name}" on chain`);
    if (DEBUG) console.log(`   Jurisdiction: ${config.jurisdiction.name}`);
    if (DEBUG) console.log(`   EntityProvider: ${config.jurisdiction.entityProviderAddress}`);
    if (DEBUG) console.log(`   Board Hash: ${boardHash}`);

    // Test connection by calling nextNumber()
    try {
      const nextNumber = await entityProvider['nextNumber']!();
      if (DEBUG) console.log(`   📊 Next entity number will be: ${nextNumber}`);
    } catch (error) {
      throw new Error(`Failed to call nextNumber(): ${error}`);
    }

    // Call the smart contract
    const tx = await entityProvider['registerNumberedEntity']!(boardHash);
    if (DEBUG) console.log(`   📤 Transaction sent: ${tx.hash}`);

    // Wait for confirmation
    const receipt = await tx.wait();
    if (DEBUG) console.log(`   ✅ Transaction confirmed in block ${receipt.blockNumber}`);

    // Check if transaction reverted
    if (receipt.status === 0) {
      throw new Error(`Transaction reverted! Hash: ${tx.hash}`);
    }

    // Debug: log all events in receipt
    if (DEBUG) {
      console.log(`   📋 Receipt logs count: ${receipt.logs.length}`);
      receipt.logs.forEach((log: any, i: number) => {
        try {
          const parsed = entityProvider.interface.parseLog(log);
          console.log(`   📝 Log ${i}: ${parsed?.name} - ${JSON.stringify(parsed?.args)}`);
        } catch {
          console.log(`   📝 Log ${i}: Unable to parse log - ${log.topics?.[0]}`);
        }
      });
    }

    // Extract entity number from event logs
    const event = receipt.logs.find((log: any) => {
      try {
        const parsed = entityProvider.interface.parseLog(log);
        return parsed?.name === 'EntityRegistered';
      } catch {
        return false;
      }
    });

    if (!event) {
      throw new Error('EntityRegistered event not found in transaction logs');
    }

    const parsedEvent = entityProvider.interface.parseLog(event);
    // const _entityId = parsedEvent?.args[0]; // Entity ID for debugging (unused)
    const entityNumber = Number(parsedEvent?.args[1]);

    if (DEBUG) console.log(`✅ Numbered entity registered!`);
    if (DEBUG) console.log(`   TX: ${tx.hash}`);
    if (DEBUG) console.log(`   Entity Number: ${entityNumber}`);

    return { txHash: tx.hash, entityNumber };
  } catch (error) {
    console.error('❌ Blockchain registration failed:', error);
    throw error;
  }
};

export const assignNameOnChain = async (
  name: string,
  entityNumber: number,
  jurisdiction: JurisdictionConfig,
): Promise<{ txHash: string }> => {
  try {
    const { entityProvider } = await connectToEthereum(jurisdiction);

    if (DEBUG) console.log(`🏷️  Assigning name "${name}" to entity #${entityNumber}`);

    // Call the smart contract (admin only)
    const tx = await entityProvider['assignName']!(name, entityNumber);
    if (DEBUG) console.log(`   📤 Transaction sent: ${tx.hash}`);

    // Wait for confirmation
    const receipt = await tx.wait();
    if (DEBUG) console.log(`   ✅ Transaction confirmed in block ${receipt.blockNumber}`);

    // Check if transaction reverted
    if (receipt.status === 0) {
      throw new Error(`Transaction reverted! Hash: ${tx.hash}`);
    }

    if (DEBUG) console.log(`✅ Name assigned successfully!`);
    if (DEBUG) console.log(`   TX: ${tx.hash}`);

    return { txHash: tx.hash };
  } catch (error) {
    console.error('❌ Name assignment failed:', error);
    throw error;
  }
};

export const getEntityInfoFromChain = async (
  entityId: string,
  jurisdiction: JurisdictionConfig,
): Promise<{ exists: boolean; entityNumber?: number; name?: string }> => {
  try {
    const { entityProvider } = await connectToEthereum(jurisdiction);

    // Try to get entity info
    const entityInfo = await entityProvider['entities']!(entityId);

    if (entityInfo.status === 0) {
      return { exists: false };
    }

    // For numbered entities, get the number and name
    const entityType = detectEntityType(entityId);
    let entityNumber: number | undefined;
    let name: string | undefined;

    if (entityType === 'numbered') {
      const extractedNumber = extractNumberFromEntityId(entityId);
      if (extractedNumber !== null) {
        entityNumber = extractedNumber;
        try {
          const retrievedName = await entityProvider['numberToName']!(entityNumber);
          name = retrievedName || undefined;
        } catch {
          // No name assigned
        }
      }
    }

    return {
      exists: true,
      ...(entityNumber !== undefined ? { entityNumber } : {}),
      ...(name !== undefined ? { name } : {})
    };
  } catch (error) {
    console.error('❌ Failed to get entity info from chain:', error);
    return { exists: false };
  }
};

export const getNextEntityNumber = async (jurisdiction: JurisdictionConfig): Promise<number> => {
  try {
    if (!jurisdiction) {
      throw new Error('Jurisdiction parameter is required');
    }

    // Support both direct property and nested under contracts with type safety
    let entityProviderAddress = jurisdiction.entityProviderAddress;

    if (!entityProviderAddress && 'contracts' in jurisdiction) {
      const jurisdictionWithContracts = jurisdiction as Record<string, unknown> & { contracts?: { entityProvider?: string } };
      const contractAddress = jurisdictionWithContracts.contracts?.entityProvider;
      if (contractAddress) {
        entityProviderAddress = contractAddress;
      }
    }

    if (!jurisdiction.name || !entityProviderAddress) {
      throw new Error('Jurisdiction object is missing required properties (name, entityProvider address)');
    }

    const { entityProvider } = await connectToEthereum(jurisdiction);

    if (DEBUG)
      console.log(`🔍 Fetching next entity number from ${entityProviderAddress} (${jurisdiction.name})`);

    const nextNumber = await entityProvider['nextNumber']!();
    const result = Number(nextNumber);

    if (DEBUG) console.log(`🔢 Next entity number: ${result}`);
    return result;
  } catch (error) {
    console.error('❌ Failed to get next entity number:', error);
    throw error;
  }
};

export const transferNameBetweenEntities = async (
  name: string,
  fromNumber: number,
  toNumber: number,
  _jurisdiction: JurisdictionConfig,
): Promise<string> => {
  if (DEBUG) console.log(`🔄 Transferring name "${name}" from #${fromNumber} to #${toNumber}`);

  // TODO: Implement real blockchain name transfer
  throw new Error('Name transfer not implemented - requires blockchain integration');
};

// === JURISDICTION MANAGEMENT ===

// Load contract configuration and generate jurisdictions
export const generateJurisdictions = async (): Promise<Map<string, JurisdictionConfig>> => {

  const jurisdictions = new Map<string, JurisdictionConfig>();

  try {
    let config: any;

    if (!isBrowser && typeof process !== 'undefined') {
      // Node.js environment - use centralized loader
      console.log('🔍 JURISDICTION SOURCE: Using centralized jurisdiction-loader');
      config = loadJurisdictions();
      console.log('🔍 JURISDICTION DEBUG: Loaded config with contracts:', config.jurisdictions?.ethereum?.contracts);
      console.log('✅ Loaded jurisdictions from centralized loader (cached)');
    } else {
      // Browser environment - fetch from server (use relative path for GitHub Pages compatibility)
      const response = await fetch('./jurisdictions.json');
      if (!response.ok) {
        throw new Error(`Failed to fetch jurisdictions.json: ${response.status} ${response.statusText}`);
      }
      config = await response.json();
      console.log('🔍 JURISDICTION DEBUG: Browser loaded config with contracts:', config.jurisdictions?.ethereum?.contracts);
      console.log('✅ Loaded jurisdictions from server');
    }

    const jurisdictionData = config.jurisdictions;

    // Build jurisdictions from loaded config with type safety
    for (const [key, data] of Object.entries(jurisdictionData)) {
      // Validate structure before using
      if (!data || typeof data !== 'object') {
        console.warn(`🚨 Invalid jurisdiction data for ${key}:`, data);
        continue;
      }
      const jData = data as Record<string, any>;
      jurisdictions.set(key, {
        address: jData['rpc'],
        name: jData['name'],
        entityProviderAddress: jData['contracts']['entityProvider'],
        depositoryAddress: jData['contracts']['depository'],
        chainId: jData['chainId'],
      });
    }
  } catch (error) {
    console.error('❌ Failed to load jurisdictions:', error);
  }

  return jurisdictions;
};

export let DEFAULT_JURISDICTIONS: Map<string, JurisdictionConfig> | null = null;

export const getJurisdictions = async (): Promise<Map<string, JurisdictionConfig>> => {
  // In browser, cache the result to avoid multiple fetches
  if (isBrowser && DEFAULT_JURISDICTIONS !== null) {
    console.log('🔍 JURISDICTIONS: Using cached browser data');
    return DEFAULT_JURISDICTIONS;
  }

  // Generate/fetch jurisdictions
  DEFAULT_JURISDICTIONS = await generateJurisdictions();
  return DEFAULT_JURISDICTIONS!;
};

export const getAvailableJurisdictions = async (): Promise<JurisdictionConfig[]> => {
  const jurisdictions = await getJurisdictions();
  return Array.from(jurisdictions.values());
};

export const getJurisdictionByAddress = async (address: string): Promise<JurisdictionConfig | undefined> => {
  const jurisdictions = await getJurisdictions();
  return jurisdictions.get(address);
};

export const submitSettle = async (jurisdiction: JurisdictionConfig, leftEntity: string, rightEntity: string, diffs: any[]) => {
  try {
    console.log(`⚖️ Submitting settle transaction between ${leftEntity.slice(0, 10)}... and ${rightEntity.slice(0, 10)}...`);
    console.log(`🔍 DIFFS:`, diffs.map(d => ({
      ...d,
      leftDiff: d.leftDiff.toString(),
      rightDiff: d.rightDiff.toString(),
      collateralDiff: d.collateralDiff.toString()
    })));

    const { depository, provider } = await connectToEthereum(jurisdiction);
    console.log(`🔍 CONTRACT ADDRESS: ${depository.target}`);

    // Check if contract exists
    const code = await provider.getCode(depository.target);
    if (code === '0x') {
      throw new Error('Contract not deployed at this address');
    }

    // Call settle function
    console.log(`📤 Calling settle function...`);
    const tx = await depository['settle']!(leftEntity, rightEntity, diffs);
    console.log(`💫 Transaction sent: ${tx.hash}`);

    // Wait for confirmation
    const receipt = await tx.wait();
    console.log(`✅ Settlement confirmed in block ${receipt.blockNumber}`);

    if (receipt.status === 0) {
      throw new Error(`Settlement transaction reverted! Hash: ${tx.hash}`);
    }

    console.log(`🎉 Settlement successful! Both entities should receive SettlementProcessed events`);
    return { txHash: tx.hash, blockNumber: receipt.blockNumber };

  } catch (error) {
    console.error('❌ Settlement failed:', error);
    throw error;
  }
};

export const submitReserveToReserve = async (jurisdiction: JurisdictionConfig, fromEntity: string, toEntity: string, tokenId: number, amount: string) => {
  try {
    console.log(`💸 DIRECT R2R: ${fromEntity.slice(0,10)} → ${toEntity.slice(0,10)}, token ${tokenId}, amount ${amount}`);

    const { depository, provider } = await connectToEthereum(jurisdiction);
    console.log(`🔍 CONTRACT ADDRESS: ${depository.target}`);

    // Check if contract exists
    const code = await provider.getCode(depository.target);
    if (code === '0x') {
      throw new Error('Contract not deployed at this address');
    }

    // Call direct reserveToReserve function
    console.log(`📤 Calling reserveToReserve(${fromEntity}, ${toEntity}, ${tokenId}, ${amount})...`);
    const tx = await depository['reserveToReserve']!(fromEntity, toEntity, tokenId, amount);
    console.log(`💫 Transaction sent: ${tx.hash}`);

    // Wait for confirmation
    const receipt = await tx.wait();
    console.log(`✅ R2R confirmed in block ${receipt.blockNumber}`);

    if (receipt.status === 0) {
      throw new Error(`R2R transaction reverted! Hash: ${tx.hash}`);
    }

    console.log(`🎉 Direct R2R successful!`);
    return { txHash: tx.hash, blockNumber: receipt.blockNumber };

  } catch (error) {
    console.error('❌ Direct R2R failed:', error);
    throw error;
  }
};

--- src/state-helpers.ts ---
/**
 * XLN State Management Helpers
 * Utilities for entity replica cloning, snapshots, and state persistence
 */

import { encode } from './snapshot-coder';
import type { EntityInput, EntityReplica, EntityState, Env, EnvSnapshot, ServerInput, AccountMachine } from './types';
import { DEBUG } from './utils';
import { validateEntityState } from './validation-utils';

// === CLONING UTILITIES ===
export const cloneMap = <K, V>(map: Map<K, V>) => new Map(map);
export const cloneArray = <T>(arr: T[]) => [...arr];

/**
 * Creates a safe deep clone of entity state with guaranteed jBlock preservation
 * This prevents the jBlock corruption bugs that occur with manual state spreading
 */
export function cloneEntityState(entityState: EntityState): EntityState {
  // CRITICAL: Log jBlock before and after cloning
  const originalJBlock = entityState.jBlock;
  console.log(`🔍 CLONE-TRACE: About to clone entity state, jBlock=${originalJBlock} (${typeof originalJBlock})`);

  // Use structuredClone for deep cloning with fallback
  try {
    const cloned = structuredClone(entityState);

    // CRITICAL: Validate jBlock was preserved correctly
    if (typeof cloned.jBlock !== 'number') {
      console.error(`💥 CLONE-CORRUPTION: structuredClone corrupted jBlock!`);
      console.error(`💥   Original: ${entityState.jBlock} (${typeof entityState.jBlock})`);
      console.error(`💥   Cloned: ${cloned.jBlock} (${typeof cloned.jBlock})`);
      cloned.jBlock = entityState.jBlock ?? 0; // Force fix
    }

    console.log(`✅ CLONE-SUCCESS: Cloned state, jBlock=${cloned.jBlock} (${typeof cloned.jBlock})`);

    // VALIDATE AT SOURCE: Guarantee type safety from this point forward
    return validateEntityState(cloned, 'cloneEntityState.structuredClone');
  } catch (error) {
    console.warn(`⚠️ structuredClone failed, using manual clone: ${(error as Error).message}`);
    const manual = manualCloneEntityState(entityState);
    console.log(`✅ MANUAL-CLONE: Manual clone completed, jBlock=${manual.jBlock} (${typeof manual.jBlock})`);

    // VALIDATE AT SOURCE: Guarantee type safety from manual clone path too
    return validateEntityState(manual, 'cloneEntityState.manual');
  }
}

/**
 * Manual entity state cloning with explicit jBlock preservation
 * Fallback for environments that don't support structuredClone
 */
function manualCloneEntityState(entityState: EntityState): EntityState {
  return {
    ...entityState,
    nonces: cloneMap(entityState.nonces),
    messages: cloneArray(entityState.messages),
    proposals: new Map(
      Array.from(entityState.proposals.entries()).map(([id, proposal]) => [
        id,
        { ...proposal, votes: cloneMap(proposal.votes) },
      ]),
    ),
    reserves: cloneMap(entityState.reserves),
    accounts: new Map(
      Array.from(entityState.accounts.entries()).map(([id, account]) => [
        id,
        {
          ...account,
          mempool: cloneArray(account.mempool),
          deltas: cloneMap(account.deltas),
          proofHeader: { ...account.proofHeader },
          proofBody: {
            tokenIds: [...account.proofBody.tokenIds],
            deltas: [...account.proofBody.deltas],
          },
        },
      ]),
    ),
    accountInputQueue: cloneArray(entityState.accountInputQueue || []),
    // CRITICAL: Explicit jBlock preservation for financial integrity
    jBlock: entityState.jBlock ?? 0,
  };
}

/**
 * Deep clone entity replica with all nested state properly cloned
 * Uses cloneEntityState as the entry point for state cloning
 */
export const cloneEntityReplica = (replica: EntityReplica): EntityReplica => {
  return {
    entityId: replica.entityId,
    signerId: replica.signerId,
    state: cloneEntityState(replica.state), // Use unified entity state cloning
    mempool: cloneArray(replica.mempool),
    ...(replica.proposal && {
      proposal: {
        height: replica.proposal.height,
        txs: cloneArray(replica.proposal.txs),
        hash: replica.proposal.hash,
        newState: replica.proposal.newState,
        signatures: cloneMap(replica.proposal.signatures),
      }
    }),
    ...(replica.lockedFrame && {
      lockedFrame: {
        height: replica.lockedFrame.height,
        txs: cloneArray(replica.lockedFrame.txs),
        hash: replica.lockedFrame.hash,
        newState: replica.lockedFrame.newState,
        signatures: cloneMap(replica.lockedFrame.signatures),
      }
    }),
    isProposer: replica.isProposer,
  };
};

export const captureSnapshot = (
  env: Env,
  envHistory: EnvSnapshot[],
  db: any,
  serverInput: ServerInput,
  serverOutputs: EntityInput[],
  description: string,
): void => {
  const snapshot: EnvSnapshot = {
    height: env.height,
    timestamp: env.timestamp,
    replicas: new Map(Array.from(env.replicas.entries()).map(([key, replica]) => [key, cloneEntityReplica(replica)])),
    serverInput: {
      serverTxs: [...serverInput.serverTxs],
      entityInputs: serverInput.entityInputs.map(input => ({
        entityId: input.entityId,
        signerId: input.signerId,
        ...(input.entityTxs && { entityTxs: [...input.entityTxs] }),
        ...(input.precommits && { precommits: new Map(input.precommits) }),
        ...(input.proposedFrame && { proposedFrame: input.proposedFrame }),
      })),
    },
    serverOutputs: serverOutputs.map(output => ({
      entityId: output.entityId,
      signerId: output.signerId,
      ...(output.entityTxs && { entityTxs: [...output.entityTxs] }),
      ...(output.precommits && { precommits: new Map(output.precommits) }),
      ...(output.proposedFrame && { proposedFrame: output.proposedFrame }),
    })),
    description,
  };

  envHistory.push(snapshot);

  // --- PERSISTENCE WITH BATCH OPERATIONS ---
  // Use batch operations for better performance
  const batch = db.batch();
  batch.put(Buffer.from(`snapshot:${snapshot.height}`), encode(snapshot));
  batch.put(Buffer.from('latest_height'), Buffer.from(snapshot.height.toString()));

  batch.write();

  if (DEBUG) {
    console.log(`📸 Snapshot captured: "${description}" (${envHistory.length} total)`);
    if (serverInput.serverTxs.length > 0) {
      console.log(`    🖥️  ServerTxs: ${serverInput.serverTxs.length}`);
      serverInput.serverTxs.forEach((tx, i) => {
        console.log(
          `      ${i + 1}. ${tx.type} ${tx.entityId}:${tx.signerId} (${tx.data.isProposer ? 'proposer' : 'validator'})`,
        );
      });
    }
    if (serverInput.entityInputs.length > 0) {
      console.log(`    📨 EntityInputs: ${serverInput.entityInputs.length}`);
      serverInput.entityInputs.forEach((input, i) => {
        const parts = [];
        if (input.entityTxs?.length) parts.push(`${input.entityTxs.length} txs`);
        if (input.precommits?.size) parts.push(`${input.precommits.size} precommits`);
        if (input.proposedFrame) parts.push(`frame: ${input.proposedFrame.hash.slice(0, 10)}...`);
        console.log(`      ${i + 1}. ${input.entityId}:${input.signerId} (${parts.join(', ') || 'empty'})`);
      });
    }
  }
};

// === ACCOUNT MACHINE HELPERS ===

/**
 * Clone AccountMachine for validation (replaces dryRun pattern)
 */
export function cloneAccountMachine(account: AccountMachine): AccountMachine {
  try {
    return structuredClone(account);
  } catch (error) {
    console.warn(`⚠️ structuredClone failed for AccountMachine, using manual clone`);
    return manualCloneAccountMachine(account);
  }
}

/**
 * Manual AccountMachine cloning
 */
function manualCloneAccountMachine(account: AccountMachine): AccountMachine {
  const result: AccountMachine = {
    counterpartyEntityId: account.counterpartyEntityId,
    mempool: [...account.mempool],
    currentFrame: {
      ...account.currentFrame,
      tokenIds: [...account.currentFrame.tokenIds],
      deltas: [...account.currentFrame.deltas],
    },
    sentTransitions: account.sentTransitions,
    ackedTransitions: account.ackedTransitions,
    deltas: new Map(Array.from(account.deltas.entries()).map(([key, delta]) => [key, { ...delta }])),
    globalCreditLimits: { ...account.globalCreditLimits },
    currentFrameId: account.currentFrameId,
    pendingSignatures: [...account.pendingSignatures],
    rollbackCount: account.rollbackCount,
    sendCounter: account.sendCounter,
    receiveCounter: account.receiveCounter,
    frameHistory: [...account.frameHistory], // Clone frame history array
    proofHeader: { ...account.proofHeader },
    proofBody: {
      ...account.proofBody,
      tokenIds: [...account.proofBody.tokenIds],
      deltas: [...account.proofBody.deltas],
    },
  };

  // Add optional properties if they exist
  if (account.pendingFrame) {
    result.pendingFrame = {
      ...account.pendingFrame,
      accountTxs: [...account.pendingFrame.accountTxs],
      tokenIds: [...account.pendingFrame.tokenIds],
      deltas: [...account.pendingFrame.deltas]
    };
  }

  if (account.clonedForValidation) {
    result.clonedForValidation = manualCloneAccountMachine(account.clonedForValidation);
  }

  if (account.hankoSignature) {
    result.hankoSignature = account.hankoSignature;
  }

  return result;
}

--- src/prepopulate.ts ---
/**
 * Prepopulate XLN with H-shaped network topology
 * Creates 10 entities: 2 hubs (E1-E2) and 8 users (E3-E10)
 * Visual structure: H-shaped for clean 1px=$1 bars visualization
 */

import type { Env, EntityInput } from './types';
import { applyServerInput } from './server';
import { createNumberedEntity } from './entity-factory';
import { getAvailableJurisdictions } from './evm';

export async function prepopulate(env: Env, processUntilEmpty: (env: Env, inputs?: EntityInput[]) => Promise<any>): Promise<void> {
  console.log('🌐 Starting XLN Prepopulation');
  console.log('================================');
  console.log('Creating H-shaped network topology:');
  console.log('  • 2 Hubs (E1, E2) - connected crossbar');
  console.log('  • 4 Users (E3-E6) - split between hubs');
  console.log('    - E3, E4 → Hub E1');
  console.log('    - E5, E6 → Hub E2');
  console.log('  Visual: Clean H-shape with 6 entities total');
  console.log('================================\n');

  // Load jurisdiction configuration using the browser-compatible function
  const jurisdictions = await getAvailableJurisdictions();
  const ethereum = jurisdictions.find(j => j.name.toLowerCase() === 'ethereum');

  if (!ethereum) {
    throw new Error('Ethereum jurisdiction not found in available jurisdictions');
  }

  console.log(`📋 Using jurisdiction: ${ethereum.name}`);
  console.log(`  ├─ EntityProvider: ${ethereum.entityProviderAddress}`);
  console.log(`  └─ Depository: ${ethereum.depositoryAddress}`);

  // Step 1: Create 6 entities by getting proper entity IDs from blockchain
  console.log('📦 Step 1: Creating 6 entities with blockchain-assigned IDs...');
  console.log('  Each entity will get sequential ID from the blockchain');

  const entities: Array<{id: string, signer: string, isHub: boolean}> = [];
  const createEntityTxs = [];

  for (let i = 1; i <= 6; i++) {
    const signer = `s${i}`;
    const isHub = i <= 2; // Only first 2 entities are hubs (H-shaped topology)
    const entityName = isHub ? `Hub ${i}` : `User ${i}`;

    // Create numbered entity through blockchain to get proper ID
    try {
      const { config, entityNumber, entityId } = await createNumberedEntity(
        entityName,
        [signer],  // Single validator
        1n,        // Threshold of 1
        ethereum   // Jurisdiction
      );

      entities.push({ id: entityId, signer, isHub });
      console.log(`  ✓ Created ${entityName}: Entity #${entityNumber} (${entityId.slice(0, 10)}...)`);

      // Add to batch for import
      createEntityTxs.push({
        type: 'importReplica' as const,
        entityId,
        signerId: signer,
        data: {
          isProposer: true,
          config
        }
      });
    } catch (error) {
      console.error(`  ❌ Failed to create ${entityName}:`, error);
      // For demo/testing, fall back to simple sequential IDs if blockchain fails
      const entityNumber = i;
      const entityId = '0x' + entityNumber.toString(16).padStart(64, '0');
      entities.push({ id: entityId, signer, isHub });

      createEntityTxs.push({
        type: 'importReplica' as const,
        entityId,
        signerId: signer,
        data: {
          isProposer: true,
          config: {
            mode: 'proposer-based' as const,
            threshold: 1n,
            validators: [signer],
            shares: { [signer]: 1n },
            jurisdiction: ethereum
          }
        }
      });
      console.log(`  ⚠️ Using fallback ID for ${entityName}: Entity #${entityNumber}`);
    }
  }

  // Import all entities in one batch
  await applyServerInput(env, {
    serverTxs: createEntityTxs,
    entityInputs: []
  });

  console.log(`\n  ✅ Imported ${entities.length} entities`);
  entities.forEach((e) => {
    const entityNum = parseInt(e.id.slice(2), 16);  // Extract number from hex ID
    console.log(`    • Entity #${entityNum}: ${e.isHub ? 'HUB' : 'User'} (signer: ${e.signer})`);
  });

  console.log('\n📡 Step 2: Connecting the two hubs (H crossbar)...');

  // Step 2: Connect Hub 1 and Hub 2 (the crossbar of the H)
  const hub1 = entities[0];
  const hub2 = entities[1];

  if (!hub1 || !hub2) {
    throw new Error('Failed to create hubs');
  }

  // Hub1 opens account with Hub2
  await processUntilEmpty(env, [{
    entityId: hub1.id,
    signerId: hub1.signer,
    entityTxs: [{
      type: 'openAccount',
      data: { targetEntityId: hub2.id }
    }]
  }]);

  const hub1Num = parseInt(hub1.id.slice(2), 16);
  const hub2Num = parseInt(hub2.id.slice(2), 16);
  console.log(`  🔗 Hub E${hub1Num} ←→ Hub E${hub2Num} connected (H crossbar)`);

  console.log('\n👥 Step 3: Connecting users to hubs (H vertical bars)...');

  // Step 3: Connect users to hubs - Vertical H shape
  // Layout sorts by: degree DESC, then entityId ASC
  // After sorting (assuming entities created as E1, E2, E3, E4, E5, E6):
  //   sorted[0] = E1 (hub, left) - degree 3
  //   sorted[1] = E2 (hub, right) - degree 3
  //   sorted[2] = E3 (user, top-left) - degree 1
  //   sorted[3] = E4 (user, top-right) - degree 1
  //   sorted[4] = E5 (user, bottom-left) - degree 1
  //   sorted[5] = E6 (user, bottom-right) - degree 1
  //
  // For H pattern:
  //   E3 (top-left) ──── E1 (hub left)
  //   E5 (bottom-left) ─ E1 (hub left)
  //   E4 (top-right) ─── E2 (hub right)
  //   E6 (bottom-right) ─ E2 (hub right)

  const users = entities.slice(2); // [E3, E4, E5, E6]

  // Alternate users between hubs: E3→hub1, E4→hub2, E5→hub1, E6→hub2
  for (let i = 0; i < users.length; i++) {
    const user = users[i];
    const hub = (i % 2 === 0) ? hub1 : hub2; // Even index → hub1, odd → hub2

    // User opens account with hub
    await processUntilEmpty(env, [{
      entityId: user.id,
      signerId: user.signer,
      entityTxs: [{
        type: 'openAccount',
        data: { targetEntityId: hub.id }
      }]
    }]);

    const userNum = parseInt(user.id.slice(2), 16);
    const hubNum = parseInt(hub.id.slice(2), 16);
    console.log(`  👤 User E${userNum} → Hub E${hubNum} connected (vertical bar)`);
  }

  console.log('\n🎯 Step 4: Setting hub profiles with lower fees...');

  // Step 4: Update hub profiles with lower routing fees
  for (const hub of [hub1, hub2]) {
    const hubNum = parseInt(hub.id.slice(2), 16);

    // Send profile update to set hub capabilities and lower fees
    await processUntilEmpty(env, [{
      entityId: hub.id,
      signerId: hub.signer,
      entityTxs: [{
        type: 'profile-update',
        data: {
          profile: {
            entityId: hub.id,
            name: `Hub ${hubNum}`,
            bio: `Professional routing hub with high capacity and low fees`,
            isHub: true,
            routingFeePPM: 50, // Lower fee for hubs (0.005%)
            baseFee: 0n,
          }
        }
      }]
    }]);

    console.log(`  💰 Hub E${hubNum} - routing fee: 50 PPM (0.005%)`);
  }

  console.log('\n================================');
  console.log('✅ Prepopulation Complete!');
  console.log('\nH-shaped network topology created:');
  console.log('  • 2 Hubs connected (H crossbar)');
  console.log('  • 4 Users: 2 per hub (H vertical bars)');
  console.log('  • Total accounts: 5 (1 hub-to-hub + 4 user-to-hub)');
  console.log('  • Topology: Clean 6-entity visualization (perfect number)');
  console.log('\nYou can now:');
  console.log('  1. View clean H-shaped topology in bird view');
  console.log('  2. Send payments between any entities');
  console.log('  3. Payments will route through hubs automatically');
  console.log('================================\n');
}
--- src/server.ts ---
// for regular use > bun run src/server.ts
// for debugging > bun repl
// await import('./debug.js');
// FORCE AUTO-REBUILD: Fixed signerId consistency and fintech type safety

// Import utilities and types
// High-level database using Level polyfill (works in both Node.js and browser)
import { Level } from 'level';

import { applyEntityInput, mergeEntityInputs } from './entity-consensus';
// TODO: Re-enable account-tx imports after fixing export issues
// import {
//   sendAccountInputMessage,
//   sendDirectPaymentToEntity, 
//   sendCreditLimitUpdateToEntity,
//   sendAccountAcknowledgment,
//   sendBatchAccountInputs,
//   getCrossEntityMessagingSummary,
//   validateAccountInputMessage
// } from './account-tx/messaging';
import {
  createLazyEntity,
  createNumberedEntity,
  detectEntityType,
  encodeBoard,
  generateLazyEntityId,
  generateNamedEntityId,
  generateNumberedEntityId,
  hashBoard,
  isEntityRegistered,
  requestNamedEntity,
  resolveEntityIdentifier,
} from './entity-factory';
import {
  assignNameOnChain,
  connectToEthereum,
  debugFundReserves,
  getAvailableJurisdictions,
  getEntityInfoFromChain,
  getJurisdictionByAddress,
  getNextEntityNumber,
  registerNumberedEntityOnChain,
  submitProcessBatch,
  submitPrefundAccount,
  submitSettle,
  submitReserveToReserve,
  transferNameBetweenEntities,
} from './evm';
import { createGossipLayer } from './gossip';
import { type Profile } from './gossip.js';
import { loadPersistedProfiles } from './gossip-loader';
import { setupJEventWatcher, JEventWatcher } from './j-event-watcher';
import {
  createProfileUpdateTx,
  getEntityDisplayInfo as getEntityDisplayInfoFromProfileOriginal,
  resolveEntityName as resolveEntityNameOriginal,
  searchEntityNames as searchEntityNamesOriginal,
} from './name-resolution';
import { runDemo } from './rundemo';
import { decode, encode } from './snapshot-coder'; // encode used in exports
import { deriveDelta, isLeft, getTokenInfo, formatTokenAmount, createDemoDelta, getDefaultCreditLimit } from './account-utils';
import {
  formatTokenAmount as formatTokenAmountEthers,
  parseTokenAmount,
  convertTokenPrecision,
  calculatePercentage as calculatePercentageEthers,
  formatAssetAmount as formatAssetAmountEthers,
  BigIntMath,
  FINANCIAL_CONSTANTS
} from './financial-utils';
import { captureSnapshot, cloneEntityReplica } from './state-helpers';
import { getEntityNumber } from './entity-helpers';
import { safeStringify } from './serialization-utils';
import { validateDelta, validateAccountDeltas, createDefaultDelta, isDelta, validateEntityInput, validateEntityOutput } from './validation-utils';
import { EntityInput, EntityReplica, Env, ServerInput } from './types';
import {
  clearDatabase,
  DEBUG,
  formatEntityDisplay,
  formatSignerDisplay,
  generateEntityAvatar,
  generateSignerAvatar,
  getEntityDisplayInfo,
  getSignerDisplayInfo,
  isBrowser,
  log,
} from './utils';

// --- Database Setup ---
// Level polyfill: Node.js uses filesystem, Browser uses IndexedDB
export const db: Level<Buffer, Buffer> = new Level('db', {
  valueEncoding: 'buffer',
  keyEncoding: 'binary',
});

declare const console: any;

// === ETHEREUM INTEGRATION ===

// === SVELTE REACTIVITY INTEGRATION ===
// Callback that Svelte can register to get notified of env changes
let envChangeCallback: ((env: Env) => void) | null = null;

// Module-level environment variable
let env: Env;

// Module-level j-watcher instance - prevent multiple instances
let jWatcher: JEventWatcher | null = null;
let jWatcherStarted = false;

export const registerEnvChangeCallback = (callback: (env: Env) => void) => {
  envChangeCallback = callback;
};

const notifyEnvChange = (env: Env) => {
  if (envChangeCallback) {
    envChangeCallback(env);
  }
};

// J-Watcher initialization
const startJEventWatcher = async (env: Env): Promise<void> => {
  try {
    // Get the Ethereum jurisdiction
    const ethereum = await getJurisdictionByAddress('ethereum');
    if (!ethereum) {
      console.warn('⚠️ Ethereum jurisdiction not found, skipping j-watcher');
      return;
    }

    // Set up j-watcher with the deployed contracts
    jWatcher = await setupJEventWatcher(
      env,
      ethereum.address, // RPC URL
      ethereum.entityProviderAddress,
      ethereum.depositoryAddress
    );

    console.log('✅ J-Event Watcher started successfully');
    console.log(`🔭 Monitoring: ${ethereum.address}`);
    console.log(`📍 EntityProvider: ${ethereum.entityProviderAddress}`);
    console.log(`📍 Depository: ${ethereum.depositoryAddress}`);
    
    // J-watcher now handles its own periodic sync every 500ms
    // Set up a periodic check to process any queued events from j-watcher
    setInterval(async () => {
      if (env.serverInput.entityInputs.length > 0) {
        const eventCount = env.serverInput.entityInputs.length;
        console.log(`🔭 J-WATCHER: Processing ${eventCount} J-machine events`);
        
        // Process the queued entity inputs from j-watcher
        await applyServerInput(env, { 
          serverTxs: [], 
          entityInputs: [...env.serverInput.entityInputs] 
        });
        
        // Clear the processed inputs
        env.serverInput.entityInputs.length = 0;
      }
    }, 100); // Check every 100ms to process j-watcher events quickly
    
  } catch (error) {
    console.error('❌ Failed to start J-Event Watcher:', error);
  }
};

// Note: History is now stored in env.history (no global variable needed)

// === SNAPSHOT UTILITIES ===
// All cloning utilities now moved to state-helpers.ts

// All snapshot functionality now moved to state-helpers.ts

// === UTILITY FUNCTIONS ===

const applyServerInput = async (
  env: Env,
  serverInput: ServerInput,
): Promise<{ entityOutbox: EntityInput[]; mergedInputs: EntityInput[] }> => {
  const startTime = Date.now();

  try {
    // SECURITY: Validate server input
    if (!serverInput) {
      log.error('❌ Null server input provided');
      return { entityOutbox: [], mergedInputs: [] };
    }
    if (!Array.isArray(serverInput.serverTxs)) {
      log.error(`❌ Invalid serverTxs: expected array, got ${typeof serverInput.serverTxs}`);
      return { entityOutbox: [], mergedInputs: [] };
    }
    if (!Array.isArray(serverInput.entityInputs)) {
      log.error(`❌ Invalid entityInputs: expected array, got ${typeof serverInput.entityInputs}`);
      return { entityOutbox: [], mergedInputs: [] };
    }

    // SECURITY: Resource limits
    if (serverInput.serverTxs.length > 1000) {
      log.error(`❌ Too many server transactions: ${serverInput.serverTxs.length} > 1000`);
      return { entityOutbox: [], mergedInputs: [] };
    }
    if (serverInput.entityInputs.length > 10000) {
      log.error(`❌ Too many entity inputs: ${serverInput.entityInputs.length} > 10000`);
      return { entityOutbox: [], mergedInputs: [] };
    }

    // Merge new serverInput into env.serverInput
    env.serverInput.serverTxs.push(...serverInput.serverTxs);
    env.serverInput.entityInputs.push(...serverInput.entityInputs);

    // Merge all entityInputs in env.serverInput
    const mergedInputs = mergeEntityInputs(env.serverInput.entityInputs);

    // FINTECH-LEVEL TYPE SAFETY: Validate all merged inputs at entry point
    mergedInputs.forEach((input, i) => {
      try {
        validateEntityInput(input);
      } catch (error) {
        console.error(`🚨 CRITICAL FINANCIAL ERROR: Invalid merged EntityInput[${i}]!`, {
          error: (error as Error).message,
          input
        });
        throw error; // Fail fast
      }
    });

    const entityOutbox: EntityInput[] = [];

    if (DEBUG) {
      console.log(`\n=== TICK ${env.height} ===`);
      console.log(
        `Server inputs: ${serverInput.serverTxs.length} new serverTxs, ${serverInput.entityInputs.length} new entityInputs`,
      );
      console.log(
        `Total in env: ${env.serverInput.serverTxs.length} serverTxs, ${env.serverInput.entityInputs.length} entityInputs (merged to ${mergedInputs.length})`,
      );
      if (mergedInputs.length > 0) {
        console.log(`🔄 Processing merged inputs:`);
        mergedInputs.forEach((input, i) => {
          const parts = [];
          if (input.entityTxs?.length) parts.push(`${input.entityTxs.length} txs`); // Debug logging - keep defensive
          if (input.precommits?.size) parts.push(`${input.precommits.size} precommits`);
          if (input.proposedFrame) parts.push(`frame: ${input.proposedFrame.hash.slice(0, 10)}...`);
          console.log(`  ${i + 1}. ${input.entityId}:${input.signerId} (${parts.join(', ') || 'empty'})`);
        });
      }
    }

    // Process server transactions (replica imports) from env.serverInput
    console.log(
      `🔍 REPLICA-DEBUG: Processing ${env.serverInput.serverTxs.length} serverTxs, current replicas: ${env.replicas.size}`,
    );
    env.serverInput.serverTxs.forEach(serverTx => {
      if (serverTx.type === 'importReplica') {
        if (DEBUG)
          console.log(
            `Importing replica Entity #${formatEntityDisplay(serverTx.entityId)}:${formatSignerDisplay(serverTx.signerId)} (proposer: ${serverTx.data.isProposer})`,
          );

        const replicaKey = `${serverTx.entityId}:${serverTx.signerId}`;
        env.replicas.set(replicaKey, {
          entityId: serverTx.entityId,
          signerId: serverTx.signerId,
          state: {
            entityId: serverTx.entityId, // Store entityId in state
            height: 0,
            timestamp: env.timestamp,
            nonces: new Map(),
            messages: [],
            proposals: new Map(),
            config: serverTx.data.config,
            // 💰 Initialize financial state
            reserves: new Map(), // tokenId -> bigint amount
            accounts: new Map(), // counterpartyEntityId -> AccountMachine

            // 🔭 J-machine tracking
            jBlock: 0, // Must start from 0 to resync all reserves
          },
          mempool: [],
          isProposer: serverTx.data.isProposer,
        });
        // Validate jBlock immediately after creation
        const createdReplica = env.replicas.get(replicaKey);
        const actualJBlock = createdReplica?.state.jBlock;
        console.log(`🔍 REPLICA-DEBUG: Added replica ${replicaKey}, jBlock should be 0, actually is: ${actualJBlock} (type: ${typeof actualJBlock})`);

        // Broadcast initial profile to gossip layer
        if (env.gossip && createdReplica) {
          const profile = {
            entityId: serverTx.entityId,
            capabilities: [],
            hubs: [],
            metadata: {
              lastUpdated: Date.now(),
              routingFeePPM: 100, // Default 100 PPM (0.01%)
              baseFee: 0n,
            },
            accounts: [], // No accounts yet
          };
          env.gossip.announce(profile);
          console.log(`📡 Broadcast initial profile for Entity #${formatEntityDisplay(serverTx.entityId)}`);
        }

        if (typeof actualJBlock !== 'number') {
          console.error(`💥 ENTITY-CREATION-BUG: Just created entity with invalid jBlock!`);
          console.error(`💥   Expected: 0 (number), Got: ${typeof actualJBlock}, Value: ${actualJBlock}`);
          // Force fix immediately
          if (createdReplica) {
            createdReplica.state.jBlock = 0;
            console.log(`💥   FIXED: Set jBlock to 0 for replica ${replicaKey}`);
          }
        }
      }
    });
    console.log(`🔍 REPLICA-DEBUG: After processing serverTxs, total replicas: ${env.replicas.size}`);

    // Simple watcher automatically syncs all proposer replicas from their last jBlock

    // Process entity inputs - check for j-events
    console.log(`🔍 SERVER-PROCESSING: About to process ${mergedInputs.length} merged entity inputs`);
    for (const entityInput of mergedInputs) {
      // Track j-events in this input - entityInput.entityTxs guaranteed by validateEntityInput above
      const jEventCount = entityInput.entityTxs!.filter(tx => tx.type === 'j_event').length;
      if (jEventCount > 0) {
        console.log(`🚨 FOUND-J-EVENTS: Entity ${entityInput.entityId.slice(0,10)}... has ${jEventCount} j-events from ${entityInput.signerId}`);
        entityInput.entityTxs!.filter(tx => tx.type === 'j_event').forEach((jEvent, i) => {
          console.log(`🚨   J-EVENT-${i}: type=${jEvent.data.event.type}, block=${jEvent.data.blockNumber}, observedAt=${new Date(jEvent.data.observedAt).toLocaleTimeString()}`);
        });
      }

      // Handle empty signerId for AccountInputs - auto-route to proposer
      let actualSignerId = entityInput.signerId;
      if (!actualSignerId || actualSignerId === '') {
        // Check if this is an AccountInput that needs auto-routing
        const hasAccountInput = entityInput.entityTxs!.some(tx => tx.type === 'accountInput');
        if (hasAccountInput) {
          // Find the proposer for this entity
          const entityReplicaKeys = Array.from(env.replicas.keys()).filter(key => key.startsWith(entityInput.entityId + ':'));
          if (entityReplicaKeys.length > 0) {
            const firstReplicaKey = entityReplicaKeys[0];
            if (!firstReplicaKey) {
              console.error(`❌ Invalid replica key for entity ${entityInput.entityId}`);
              continue;
            }
            const firstReplica = env.replicas.get(firstReplicaKey);
            if (firstReplica?.state.config.validators[0]) {
              actualSignerId = firstReplica.state.config.validators[0];
              console.log(`🔄 AUTO-ROUTE: Routing AccountInput to proposer ${actualSignerId} for entity ${entityInput.entityId.slice(0,10)}...`);
            }
          }
        }

        // Fallback if still no signerId
        if (!actualSignerId || actualSignerId === '') {
          console.warn(`⚠️ No signerId and unable to determine proposer for entity ${entityInput.entityId.slice(0,10)}...`);
          continue; // Skip this input
        }
      }

      const replicaKey = `${entityInput.entityId}:${actualSignerId}`;
      const entityReplica = env.replicas.get(replicaKey);

      console.log(`🔍 REPLICA-LOOKUP: Key="${replicaKey}"`);
      console.log(`🔍 REPLICA-LOOKUP: Found replica: ${!!entityReplica}`);
      console.log(`🔍 REPLICA-LOOKUP: Input txs: ${entityInput.entityTxs!.length}`);
      if (entityInput.entityTxs && entityInput.entityTxs.length > 0) {
        console.log(
          `🔍 REPLICA-LOOKUP: Tx types:`,
          entityInput.entityTxs.map(tx => tx.type),
        );
      }
      if (!entityReplica) {
        console.log(`🔍 REPLICA-LOOKUP: Available replica keys:`, Array.from(env.replicas.keys()));
      }

      if (entityReplica) {
        if (DEBUG) {
          console.log(`Processing input for ${replicaKey}:`);
          if (entityInput.entityTxs!.length) console.log(`  → ${entityInput.entityTxs!.length} transactions`);
          if (entityInput.proposedFrame) console.log(`  → Proposed frame: ${entityInput.proposedFrame.hash}`);
          if (entityInput.precommits?.size) console.log(`  → ${entityInput.precommits.size} precommits`);
        }

        const { newState, outputs } = await applyEntityInput(env, entityReplica, entityInput);
        console.log(`🔍 APPLY-ENTITY-INPUT-RESULT: Got ${outputs.length} outputs from ${replicaKey}`);

        // CRITICAL FIX: Update the replica in the environment with the new state
        env.replicas.set(replicaKey, { ...entityReplica, state: newState });

        // FINTECH-LEVEL TYPE SAFETY: Validate all entity outputs before routing
        outputs.forEach((output, index) => {
          try {
            validateEntityOutput(output);
          } catch (error) {
            console.error(`🚨 CRITICAL FINANCIAL ERROR: Invalid EntityOutput[${index}] from ${replicaKey}!`, {
              error: (error as Error).message,
              output
            });
            throw error; // Fail fast to prevent financial routing corruption
          }
        });

        entityOutbox.push(...outputs);
        console.log(`🔍 ENTITY-OUTBOX-AFTER-PUSH: entityOutbox now has ${entityOutbox.length} outputs`);
      }
    }

    // Only create server frame if there's actual work to do
    const hasServerTxs = env.serverInput.serverTxs.length > 0;
    const hasEntityInputs = mergedInputs.length > 0;
    const hasOutputs = entityOutbox.length > 0;

    if (hasServerTxs || hasEntityInputs || hasOutputs) {
      // Update env (mutable)
      env.height++;
      env.timestamp = Date.now();

      // Capture snapshot BEFORE clearing (to show what was actually processed)
      const inputDescription = `Tick ${env.height - 1}: ${env.serverInput.serverTxs.length} serverTxs, ${mergedInputs.length} merged entityInputs → ${entityOutbox.length} outputs`;
      const processedInput = {
        serverTxs: [...env.serverInput.serverTxs],
        entityInputs: [...mergedInputs], // Use merged inputs instead of raw inputs
      };

      // Clear processed data from env.serverInput
      env.serverInput.serverTxs.length = 0;
      env.serverInput.entityInputs.length = 0;

      // Capture snapshot with the actual processed input and outputs
      await captureSnapshot(env, env.history, db, processedInput, entityOutbox, inputDescription);
    } else {
      console.log(`⚪ SKIP-FRAME: No serverTxs, entityInputs, or outputs - not creating empty frame`);
    }

    // Notify Svelte about environment changes
    console.log(`🔍 REPLICA-DEBUG: Before notifyEnvChange, total replicas: ${env.replicas.size}`);
    console.log(`🔍 REPLICA-DEBUG: Replica keys:`, Array.from(env.replicas.keys()));
    console.log(`🔍 GOSSIP-DEBUG: Environment keys before notify:`, Object.keys(env));
    console.log(`🔍 GOSSIP-DEBUG: Gossip layer exists:`, !!env.gossip);
    console.log(`🔍 GOSSIP-DEBUG: Gossip layer type:`, typeof env.gossip);
    console.log(`🔍 GOSSIP-DEBUG: Gossip announce method:`, typeof env.gossip?.announce);
    
    // CRITICAL FIX: Initialize gossip layer if missing
    if (!env.gossip) {
      console.log(`🚨 CRITICAL: gossip layer missing from environment, creating new one`);
      env.gossip = createGossipLayer();
      console.log(`✅ Gossip layer created and added to environment`);
    }

    // Compare old vs new entities
    const oldEntityKeys = Array.from(env.replicas.keys()).filter(
      key =>
        key.startsWith('0x0000000000000000000000000000000000000000000000000000000000000001:') ||
        key.startsWith('0x0000000000000000000000000000000000000000000000000000000000000002:'),
    );
    const newEntityKeys = Array.from(env.replicas.keys()).filter(
      key =>
        !key.startsWith('0x0000000000000000000000000000000000000000000000000000000000000001:') &&
        !key.startsWith('0x0000000000000000000000000000000000000000000000000000000000000002:') &&
        !key.startsWith('0x57e360b00f393ea6d898d6119f71db49241be80aec0fbdecf6358b0103d43a31:'),
    );

    console.log(`🔍 OLD-ENTITY-DEBUG: ${oldEntityKeys.length} old entities:`, oldEntityKeys.slice(0, 2));
    console.log(`🔍 NEW-ENTITY-DEBUG: ${newEntityKeys.length} new entities:`, newEntityKeys.slice(0, 2));

    if (oldEntityKeys.length > 0 && newEntityKeys.length > 0) {
      const oldReplicaKey = oldEntityKeys[0];
      const newReplicaKey = newEntityKeys[0];
      if (!oldReplicaKey || !newReplicaKey) {
        console.error(`❌ Invalid replica keys: old=${oldReplicaKey}, new=${newReplicaKey}`);
        // Continue with empty outbox instead of crashing
      } else {
      const oldReplica = env.replicas.get(oldReplicaKey);
      const newReplica = env.replicas.get(newReplicaKey);
      console.log(`🔍 OLD-REPLICA-STRUCTURE:`, {
        hasState: !!oldReplica?.state,
        hasConfig: !!oldReplica?.state?.config,
        hasJurisdiction: !!oldReplica?.state?.config?.jurisdiction,
        jurisdictionName: oldReplica?.state?.config?.jurisdiction?.name,
      });
      console.log(`🔍 NEW-REPLICA-STRUCTURE:`, {
        hasState: !!newReplica?.state,
        hasConfig: !!newReplica?.state?.config,
        hasJurisdiction: !!newReplica?.state?.config?.jurisdiction,
        jurisdictionName: newReplica?.state?.config?.jurisdiction?.name,
      });
      }
    }

    notifyEnvChange(env);

    if (DEBUG && entityOutbox.length > 0) {
      console.log(`📤 Outputs: ${entityOutbox.length} messages`);
      entityOutbox.forEach((output, i) => {
        console.log(
          `  ${i + 1}. → ${output.signerId} (${output.entityTxs ? `${output.entityTxs.length} txs` : ''}${output.proposedFrame ? ` proposal: ${output.proposedFrame.hash.slice(0, 10)}...` : ''}${output.precommits ? ` ${output.precommits.size} precommits` : ''})`,
        );
      });
    } else if (DEBUG && entityOutbox.length === 0) {
      console.log(`📤 No outputs generated`);
    }

    if (DEBUG) {
      console.log(`Replica states:`);
      env.replicas.forEach((replica, key) => {
        const [entityId, signerId] = key.split(':');
        if (!entityId || !signerId) return; // Skip malformed keys (use return in forEach)
        const entityDisplay = formatEntityDisplay(entityId);
        const signerDisplay = formatSignerDisplay(signerId);
        console.log(
          `  Entity #${entityDisplay}:${signerDisplay}: mempool=${replica.mempool.length}, messages=${replica.state.messages.length}, proposal=${replica.proposal ? '✓' : '✗'}`,
        );
      });
    }

    // Only create snapshots when there are meaningful changes AND we're not being called from processUntilEmpty
    // processUntilEmpty handles its own snapshot management to avoid duplicates
    const isProcessUntilEmptyCall = serverInput.serverTxs.length === 0 && serverInput.entityInputs.length > 0;

    if (!isProcessUntilEmptyCall && (serverInput.serverTxs.length > 0 || mergedInputs.length > 0)) {
      // Create a snapshot of the current environment state
      const snapshot = {
        replicas: new Map(env.replicas),
        height: env.height,
        timestamp: env.timestamp,
        serverInput: { serverTxs: [], entityInputs: [] },
        serverOutputs: [],
        description: `Frame ${env.height} snapshot`,
        gossip: env.gossip, // Include gossip for time-aware network tab
      };

      // Initialize history if needed
      if (!env.history) {
        env.history = [];
      }

      // Add snapshot to history
      env.history.push(snapshot);
      console.log(`📸 Frame ${env.height}: Snapshot added to history (${serverInput.serverTxs.length} serverTxs, ${mergedInputs.length} entityInputs)`);
    }

    // Always notify UI after processing a frame (this is the discrete simulation step)
    notifyEnvChange(env);

    // Performance logging
    const endTime = Date.now();
    if (DEBUG) {
      console.log(`⏱️  Tick ${env.height - 1} completed in ${endTime - startTime}ms`);
    }

    console.log(`🔍 APPLY-SERVER-INPUT-FINAL-RETURN: Returning ${entityOutbox.length} outputs, ${mergedInputs.length} mergedInputs`);
    return { entityOutbox, mergedInputs };
  } catch (error) {
    log.error(`❌ Error processing server input:`, error);
    return { entityOutbox: [], mergedInputs: [] };
  }
};

// This is the new, robust main function that replaces the old one.
const main = async (): Promise<Env> => {
  // DEBUG: Log jurisdictions content on startup using centralized loader
  if (!isBrowser) {
    try {
      const { loadJurisdictions } = await import('./jurisdiction-loader');
      const jurisdictions = loadJurisdictions();
      console.log('🔍 STARTUP: Current jurisdictions content (from centralized loader):');
      console.log('📍 Ethereum Depository:', jurisdictions.jurisdictions['ethereum']?.contracts?.depository);
      console.log('📍 Ethereum EntityProvider:', jurisdictions.jurisdictions['ethereum']?.contracts?.entityProvider);
      console.log('📍 Last updated:', jurisdictions.lastUpdated);
      console.log('📍 Full Ethereum config:', JSON.stringify(jurisdictions.jurisdictions['ethereum'], null, 2));
    } catch (error) {
      console.log('⚠️ Failed to load jurisdictions:', (error as Error).message);
    }
  }

  // Initialize gossip layer
  console.log('🕸️ Initializing gossip layer...');
  const gossipLayer = createGossipLayer();
  console.log('✅ Gossip layer initialized');

  // Load persisted profiles from database into gossip layer
  console.log('📡 Loading persisted profiles from database...');
  await loadPersistedProfiles(db, gossipLayer);

  // First, create default environment with gossip layer
  env = {
    replicas: new Map(),
    height: 0,
    timestamp: Date.now(),
    serverInput: { serverTxs: [], entityInputs: [] },
    history: [],
    gossip: gossipLayer,
  };

  // Then try to load saved state if available
  try {
    if (isBrowser) {
      console.log('🌐 BROWSER-DEBUG: Starting IndexedDB snapshot loading process...');
    } else {
      console.log('🖥️ Node.js environment: Attempting to load snapshots from filesystem...');
    }

    console.log('🔍 BROWSER-DEBUG: Querying latest_height from database...');
    const latestHeightBuffer = await db.get(Buffer.from('latest_height'));
    const latestHeight = parseInt(latestHeightBuffer.toString(), 10);
    console.log(`📊 BROWSER-DEBUG: Found latest height in DB: ${latestHeight}`);

    console.log(`📊 Found latest height: ${latestHeight}, loading ${latestHeight + 1} snapshots...`);

    // Load snapshots starting from 1 (height 0 is initial state, no snapshot saved)
    console.log(`📥 Loading snapshots: 1 to ${latestHeight}...`);
    const snapshots = [];

    // Start from 1 since height 0 is initial state with no snapshot
    for (let i = 1; i <= latestHeight; i++) {
      try {
        const buffer = await db.get(Buffer.from(`snapshot:${i}`));
        const snapshot = decode(buffer);
        snapshots.push(snapshot);
        console.log(`📦 Snapshot ${i}: loaded ${buffer.length} bytes`);
      } catch (error) {
        console.error(`❌ Failed to load snapshot ${i}:`, error);
        console.warn(`⚠️ Snapshot ${i} missing, continuing with available data...`);
      }
    }

    if (snapshots.length === 0) {
      console.log(`📦 No snapshots found (latestHeight: ${latestHeight}), using fresh environment`);
      throw new Error('LEVEL_NOT_FOUND');
    }

    console.log(`📊 Successfully loaded ${snapshots.length}/${latestHeight} snapshots (starting from height 1)`);
    env.history = snapshots;

    if (snapshots.length > 0) {
      const latestSnapshot = snapshots[snapshots.length - 1];

      // CRITICAL: Validate snapshot has proper replicas data
      if (!latestSnapshot.replicas) {
        console.warn('⚠️ Latest snapshot missing replicas data, using fresh environment');
        throw new Error('LEVEL_NOT_FOUND');
      }

      // Restore gossip profiles from snapshot
      const gossipLayer = createGossipLayer();
      if (latestSnapshot.gossip?.profiles) {
        for (const [id, profile] of Object.entries(latestSnapshot.gossip.profiles)) {
          gossipLayer.profiles.set(id, profile as Profile);
        }
        console.log(`📡 Restored gossip profiles: ${Object.keys(latestSnapshot.gossip.profiles).length} entries`);
      }

      // CRITICAL: Convert replicas to proper Map if needed (handle deserialization from DB)
      let replicasMap: Map<string, EntityReplica>;
      try {
        if (latestSnapshot.replicas instanceof Map) {
          replicasMap = latestSnapshot.replicas;
        } else if (latestSnapshot.replicas && typeof latestSnapshot.replicas === 'object') {
          // Deserialized from DB - convert object to Map
          replicasMap = new Map(Object.entries(latestSnapshot.replicas));
        } else {
          console.warn('⚠️ Invalid replicas format in snapshot, using fresh environment');
          throw new Error('LEVEL_NOT_FOUND');
        }
      } catch (conversionError) {
        console.error('❌ Failed to convert replicas to Map:', conversionError);
        console.warn('⚠️ Falling back to fresh environment');
        throw new Error('LEVEL_NOT_FOUND');
      }

      env = {
        // CRITICAL: Clone the replicas Map to avoid mutating snapshot data!
        replicas: new Map(Array.from(replicasMap).map(([key, replica]): [string, EntityReplica] => {
          return [key, cloneEntityReplica(replica)];
        })),
        height: latestSnapshot.height,
        timestamp: latestSnapshot.timestamp,
        // CRITICAL: serverInput must start EMPTY on restore!
        // The snapshot's serverInput was already processed
        serverInput: {
          serverTxs: [],
          entityInputs: []
        },
        history: snapshots, // Include the loaded history
        gossip: gossipLayer, // Use restored gossip layer
      };
      console.log(`✅ History restored. Server is at height ${env.height} with ${env.history.length} snapshots.`);
      console.log(`📈 Snapshot details:`, {
        height: env.height,
        replicaCount: env.replicas.size,
        timestamp: new Date(env.timestamp).toISOString(),
        serverInputs: env.serverInput.entityInputs.length,
      });
    }
  } catch (error: any) {
    // Handle various "not found" error conditions gracefully
    const isNotFoundError =
      error.code === 'LEVEL_NOT_FOUND' ||
      error.message?.includes('LEVEL_NOT_FOUND') ||
      error.message?.includes('NotFoundError') ||
      error.name === 'NotFoundError';

    if (isNotFoundError) {
      console.log('📦 No saved state found, using fresh environment');
      if (isBrowser) {
        console.log('💡 This is normal for first-time use. IndexedDB will be created automatically.');
      } else {
        console.log('💡 Node.js: No existing snapshots in db directory.');
      }
    } else {
      // Log the error but don't crash - fall back to fresh environment
      console.warn('⚠️ Error loading state from LevelDB (falling back to fresh environment):', error.message);
      console.log('🔍 Error type:', error.code || error.name || 'Unknown');

      if (DEBUG) {
        console.error('🔍 Full error details:', {
          code: error.code,
          name: error.name,
          message: error.message,
          isBrowser,
          dbLocation: isBrowser ? 'IndexedDB: db' : 'db',
        });
      }

      // Don't throw - just use fresh environment
      console.log('✅ Using fresh environment to continue startup');
    }
  }

  // Demo profiles are only initialized during runDemo - not by default

  // Only run demos in Node.js environment, not browser
  if (!isBrowser) {
    // DISABLED: Hanko tests during development
    console.log('\n🚀 Hanko tests disabled during development - focusing on core functionality');
    
    // // Add hanko demo to the main execution
    // console.log('\n🖋️  Testing Complete Hanko Implementation...');
    // await demoCompleteHanko();

    // // 🧪 Run basic Hanko functionality tests first
    // console.log('\n🧪 Running basic Hanko functionality tests...');
    // await runBasicHankoTests();

    // // 🧪 Run comprehensive Depository-Hanko integration tests
    // console.log('\n🧪 Running comprehensive Depository-Hanko integration tests...');
    // try {
    //   await runDepositoryHankoTests();
    // } catch (error) {
    //   console.log(
    //     'ℹ️  Depository integration tests skipped (contract setup required):',
    //     (error as Error).message?.substring(0, 100) || 'Unknown error',
    //   );
    // }
  } else {
    console.log('🌐 Browser environment: Demos available via UI buttons, not auto-running');
  }

  log.info(`🎯 Server startup complete. Height: ${env.height}, Entities: ${env.replicas.size}`);

  // Debug final state before starting j-watcher
  if (isBrowser) {
    console.log(`🔍 BROWSER-DEBUG: Final state before j-watcher start:`);
    console.log(`🔍   Environment height: ${env.height}`);
    console.log(`🔍   Total replicas: ${env.replicas.size}`);
    for (const [replicaKey, replica] of env.replicas.entries()) {
      const [entityId, signerId] = replicaKey.split(':');
      if (entityId && signerId) {
        console.log(`🔍   Entity ${entityId.slice(0,10)}... (${signerId}): jBlock=${replica.state.jBlock}, isProposer=${replica.isProposer}`);
      }
    }
  }

  // Start j-watcher after snapshots are fully loaded (prevent multiple instances)
  if (!jWatcherStarted) {
    try {
      console.log('🔭 STARTING-JWATCHER: Snapshots loaded, starting j-watcher...');
      await startJEventWatcher(env);
      jWatcherStarted = true;
      console.log('🔭 JWATCHER-READY: J-watcher started successfully');
    } catch (error) {
      console.error('❌ Failed to start J-Event Watcher:', error);
    }
  } else {
    console.log('🔭 JWATCHER-SKIP: J-watcher already started, skipping');
  }

  return env;
};

// === TIME MACHINE API ===
const getHistory = () => env.history || [];
const getSnapshot = (index: number) => {
  const history = env.history || [];
  return index >= 0 && index < history.length ? history[index] : null;
};
const getCurrentHistoryIndex = () => (env.history || []).length - 1;

// Server-specific clearDatabase that also resets history
const clearDatabaseAndHistory = async () => {
  console.log('🗑️ Clearing database and resetting server history...');

  // Clear the Level database
  await clearDatabase(db);

  // Reset the server environment to initial state (including history)
  env = {
    replicas: new Map(),
    height: 0,
    timestamp: Date.now(),
    serverInput: { serverTxs: [], entityInputs: [] },
    history: [],
    gossip: createGossipLayer(),
  };

  console.log('✅ Database and server history cleared');
};

// Export j-watcher status for frontend display
export const getJWatcherStatus = () => {
  if (!jWatcher || !env) return null;
  return {
    isWatching: jWatcher.getStatus().isWatching,
    proposers: Array.from(env.replicas.entries())
      .filter(([, replica]) => replica.isProposer)
      .map(([key, replica]) => {
        const [entityId, signerId] = key.split(':');
        if (!entityId || !signerId) {
          throw new Error(`Invalid replica key format: ${key}`);
        }
        return {
          entityId: entityId.slice(0,10) + '...',
          signerId,
          jBlock: replica.state.jBlock,
        };
      }),
    nextSyncIn: Math.floor((1000 - (Date.now() % 1000)) / 100) / 10, // Seconds until next 1s sync
  };
};

export {
  applyServerInput,
  assignNameOnChain,
  clearDatabase,
  clearDatabaseAndHistory,
  connectToEthereum,
  // Entity creation functions
  createLazyEntity,
  createNumberedEntity,
  createProfileUpdateTx,
  demoCompleteHanko,
  detectEntityType,
  encodeBoard,
  // Display and avatar functions
  formatEntityDisplay,
  formatSignerDisplay,
  generateEntityAvatar,
  // Entity utility functions
  generateLazyEntityId,
  generateNamedEntityId,
  generateNumberedEntityId,
  generateSignerAvatar,
  getAvailableJurisdictions,
  getCurrentHistoryIndex,
  getEntityDisplayInfo,
  getEntityDisplayInfoFromProfile,
  getEntityInfoFromChain,
  getHistory,
  getJurisdictionByAddress,
  getNextEntityNumber,
  getSignerDisplayInfo,
  getSnapshot,
  hashBoard,
  isEntityRegistered,
  main,
  // Blockchain registration functions
  registerNumberedEntityOnChain,
  requestNamedEntity,
  resolveEntityIdentifier,
  resolveEntityName,
  runDemo,
  runDemoWrapper,
  // Name resolution functions
  searchEntityNames,
  submitProcessBatch,
  submitPrefundAccount,
  submitSettle,
  submitReserveToReserve,
  debugFundReserves,
  transferNameBetweenEntities,
  // Account utilities (destructured from AccountUtils)
  deriveDelta,
  isLeft,
  getTokenInfo,
  formatTokenAmount,
  createDemoDelta,
  getDefaultCreditLimit,

  // Entity utilities (from entity-helpers and serialization-utils)
  getEntityNumber,
  safeStringify,

  // Financial utilities (ethers.js-based, precision-safe)
  formatTokenAmountEthers,
  parseTokenAmount,
  convertTokenPrecision,
  calculatePercentageEthers,
  formatAssetAmountEthers,
  BigIntMath,
  FINANCIAL_CONSTANTS,

  // Validation utilities (strict typing for financial data)
  validateDelta,
  validateAccountDeltas,
  createDefaultDelta,
  isDelta,

  // Snapshot utilities
  encode,
  decode,
  
  // Account messaging functions - TODO: Re-enable after fixing account-tx exports
  // sendAccountInputMessage,
  // sendDirectPaymentToEntity,
  // sendCreditLimitUpdateToEntity,
  // sendAccountAcknowledgment,
  // sendBatchAccountInputs,
  // getCrossEntityMessagingSummary,
  // validateAccountInputMessage,
};

// The browser-specific auto-execution logic has been removed.
// The consuming application (e.g., index.html) is now responsible for calling main().

// --- Node.js auto-execution for local testing ---
// This part will only run when the script is executed directly in Node.js.
if (!isBrowser) {
  main()
    .then(async env => {
      if (env) {
        // Check if demo should run automatically (can be disabled with NO_DEMO=1)
        const noDemoFlag = process.env['NO_DEMO'] === '1' || process.argv.includes('--no-demo');

        if (!noDemoFlag) {
          console.log('✅ Node.js environment initialized. Running demo for local testing...');
          console.log('💡 To skip demo, use: NO_DEMO=1 bun run src/server.ts or --no-demo flag');
          await runDemo(env);

          // Start j-watcher after demo completes
          await startJEventWatcher(env);

          // Add a small delay to ensure demo completes before verification
          setTimeout(async () => {
            await verifyJurisdictionRegistrations();
          }, 2000);
        } else {
          console.log('✅ Node.js environment initialized. Demo skipped (NO_DEMO=1 or --no-demo)');
          console.log('💡 Use XLN.runDemo(env) to run demo manually if needed');
          
          // J-watcher is already started in main(), no need to start again
        }
      }
    })
    .catch(error => {
      console.error('❌ An error occurred during Node.js auto-execution:', error);
    });
}

// === BLOCKCHAIN VERIFICATION ===
const verifyJurisdictionRegistrations = async () => {
  console.log('\n🔍 === JURISDICTION VERIFICATION ===');
  console.log('📋 Verifying entity registrations across all jurisdictions...\n');

  const jurisdictions = await getAvailableJurisdictions();

  for (const jurisdiction of jurisdictions) {
    try {
      console.log(`🏛️ ${jurisdiction.name}:`);
      console.log(`   📡 RPC: ${jurisdiction.address}`);
      console.log(`   📄 Contract: ${jurisdiction.entityProviderAddress}`);

      // Connect to this jurisdiction's network
      const { entityProvider } = await connectToEthereum(jurisdiction);

      // Get next entity number (indicates how many are registered)
      const nextNumber = await entityProvider['nextNumber']!();
      const registeredCount = Number(nextNumber) - 1;

      console.log(`   📊 Registered Entities: ${registeredCount}`);

      // Read registered entities
      if (registeredCount > 0) {
        console.log(`   📝 Entity Details:`);
        for (let i = 1; i <= registeredCount; i++) {
          try {
            const entityId = generateNumberedEntityId(i);
            const entityInfo = await entityProvider['entities']!(entityId);
            console.log(`      #${i}: ${entityId.slice(0, 10)}... (Block: ${entityInfo.registrationBlock})`);
          } catch (error) {
            console.log(`      #${i}: Error reading entity data`);
          }
        }
      }

      console.log('');
    } catch (error) {
      console.error(`   ❌ Failed to verify ${jurisdiction.name}:`, error instanceof Error ? error.message : error);
      console.log('');
    }
  }

  console.log('✅ Jurisdiction verification complete!\n');
};

// === HANKO DEMO FUNCTION ===

const demoCompleteHanko = async (): Promise<void> => {
  try {
    // Check if running in browser environment
    const isBrowser = typeof window !== 'undefined';

    if (isBrowser) {
      console.log('🎯 Browser environment detected - running simplified Hanko demo...');
      console.log('✅ Basic signature verification available');
      console.log('💡 Full test suite available in Node.js environment');
      console.log('✅ Hanko browser demo completed!');
      return;
    }

    console.log('🎯 Complete Hanko test suite disabled during strict TypeScript mode');
    // await runCompleteHankoTests();
    console.log('✅ Complete Hanko tests skipped!');
  } catch (error) {
    console.error('❌ Complete Hanko tests failed:', error);
    throw error;
  }
};

// Create a wrapper for runDemo that provides better browser feedback
const runDemoWrapper = async (env: any): Promise<any> => {
  try {
    console.log('🚀 Starting XLN Consensus Demo...');
    console.log('📊 This will demonstrate entity creation, consensus, and message passing');

    const result = await runDemo(env);

    console.log('✅ XLN Demo completed successfully!');
    console.log('🎯 Check the entity cards above to see the results');
    console.log('🕰️ Use the time machine to replay the consensus steps');

    // J-watcher is already started in main(), no need to start again

    return result;
  } catch (error) {
    console.error('❌ XLN Demo failed:', error);
    throw error;
  }
};

// === ENVIRONMENT UTILITIES ===
export const createEmptyEnv = (): Env => {
  return {
    replicas: new Map(),
    height: 0,
    timestamp: Date.now(),
    serverInput: { serverTxs: [], entityInputs: [] },
    history: [],
    gossip: createGossipLayer(),
  };
};

// === CONSENSUS PROCESSING UTILITIES ===
export const processUntilEmpty = async (env: Env, inputs?: EntityInput[]) => {
  let outputs = inputs || [];
  let iterationCount = 0;
  const maxIterations = 10; // Safety limit

  // Only log cascade details if there are outputs to process
  if (outputs.length > 0) {
    console.log('🔥 PROCESS-CASCADE: Starting with', outputs.length, 'initial outputs');

    // Log FULL entityIds for debugging routing issues
    outputs.forEach((o, idx) => {
      console.log(`📤 CASCADE-INPUT[${idx}]: FULL entityId="${o.entityId}", signerId="${o.signerId}", replicaKey="${o.entityId}:${o.signerId}"`);
    });

    console.log(
      '🔥 PROCESS-CASCADE: Initial outputs:',
      outputs.map(o => {
        // FINTECH-LEVEL TYPE SAFETY: Validate all financial routing inputs
        try {
          validateEntityInput(o);
        } catch (error) {
          console.error(`🚨 CRITICAL FINANCIAL ERROR: Invalid EntityInput detected!`, {
            error: (error as Error).message,
            input: o
          });
          throw error; // Re-throw to fail fast
        }

        return {
          entityId: o.entityId.slice(0, 8) + '...',
          signerId: o.signerId,
          txs: o.entityTxs?.length || 0,
          precommits: o.precommits?.size || 0,
          hasFrame: !!o.proposedFrame,
        };
      }),
    );
  }

  // DEBUG: Log transaction details for vote transactions
  outputs.forEach((output, i) => {
    if (output.entityTxs?.some(tx => tx.type === 'vote')) {
      console.log(
        `🗳️ VOTE-DEBUG: Input ${i + 1} contains vote transactions:`,
        output.entityTxs.filter(tx => tx.type === 'vote'),
      );
    }
  });

  while (outputs.length > 0 && iterationCount < maxIterations) {
    iterationCount++;
    console.log(`🔥 PROCESS-CASCADE: Iteration ${iterationCount} - processing ${outputs.length} outputs`);

    const result = await applyServerInput(env, { serverTxs: [], entityInputs: outputs });
    outputs = result.entityOutbox;

    console.log(`🔥 PROCESS-CASCADE: Iteration ${iterationCount} generated ${outputs.length} new outputs`);
    if (outputs.length > 0) {
      console.log(
        '🔥 PROCESS-CASCADE: New outputs:',
        outputs.map(o => ({
          entityId: o.entityId.slice(0, 8) + '...',
          signerId: o.signerId,
          txs: o.entityTxs?.length || 0,
          precommits: o.precommits?.size || 0,
          hasFrame: !!o.proposedFrame,
        })),
      );
    }
  }

  // Create a single snapshot after all iterations complete
  if (iterationCount > 0) {
    const snapshot = {
      replicas: new Map(env.replicas),
      height: env.height,
      timestamp: env.timestamp,
      serverInput: { serverTxs: [], entityInputs: [] },
      serverOutputs: [],
      description: `ProcessUntilEmpty frame ${env.height}`,
      gossip: env.gossip, // Include gossip for time-aware network tab
    };

    // Initialize history if needed
    if (!env.history) {
      env.history = [];
    }

    // Add snapshot to history
    env.history.push(snapshot);
    console.log(`📸 Frame ${env.height}: ProcessUntilEmpty snapshot added (after ${iterationCount} iterations)`);
  }

  if (iterationCount >= maxIterations) {
    console.warn('⚠️ processUntilEmpty reached maximum iterations');
  } else if (iterationCount > 0) {
    console.log(`🔥 PROCESS-CASCADE: Completed after ${iterationCount} iterations`);
  }

  return env;
};

// === PREPOPULATE FUNCTION ===
import { prepopulate } from './prepopulate';
export { prepopulate };

// === NAME RESOLUTION WRAPPERS (override imports) ===
const searchEntityNames = (query: string, limit?: number) => searchEntityNamesOriginal(db, query, limit);
const resolveEntityName = (entityId: string) => resolveEntityNameOriginal(db, entityId);
const getEntityDisplayInfoFromProfile = (entityId: string) => getEntityDisplayInfoFromProfileOriginal(db, entityId);

// Avatar functions are already imported and exported above

--- src/validation-utils.ts ---
/**
 * FINTECH-GRADE TYPE VALIDATION SYSTEM
 *
 * Core Principle: Validate at SOURCE, Trust at USE
 * - Data is validated ONCE at creation/entry points
 * - After validation, data can be used without defensive checks
 * - UI layer receives guaranteed-safe data structures
 * - Zero tolerance for undefined/null in financial flows
 */

import type {
  Delta,
  EntityInput,
  EntityState,
  AccountMachine,
  AccountFrame
} from './types';

/**
 * Strict validation for Delta objects - financial data must be complete
 */
export function validateDelta(delta: any, source: string = 'unknown'): Delta {
  if (!delta || typeof delta !== 'object') {
    throw new Error(`Invalid Delta object from ${source}: ${delta}`);
  }

  // Ensure all required properties exist and are proper types
  const errors: string[] = [];

  if (typeof delta.tokenId !== 'number' || !Number.isInteger(delta.tokenId) || delta.tokenId < 0) {
    errors.push(`tokenId must be non-negative integer, got: ${delta.tokenId}`);
  }

  // Validate all BigInt fields
  const bigintFields = ['collateral', 'ondelta', 'offdelta', 'leftCreditLimit', 'rightCreditLimit', 'leftAllowence', 'rightAllowence'];

  for (const field of bigintFields) {
    const value = delta[field];
    if (value === null || value === undefined) {
      errors.push(`${field} cannot be null/undefined, got: ${value}`);
    } else if (typeof value !== 'bigint') {
      // Try to convert if it's a string representation
      if (typeof value === 'string' && /^-?\d+n?$/.test(value)) {
        try {
          delta[field] = BigInt(value.replace(/n$/, ''));
        } catch (e) {
          errors.push(`${field} invalid BigInt string: ${value}`);
        }
      } else {
        errors.push(`${field} must be BigInt, got: ${typeof value} (${value})`);
      }
    }
  }

  if (errors.length > 0) {
    throw new Error(`Delta validation failed from ${source}:\n${errors.join('\n')}`);
  }

  // Ensure we return a properly typed Delta
  return {
    tokenId: delta.tokenId,
    collateral: delta.collateral,
    ondelta: delta.ondelta,
    offdelta: delta.offdelta,
    leftCreditLimit: delta.leftCreditLimit,
    rightCreditLimit: delta.rightCreditLimit,
    leftAllowence: delta.leftAllowence,
    rightAllowence: delta.rightAllowence,
  };
}

/**
 * Validate and fix account deltas Map
 */
export function validateAccountDeltas(deltas: any, source: string = 'unknown'): Map<number, Delta> {
  if (!deltas) {
    console.warn(`No deltas provided from ${source}, returning empty Map`);
    return new Map();
  }

  // Handle both Map and plain object formats
  const result = new Map<number, Delta>();

  if (deltas instanceof Map) {
    for (const [tokenId, delta] of deltas.entries()) {
      try {
        const validatedDelta = validateDelta(delta, `${source}.Map[${tokenId}]`);
        result.set(tokenId, validatedDelta);
      } catch (error) {
        console.error(`Skipping invalid delta for token ${tokenId}:`, error);
      }
    }
  } else if (typeof deltas === 'object') {
    // Handle serialized Map or plain object
    for (const [tokenIdStr, delta] of Object.entries(deltas)) {
      const tokenId = parseInt(tokenIdStr, 10);
      if (isNaN(tokenId)) {
        console.error(`Invalid tokenId: ${tokenIdStr}`);
        continue;
      }

      try {
        const validatedDelta = validateDelta(delta, `${source}.Object[${tokenId}]`);
        result.set(tokenId, validatedDelta);
      } catch (error) {
        console.error(`Skipping invalid delta for token ${tokenId}:`, error);
      }
    }
  } else {
    console.error(`Invalid deltas format from ${source}:`, typeof deltas);
    return new Map();
  }

  console.log(`✅ Validated ${result.size} deltas from ${source}`);
  return result;
}

/**
 * Create a safe default Delta object with proper BigInt values
 */
export function createDefaultDelta(tokenId: number): Delta {
  return {
    tokenId,
    collateral: 0n,
    ondelta: 0n,
    offdelta: 0n,
    leftCreditLimit: 1000000000000000000000000n, // 1M with 18 decimals
    rightCreditLimit: 1000000000000000000000000n,
    leftAllowence: 0n,
    rightAllowence: 0n,
  };
}

/**
 * Type guard for Delta objects
 */
export function isDelta(obj: any): obj is Delta {
  try {
    validateDelta(obj, 'type-guard');
    return true;
  } catch {
    return false;
  }
}

// ============================================================================
// FINTECH-LEVEL TYPE SAFETY: ROUTING INTEGRITY VALIDATION
// ============================================================================

/**
 * CRITICAL: Validate EntityInput has required routing identifiers
 * Never allow undefined entityId/signerId in financial flows
 */
export function validateEntityInput(input: any): EntityInput {
  if (!input) {
    throw new Error(`FINANCIAL-SAFETY: EntityInput is null/undefined`);
  }

  if (!input.entityId || typeof input.entityId !== 'string') {
    throw new Error(`FINANCIAL-SAFETY: entityId is missing or invalid - financial routing corruption detected`);
  }

  if (!input.signerId || typeof input.signerId !== 'string') {
    throw new Error(`FINANCIAL-SAFETY: signerId is missing or invalid - payment routing will fail`);
  }

  if (!input.entityTxs || !Array.isArray(input.entityTxs)) {
    throw new Error(`FINANCIAL-SAFETY: entityTxs is missing or invalid`);
  }

  return input as EntityInput;
}

/**
 * CRITICAL: Validate EntityOutput (same as EntityInput) has required routing identifiers
 * Ensure all outputs have proper routing data for financial flows
 */
export function validateEntityOutput(output: any): EntityInput {
  if (!output) {
    throw new Error(`FINANCIAL-SAFETY: EntityOutput is null/undefined`);
  }

  if (!output.entityId || typeof output.entityId !== 'string') {
    throw new Error(`FINANCIAL-SAFETY: EntityOutput entityId is missing - routing corruption`);
  }

  if (!output.signerId || typeof output.signerId !== 'string') {
    throw new Error(`FINANCIAL-SAFETY: EntityOutput signerId is missing - routing corruption`);
  }

  return output as EntityInput;
}

/**
 * CRITICAL: Validate payment route integrity
 * Ensure payment routing paths are complete and valid
 */
export function validatePaymentRoute(route: any): string[] {
  if (!route || !Array.isArray(route)) {
    throw new Error(`FINANCIAL-SAFETY: Payment route must be a valid array`);
  }

  if (route.length === 0) {
    throw new Error(`FINANCIAL-SAFETY: Payment route cannot be empty`);
  }

  for (let i = 0; i < route.length; i++) {
    const entityId = route[i];
    if (!entityId || typeof entityId !== 'string') {
      throw new Error(`FINANCIAL-SAFETY: Route[${i}] is invalid - entity ID required for financial routing`);
    }
  }

  return route as string[];
}

/**
 * CRITICAL: Safe Map.get() for financial data
 * Replace all financial Map.get(id)! with null-safe patterns
 */
export function safeMapGet<K, V>(map: Map<K, V>, key: K, context: string): V {
  const value = map.get(key);
  if (value === undefined) {
    throw new Error(`FINANCIAL-SAFETY: ${context} not found for key: ${key}`);
  }
  return value;
}

// =============================================================================
// ENHANCED ERROR CLASSES - Fail Fast, Fail Loud
// =============================================================================

export class FinancialDataCorruptionError extends Error {
  constructor(message: string, context?: Record<string, unknown>) {
    super(`🚨 FINANCIAL-SAFETY VIOLATION: ${message}`);
    this.name = 'FinancialDataCorruptionError';
    if (context) {
      this.message += `\nContext: ${JSON.stringify(context, (_k, v) => typeof v === 'bigint' ? v.toString() : v)}`;
    }
  }
}

export class TypeSafetyViolationError extends Error {
  constructor(message: string, value?: unknown) {
    super(`🛡️ TYPE-SAFETY VIOLATION: ${message}`);
    this.name = 'TypeSafetyViolationError';
    if (value !== undefined) {
      this.message += `\nReceived: ${typeof value} = ${String(value)}`;
    }
  }
}

// =============================================================================
// PRIMITIVE VALIDATORS - Building Blocks for Complex Types
// =============================================================================

function validateString(value: unknown, fieldName: string): string {
  if (typeof value !== 'string' || value.length === 0) {
    throw new TypeSafetyViolationError(`${fieldName} must be a non-empty string`, value);
  }
  return value;
}

// Removed unused validateBigInt function

function validateNumber(value: unknown, fieldName: string): number {
  if (typeof value !== 'number' || !Number.isFinite(value)) {
    throw new TypeSafetyViolationError(`${fieldName} must be a finite number`, value);
  }
  return value;
}

function validateObject(value: unknown, fieldName: string): Record<string, any> {
  if (!value || typeof value !== 'object' || Array.isArray(value)) {
    throw new TypeSafetyViolationError(`${fieldName} must be a non-null object`, value);
  }
  return value as Record<string, any>;
}

function validateArray<T>(value: unknown, fieldName: string): T[] {
  if (!Array.isArray(value)) {
    throw new TypeSafetyViolationError(`${fieldName} must be an array`, value);
  }
  return value;
}

// Removed unused validateMap function

// =============================================================================
// COMPREHENSIVE VALIDATORS - Complete Type Safety
// =============================================================================

/**
 * Validates AccountFrame objects - Consensus frames for bilateral accounts
 * CRITICAL: Frame integrity ensures consensus safety
 */
export function validateAccountFrame(value: unknown, context = 'AccountFrame'): AccountFrame {
  const obj = validateObject(value, context);

  const validated: AccountFrame = {
    frameId: validateNumber(obj['frameId'], `${context}.frameId`),
    timestamp: validateNumber(obj['timestamp'], `${context}.timestamp`),
    accountTxs: validateArray(obj['accountTxs'], `${context}.accountTxs`),
    previousStateHash: validateString(obj['previousStateHash'], `${context}.previousStateHash`),
    stateHash: validateString(obj['stateHash'], `${context}.stateHash`),
    tokenIds: validateArray<number>(obj['tokenIds'] || [], `${context}.tokenIds`),
    deltas: validateArray<bigint>(obj['deltas'] || [], `${context}.deltas`)
  };

  // Additional integrity checks
  if (validated.stateHash.length === 0) {
    throw new FinancialDataCorruptionError('AccountFrame.stateHash cannot be empty');
  }

  if (validated.timestamp <= 0) {
    throw new FinancialDataCorruptionError('AccountFrame.timestamp must be positive', { timestamp: validated.timestamp });
  }

  return validated;
}

/**
 * Validates AccountMachine objects - Bilateral account state machines
 * CRITICAL: Account integrity ensures payment routing safety
 */
export function validateAccountMachine(value: unknown, context = 'AccountMachine'): AccountMachine {
  const obj = validateObject(value, context);

  // This is a complex interface - for now just do basic validation
  // TODO: Implement full validation of all AccountMachine fields
  if (!obj['counterpartyEntityId'] || typeof obj['counterpartyEntityId'] !== 'string') {
    throw new FinancialDataCorruptionError(`${context}.counterpartyEntityId must be a string`);
  }

  if (!obj['deltas'] || !(obj['deltas'] instanceof Map)) {
    throw new FinancialDataCorruptionError(`${context}.deltas must be a Map`);
  }

  // Validate all deltas in the map
  for (const [tokenId, delta] of obj['deltas'].entries()) {
    validateDelta(delta, `${context}.deltas[${tokenId}]`);
  }

  return obj as AccountMachine; // Cast after basic validation
}

/**
 * Validates EntityState objects - Complete entity state
 * CRITICAL: Entity integrity ensures consensus and routing safety
 */
export function validateEntityState(value: unknown, context = 'EntityState'): EntityState {
  const obj = validateObject(value, context);

  // Basic validation - the interface is complex, so validate critical fields
  if (!obj['entityId'] || typeof obj['entityId'] !== 'string') {
    throw new FinancialDataCorruptionError(`${context}.entityId must be a string`);
  }

  if (typeof obj['height'] !== 'number') {
    throw new FinancialDataCorruptionError(`${context}.height must be a number`);
  }

  if (typeof obj['timestamp'] !== 'number') {
    throw new FinancialDataCorruptionError(`${context}.timestamp must be a number`);
  }

  if (!(obj['reserves'] instanceof Map)) {
    throw new FinancialDataCorruptionError(`${context}.reserves must be a Map`);
  }

  if (!(obj['accounts'] instanceof Map)) {
    throw new FinancialDataCorruptionError(`${context}.accounts must be a Map`);
  }

  // Validate all reserves are valid bigints
  for (const [tokenId, amount] of obj['reserves'].entries()) {
    if (typeof amount !== 'bigint') {
      throw new FinancialDataCorruptionError(`Reserve amount for token ${tokenId} must be bigint`, { tokenId, amount });
    }
  }

  return obj as EntityState; // Cast after basic validation
}

// Config validation removed - ConsensusConfig is more complex than expected

// EntityReplica validation removed - interface too complex for now

// =============================================================================
// ENHANCED SAFE COLLECTION ACCESS
// =============================================================================

/**
 * Safe Map.get() with validation for financial data
 */
export function safeMapGetFinancial<K, V>(
  map: Map<K, V>,
  key: K,
  validator: (value: unknown, context: string) => V,
  context: string
): V {
  const value = map.get(key);
  if (value === undefined) {
    throw new FinancialDataCorruptionError(`Missing financial data in ${context}`, { key: String(key) });
  }
  return validator(value, `${context}[${String(key)}]`);
}

/**
 * Safe array access with bounds checking
 */
export function safeArrayGet<T>(array: T[], index: number, context: string): T {
  if (index < 0 || index >= array.length) {
    throw new TypeSafetyViolationError(`Array index out of bounds in ${context}`, { index, length: array.length });
  }
  return array[index]!; // Add non-null assertion to fix TypeScript issue
}

/**
 * Validates an entity ID string
 */
export function validateEntityId(value: unknown, context: string): string {
  const entityId = validateString(value, context);
  if (entityId.includes('undefined')) {
    throw new FinancialDataCorruptionError(`${context} contains 'undefined' - routing corruption detected`, { entityId });
  }
  return entityId;
}
--- src/run-hanko-tests.ts ---
/**
 * Simple runner for Hanko tests
 */

import { runBasicHankoTests } from './test-hanko-basic';

async function main() {
  console.log('🚀 Starting Hanko Tests...\n');

  const success = await runBasicHankoTests();

  if (success) {
    console.log('\n✅ ALL HANKO TESTS PASSED!');
    console.log('🎯 Summary:');
    console.log('  ✅ Hanko building works with placeholders + packedSignatures + claims');
    console.log('  ✅ Multiple signatures verified with real ecrecover');
    console.log('  ✅ ABI encoding compatible with Solidity');
    console.log('  ✅ Complex Hanko structures (mixed placeholders/signatures/claims)');
    console.log('  ✅ Signature verification with ethers.js compatibility');
    console.log('\n🔒 SECURITY VERIFIED:');
    console.log('  ✅ All signatures use real secp256k1 cryptography');
    console.log('  ✅ No off-chain trust assumptions');
    console.log('  ✅ Domain separation prevents replay attacks');
    console.log('  ✅ EVM-style sequential nonces');
  } else {
    console.log('\n❌ SOME TESTS FAILED!');
  }

  if (typeof process !== 'undefined') {
    process.exit(success ? 0 : 1);
  }
}

main().catch(console.error);

--- src/entity-factory.ts ---
/**
 * XLN Entity Factory
 * Entity creation, ID generation, and entity utility functions
 */

import { ethers } from 'ethers';

import { ConsensusConfig, EntityType, JurisdictionConfig } from './types';
import { DEBUG } from './utils';

// Extend globalThis to include our entity counter
declare global {
  // eslint-disable-next-line no-var
  var _entityCounter: number | undefined;
}

// Entity encoding utilities
export const encodeBoard = (config: ConsensusConfig): string => {
  const delegates = config.validators.map(validator => ({
    entityId: validator, // For EOA addresses (20 bytes)
    votingPower: Number(config.shares[validator] || 1n),
  }));

  const board = {
    votingThreshold: Number(config.threshold),
    delegates: delegates,
  };

  // Return JSON representation that can be hashed consistently
  return JSON.stringify(board, Object.keys(board).sort());
};

export const hashBoard = (encodedBoard: string): string => {
  // Use real keccak256 hash like Ethereum
  return ethers.keccak256(ethers.toUtf8Bytes(encodedBoard));
};

export const generateLazyEntityId = (
  validators: { name: string; weight: number }[] | string[],
  threshold: bigint,
): string => {
  // Create deterministic entity ID from quorum composition
  let validatorData: { name: string; weight: number }[];

  // Handle both formats: array of objects or array of strings (assume weight=1)
  if (typeof validators[0] === 'string') {
    validatorData = (validators as string[]).map(name => ({ name, weight: 1 }));
  } else {
    validatorData = validators as { name: string; weight: number }[];
  }

  // Sort by name for canonical ordering
  const sortedValidators = validatorData.slice().sort((a, b) => a.name.localeCompare(b.name));

  const quorumData = {
    validators: sortedValidators,
    threshold: threshold.toString(),
  };

  const serialized = JSON.stringify(quorumData);
  return hashBoard(serialized);
};

export const generateNumberedEntityId = (entityNumber: number): string => {
  // Convert number to bytes32 (left-padded with zeros)
  return `0x${entityNumber.toString(16).padStart(64, '0')}`;
};

export const generateNamedEntityId = (name: string): string => {
  // For named entities: entityId resolved via name lookup on-chain
  // This is just for client-side preview
  return hashBoard(name);
};

export const detectEntityType = (entityId: string): EntityType => {
  // Check if this is a hex string (0x followed by hex digits)
  if (entityId.startsWith('0x') && entityId.length === 66) {
    try {
      const num = BigInt(entityId);

      // Small positive numbers = numbered entities
      if (num > 0n && num < 1000000n) {
        return 'numbered';
      }

      // Very large numbers are lazy entity hashes
      return 'lazy';
    } catch {
      return 'lazy';
    }
  }

  // Check if this is a numeric string before trying BigInt conversion
  if (/^[0-9]+$/.test(entityId)) {
    try {
      const num = BigInt(entityId);

      // Small positive numbers = numbered entities
      if (num > 0n && num < 1000000n) {
        return 'numbered';
      }

      // Very large numbers might be lazy entity hashes
      return 'lazy';
    } catch {
      return 'lazy';
    }
  }

  // Non-numeric, non-hex strings are lazy entities
  return 'lazy';
};

export const extractNumberFromEntityId = (entityId: string): number => {
  if (!entityId || typeof entityId !== 'string') {
    throw new Error(`FINTECH-SAFETY: Invalid entityId type: ${typeof entityId}`);
  }

  // Check if this is a hex string (0x followed by hex digits)
  if (entityId.startsWith('0x') && entityId.length === 66) {
    try {
      const num = BigInt(entityId);

      // Check if it's a numbered entity (small positive number)
      if (num > 0n && num < 1000000n) {
        return Number(num);
      }

      // For lazy entities: generate deterministic display number from hash
      // Take last 4 bytes and convert to display number (always positive)
      const hashSuffix = entityId.slice(-8); // Last 4 bytes as hex
      const displayNum = parseInt(hashSuffix, 16) % 9000000 + 1000000; // 1M-10M range
      return displayNum;
    } catch (error) {
      throw new Error(`FINTECH-SAFETY: Invalid entityId format: ${entityId} - ${error}`);
    }
  }

  // Check if this is a numeric string before trying BigInt conversion
  if (/^[0-9]+$/.test(entityId)) {
    try {
      const num = BigInt(entityId);

      // Check if it's a numbered entity (small positive number)
      if (num > 0n && num < 1000000n) {
        return Number(num);
      }

      // Large numeric strings - use modulo for display
      const displayNum = Number(num % 9000000n + 1000000n);
      return displayNum;
    } catch (error) {
      throw new Error(`FINTECH-SAFETY: Invalid numeric entityId: ${entityId} - ${error}`);
    }
  }

  throw new Error(`FINTECH-SAFETY: EntityId must be hex or numeric, got: ${entityId}`);
};

// 1. LAZY ENTITIES (Free, instant)
export const createLazyEntity = (
  name: string,
  validators: string[],
  threshold: bigint,
  jurisdiction?: JurisdictionConfig,
): ConsensusConfig => {
  const entityId = generateLazyEntityId(validators, threshold);

  if (DEBUG) console.log(`🔒 Creating lazy entity: ${name}`);
  if (DEBUG) console.log(`   EntityID: ${entityId} (quorum hash)`);
  if (DEBUG) console.log(`   Validators: ${validators.join(', ')}`);
  if (DEBUG) console.log(`   Threshold: ${threshold}`);
  if (DEBUG) console.log(`   🆓 FREE - No gas required`);

  const shares: { [validatorId: string]: bigint } = {};
  validators.forEach(validator => {
    shares[validator] = 1n; // Equal voting power for simplicity
  });

  const config: ConsensusConfig = {
    mode: 'proposer-based',
    threshold,
    validators,
    shares,
    ...(jurisdiction && { jurisdiction }),
  };
  return config;
};

// 2. NUMBERED ENTITIES (Small gas cost)
export const createNumberedEntity = async (
  name: string,
  validators: string[],
  threshold: bigint,
  jurisdiction: JurisdictionConfig,
): Promise<{ config: ConsensusConfig; entityNumber: number; entityId: string }> => {
  if (!jurisdiction) {
    throw new Error('Jurisdiction required for numbered entity registration');
  }

  const boardHash = hashBoard(
    encodeBoard({
      mode: 'proposer-based',
      threshold,
      validators,
      shares: validators.reduce((acc, v) => ({ ...acc, [v]: 1n }), {}),
      jurisdiction,
    }),
  );

  if (DEBUG) console.log(`🔢 Creating numbered entity: ${name}`);
  if (DEBUG) console.log(`   Board Hash: ${boardHash}`);
  if (DEBUG) console.log(`   Jurisdiction: ${jurisdiction.name}`);
  if (DEBUG) console.log(`   💸 Gas required for registration`);

  // Get the next entity number from the blockchain
  const { getNextEntityNumber, registerNumberedEntityOnChain } = await import('./evm');

  try {
    // First, get the next available entity number from the blockchain
    await getNextEntityNumber(jurisdiction);

    // Register the entity on-chain with its board configuration
    const { entityNumber } = await registerNumberedEntityOnChain(
      { mode: 'proposer-based', threshold, validators, shares: validators.reduce((acc, v) => ({ ...acc, [v]: 1n }), {}), jurisdiction },
      name
    );

    const entityId = generateNumberedEntityId(entityNumber);

    if (DEBUG) console.log(`   ✅ Registered Entity Number: ${entityNumber}`);
    if (DEBUG) console.log(`   EntityID: ${entityId}`);

    const shares: { [validatorId: string]: bigint } = {};
    validators.forEach(validator => {
      shares[validator] = 1n;
    });

    const config: ConsensusConfig = {
      mode: 'proposer-based',
      threshold,
      validators,
      shares,
      jurisdiction,
    };

    return { config, entityNumber, entityId };
  } catch (error) {
    console.error('❌ Failed to register numbered entity on blockchain:', error);
    throw error;
  }
};

// 3. NAMED ENTITIES (Premium - admin assignment required)
export const requestNamedEntity = async (
  name: string,
  entityNumber: number,
  jurisdiction: JurisdictionConfig,
): Promise<string> => {
  if (!jurisdiction) {
    throw new Error('Jurisdiction required for named entity');
  }

  if (DEBUG) console.log(`🏷️ Requesting named entity assignment`);
  if (DEBUG) console.log(`   Name: ${name}`);
  if (DEBUG) console.log(`   Target Entity Number: ${entityNumber}`);
  if (DEBUG) console.log(`   Jurisdiction: ${jurisdiction.name}`);
  if (DEBUG) console.log(`   👑 Requires admin approval`);

  // Simulate admin assignment request
  const requestId = `req_${Math.random().toString(16).substring(2, 10)}`;

  if (DEBUG) console.log(`   📝 Name assignment request submitted: ${requestId}`);
  if (DEBUG) console.log(`   ⏳ Waiting for admin approval...`);

  return requestId;
};

// Entity resolution (client-side)
export const resolveEntityIdentifier = async (identifier: string): Promise<{ entityId: string; type: EntityType }> => {
  // Handle different input formats
  if (identifier.startsWith('#')) {
    // #42 -> numbered entity
    const number = parseInt(identifier.slice(1));
    return {
      entityId: generateNumberedEntityId(number),
      type: 'numbered',
    };
  } else if (/^\d+$/.test(identifier)) {
    // 42 -> numbered entity
    const number = parseInt(identifier);
    return {
      entityId: generateNumberedEntityId(number),
      type: 'numbered',
    };
  } else if (identifier.startsWith('0x')) {
    // 0x123... -> direct entity ID
    return {
      entityId: identifier,
      type: detectEntityType(identifier),
    };
  } else {
    // "coinbase" -> named entity (requires on-chain lookup)
    // For demo, simulate lookup
    if (DEBUG) console.log(`🔍 Looking up named entity: ${identifier}`);

    // Simulate on-chain name resolution
    const simulatedNumber = identifier === 'coinbase' ? 42 : 0;
    if (simulatedNumber > 0) {
      return {
        entityId: generateNumberedEntityId(simulatedNumber),
        type: 'named',
      };
    } else {
      throw new Error(`Named entity "${identifier}" not found`);
    }
  }
};

export const isEntityRegistered = async (entityId: string): Promise<boolean> => {
  const type = detectEntityType(entityId);

  // Lazy entities are never "registered" - they exist by definition
  if (type === 'lazy') {
    return false;
  }

  // Numbered and named entities require on-chain verification
  // For demo, assume they exist if they're small numbers
  if (!/^[0-9]+$/.test(entityId)) {
    return false; // Non-numeric IDs are not registered
  }

  try {
    const num = BigInt(entityId);
    return num > 0n && num < 1000000n;
  } catch {
    return false;
  }
};

